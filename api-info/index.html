{"posts":[{"fileName":"图像、视频的格式","abstract":"","description":"图像格式 世界上图像格式有很多，但Web上常用的只是其中的3种：jpeg、png、gif。 一般而言，相同质量下，jpeg照片一般比png、gif要小。对于logo图片，使用png或者gif一般而言效果更好，文件也可能更小。 PNG是最新...","title":"图像、视频的格式","tags":[{"name":"html","slug":"wIxVuXypZ","used":true,"link":"https://shaoyihao.github.io/blog/wIxVuXypZ/"}],"feature":"","link":"https://shaoyihao.github.io/blog/图像、视频的格式/","stats":{"text":"2 min read","time":114000,"words":533,"minutes":2},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E5%9B%BE%E5%83%8F%E6%A0%BC%E5%BC%8F\">图像格式</a></li>\n<li><a href=\"#%E8%A7%86%E9%A2%91%E6%A0%BC%E5%BC%8F\">视频格式</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2022-09-24 13:56:31","dateFormat":"2022-09-24"},{"fileName":"一些html5标签","abstract":"","description":"html5新增标签 article、nav、header、footer、time、aside、section、video、audio、progress、mark、meter、canvas、figure、main... 这些标签用&lt;di...","title":"一些标签(2)","tags":[{"name":"html","slug":"wIxVuXypZ","used":true,"link":"https://shaoyihao.github.io/blog/wIxVuXypZ/"}],"feature":"","link":"https://shaoyihao.github.io/blog/一些html5标签/","stats":{"text":"3 min read","time":125000,"words":542,"minutes":3},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#html5%E6%96%B0%E5%A2%9E%E6%A0%87%E7%AD%BE\">html5新增标签</a>\n<ul>\n<li><a href=\"#time\">time</a></li>\n<li><a href=\"#audio\">audio</a></li>\n<li><a href=\"#video\">video</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2022-09-24 13:47:35","dateFormat":"2022-09-24"},{"fileName":"一些html标签","abstract":"","description":"元素的属性 元素一般会具有属性，属性用于提供元素的一些附加信息。属性之间的顺序任意。 属性总是以名称/值对的形式出现，比如：name=&quot;value&quot;。注意：属性值应该始终被包括在引号内。 HTML全称是“hyperte...","title":"一些标签(1)","tags":[{"name":"html","slug":"wIxVuXypZ","used":true,"link":"https://shaoyihao.github.io/blog/wIxVuXypZ/"}],"feature":"","link":"https://shaoyihao.github.io/blog/一些html标签/","stats":{"text":"9 min read","time":502000,"words":2197,"minutes":9},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E5%85%83%E7%B4%A0%E7%9A%84%E5%B1%9E%E6%80%A7\">元素的属性</a></li>\n<li><a href=\"#%E4%B8%80%E4%BA%9B%E6%A0%87%E7%AD%BE\">一些标签</a>\n<ul>\n<li><a href=\"#%E5%85%B6%E5%AE%83%E6%A0%87%E7%AD%BE\">其它标签</a></li>\n<li><a href=\"#%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6\">特殊字符</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2022-09-24 13:38:55","dateFormat":"2022-09-24"},{"fileName":"关于html","abstract":"","description":"html与浏览器 html文件、图片、视频...存储在web服务器上，浏览器可以通过互联网向web服务器发起请求。服务器收到这些请求时，会查找所请求的资源（html文档等）并将找到的资源发回浏览器，浏览器再显示出该页面。 浏览器怎么知道如何...","title":"关于html","tags":[{"name":"html","slug":"wIxVuXypZ","used":true,"link":"https://shaoyihao.github.io/blog/wIxVuXypZ/"}],"feature":"","link":"https://shaoyihao.github.io/blog/关于html/","stats":{"text":"5 min read","time":289000,"words":1293,"minutes":5},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#html%E4%B8%8E%E6%B5%8F%E8%A7%88%E5%99%A8\">html与浏览器</a></li>\n<li><a href=\"#html%E6%96%87%E6%A1%A3%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84\">html文档的基本结构</a>\n<ul>\n<li><a href=\"#head\">head</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%85%B3%E4%BA%8Ehtml5\">关于html5</a></li>\n<li><a href=\"#%E9%A1%B9%E7%9B%AE%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%84%E7%BB%87\">项目文件的组织</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2022-09-24 13:33:16","dateFormat":"2022-09-24"},{"fileName":"VMware+Ubuntu","abstract":"","description":"安装VMware与Ubuntu 首先在Ubuntu官网上下载系统文件：下载链接 再安装VMware虚拟机软件：官网链接 VMware Workstation Pro正版是收费的，VMware Workstation Player...","title":"Windows下安装虚拟机：VMware+Ubuntu","tags":[{"name":"Unix/Linux","slug":"2c0Sh6Yfq","used":true,"link":"https://shaoyihao.github.io/blog/2c0Sh6Yfq/"}],"feature":"","link":"https://shaoyihao.github.io/blog/VMware+Ubuntu/","stats":{"text":"4 min read","time":222000,"words":928,"minutes":4},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E5%AE%89%E8%A3%85vmware%E4%B8%8Eubuntu\">安装VMware与Ubuntu</a></li>\n<li><a href=\"#%E4%BF%AE%E6%94%B9apt%E6%BA%90\">修改apt源</a></li>\n<li><a href=\"#%E5%AF%B9%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%9B%E8%A1%8C%E4%B8%80%E4%BA%9B%E9%85%8D%E7%BD%AE\">对虚拟机进行一些配置</a>\n<ul>\n<li><a href=\"#vim%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE\">vim的安装与配置</a></li>\n<li><a href=\"#filezilla%E8%BF%9E%E6%8E%A5%E8%99%9A%E6%8B%9F%E6%9C%BA\">Filezilla连接虚拟机</a></li>\n<li><a href=\"#%E5%BC%80%E5%90%AFftp%E6%9C%8D%E5%8A%A1\">开启FTP服务</a></li>\n<li><a href=\"#ssh%E9%85%8D%E7%BD%AE%E4%B8%8Eputty%E8%BF%9E%E6%8E%A5\">ssh配置与Putty连接</a></li>\n<li><a href=\"#%E5%AE%89%E8%A3%85java\">安装java</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2022-09-22 15:21:55","dateFormat":"2022-09-22"},{"fileName":"Linux环境变量","abstract":"","description":"什么是环境变量？ 环境变量简单的说就是当前环境下的参数或者变量。如果说的专业一点就是指在操作系统中用来指定操作系统的一些参数。 举个我们最常见的环境变量 —— PATH，它的用途就是当用户要求系统运行一个程序而没有告诉它程序所在的完整路径时...","title":"Linux环境变量","tags":[{"name":"Unix/Linux","slug":"2c0Sh6Yfq","used":true,"link":"https://shaoyihao.github.io/blog/2c0Sh6Yfq/"}],"feature":"","link":"https://shaoyihao.github.io/blog/Linux环境变量/","stats":{"text":"3 min read","time":148000,"words":678,"minutes":3},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F\">什么是环境变量？</a></li>\n<li><a href=\"#%E5%9C%A8-linux-%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95\">在 Linux 系统下配置环境变量最常用的两种方法：</a>\n<ul>\n<li><a href=\"#%E4%BF%AE%E6%94%B9%E5%AE%B6%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84-bashrc-%E6%96%87%E4%BB%B6\">修改家目录下的 .bashrc 文件</a></li>\n<li><a href=\"#%E4%BF%AE%E6%94%B9-etcprofile-%E6%96%87%E4%BB%B6\">修改 /etc/profile 文件</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%AF%B9%E6%AF%94%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95\">对比两种方法</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2022-09-22 15:15:53","dateFormat":"2022-09-22"},{"fileName":"数列极限","abstract":"","description":" 数列a1,a2,...,an,...a_1,a_2,...,a_n,...a1​,a2​,...,an​,...本质上就是一个定义域为 N+N_+N+​ 的 离散函数 的值域。 ax=f(x), x∈N+a_x=f(x),\\ \\ \\...","title":"数列极限","tags":[{"name":"微积分","slug":"i8TzGFf2j","used":true,"link":"https://shaoyihao.github.io/blog/i8TzGFf2j/"}],"feature":"","link":"https://shaoyihao.github.io/blog/数列极限/","stats":{"text":"18 min read","time":1049000,"words":3469,"minutes":18},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E6%A0%B9%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%81%E6%98%8E%E6%95%B0%E5%88%97%E6%9E%81%E9%99%90\">根据定义证明数列极限</a></li>\n<li><a href=\"#%E9%87%8D%E8%A6%81%E7%9A%84%E6%95%B0%E5%88%97%E6%9E%81%E9%99%90\">重要的数列极限</a></li>\n<li><a href=\"#%E6%94%B6%E6%95%9B%E6%95%B0%E5%88%97%E7%9A%84%E6%80%A7%E8%B4%A8\">收敛数列的性质</a></li>\n<li><a href=\"#%E5%88%A4%E6%96%AD%E6%95%B0%E5%88%97%E6%94%B6%E6%95%9B%E7%9A%842%E6%9D%A1%E5%87%86%E5%88%99\">判断数列收敛的2条准则</a>\n<ul>\n<li><a href=\"#%E5%A4%B9%E9%80%BC%E5%AE%9A%E7%90%86\"><strong>夹逼定理</strong></a></li>\n<li><a href=\"#%E5%8D%95%E8%B0%83%E6%9C%89%E7%95%8C%E5%8E%9F%E7%90%86\"><strong>单调有界原理</strong></a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%AD%90%E6%95%B0%E5%88%97\">子数列</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2022-09-19 21:54:48","dateFormat":"2022-09-19"},{"fileName":"关于开源","abstract":"","description":"简单来说，开源软件的特点就是把软件程序与源代码文件一起打包提供给用户，让用户在不受限制地使用某个软件功能的基础上还可以按需进行修改，或编制成衍生产品再发布出去。用户具有使用自由、修改自由、重新发布自由以及创建衍生品的自由。 开源软件最重要的...","title":"关于开源","tags":[{"name":"其它","slug":"CZufz5lnM","used":true,"link":"https://shaoyihao.github.io/blog/CZufz5lnM/"}],"feature":"","link":"https://shaoyihao.github.io/blog/关于开源/","stats":{"text":"4 min read","time":236000,"words":1146,"minutes":4},"isTop":false,"toc":"","date":"2022-09-16 13:50:35","dateFormat":"2022-09-16"},{"fileName":"数制","abstract":"","description":" 每一位的权由基数的幂次决定，不同位上的数有着不同的权值，这称为位权表示法，同时基数也代表着数码的个数。 特点为： 基数为 RRR 的数制中，包含 0,1,...,R−10,1,...,R-10,1,...,R−1 共 RRR 个数码 每...","title":"数制","tags":[{"name":"计算机组成原理","slug":"xWT85UO9c","used":true,"link":"https://shaoyihao.github.io/blog/xWT85UO9c/"}],"feature":"","link":"https://shaoyihao.github.io/blog/数制/","stats":{"text":"6 min read","time":358000,"words":1409,"minutes":6},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E5%8C%96%E4%B8%BAk%E8%BF%9B%E5%88%B6%E6%95%B0\">十进制转化为k进制数</a>\n<ul>\n<li><a href=\"#%E4%BA%8C%E8%BF%9B%E5%88%B6-%E5%85%AB%E8%BF%9B%E5%88%B6-%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2\">二进制、八进制、十六进制之间的转换</a></li>\n</ul>\n</li>\n<li><a href=\"#%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6\">计算机中使用二进制</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2022-09-14 14:59:57","dateFormat":"2022-09-14"},{"fileName":"选出最多的数","abstract":"","description":" 原题链接：钻石收藏家 题目大意：在nnn个数中选出最多的数，满足任意两数的差值≤k\\le k≤k。 思路： 首先将这nnn个数进行从小到大排序。 对于元素aia_iai​，使指针jjj指向最远的满足aj−ai≤ka_j-a_i\\le ...","title":"选出最多的数","tags":[{"name":"双指针","slug":"_ryZST3v0","used":true,"link":"https://shaoyihao.github.io/blog/_ryZST3v0/"},{"name":"排序","slug":"C8jTnsHs8","used":true,"link":"https://shaoyihao.github.io/blog/C8jTnsHs8/"}],"feature":"","link":"https://shaoyihao.github.io/blog/选出最多的数/","stats":{"text":"4 min read","time":237000,"words":803,"minutes":4},"isTop":false,"toc":"","date":"2022-09-13 21:02:24","dateFormat":"2022-09-13"},{"fileName":"替换空格","abstract":"","description":" 原题链接：替换空格 题目大意：请实现一个函数，把字符串中的每个空格替换成&quot;%20&quot; (线性扫描) O(n)O(n)O(n) 这个题在 C++ 里比较好做，我们可以从前往后枚举原字符串： 如果遇到空格，则在 stri...","title":"替换空格","tags":[{"name":"双指针","slug":"_ryZST3v0","used":true,"link":"https://shaoyihao.github.io/blog/_ryZST3v0/"}],"feature":"","link":"https://shaoyihao.github.io/blog/替换空格/","stats":{"text":"3 min read","time":125000,"words":518,"minutes":3},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E7%BA%BF%E6%80%A7%E6%89%AB%E6%8F%8F-on\">(线性扫描) <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">)</span></span></span></span></a></li>\n<li><a href=\"#%E5%8F%8C%E6%8C%87%E9%92%88%E6%89%AB%E6%8F%8F-on\">(双指针扫描) <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(n)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">)</span></span></span></span></a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2022-09-13 20:56:21","dateFormat":"2022-09-13"},{"fileName":"最长连续不重复子列","abstract":"","description":" 原题链接：最长连续不重复子列 题目大意：给定一个长度为 nnn 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。 即每次处理的是区间[j,i][j,i][j,i]中的元素，判断该区间（子列)中是否含有重复元素。由于ii...","title":"最长连续不重复子列","tags":[{"name":"双指针","slug":"_ryZST3v0","used":true,"link":"https://shaoyihao.github.io/blog/_ryZST3v0/"}],"feature":"","link":"https://shaoyihao.github.io/blog/最长连续不重复子列/","stats":{"text":"2 min read","time":95000,"words":369,"minutes":2},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li>\n<ul>\n<li>\n<ul>\n<li></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2022-09-13 20:34:51","dateFormat":"2022-09-13"},{"fileName":"输出被空格隔开的单词","abstract":"","description":" int main() { char str[1000]; gets(str); int n = strlen(str); for (int i = 0; i &lt; n; i ++) { int j = i; whil...","title":"输出被空格隔开的单词","tags":[{"name":"双指针","slug":"_ryZST3v0","used":true,"link":"https://shaoyihao.github.io/blog/_ryZST3v0/"}],"feature":"","link":"https://shaoyihao.github.io/blog/输出被空格隔开的单词/","stats":{"text":"1 min read","time":19000,"words":52,"minutes":1},"isTop":false,"toc":"","date":"2022-09-13 20:32:10","dateFormat":"2022-09-13"},{"fileName":"双指针","abstract":"","description":"双指针算法大体上分为两类: 两个指针指向两个序列 两个指针指向同一个序列，操作的是同一个序列中的不同区间 通常的写法： for (i = 0, j = k; i &lt; n; i ++)//i遍历一遍 { while (j &lt;...","title":"双指针算法","tags":[{"name":"双指针","slug":"_ryZST3v0","used":true,"link":"https://shaoyihao.github.io/blog/_ryZST3v0/"},{"name":"模板","slug":"O4BIFblmXJ","used":true,"link":"https://shaoyihao.github.io/blog/O4BIFblmXJ/"}],"feature":"","link":"https://shaoyihao.github.io/blog/双指针/","stats":{"text":"1 min read","time":48000,"words":206,"minutes":1},"isTop":false,"toc":"","date":"2022-09-13 20:30:15","dateFormat":"2022-09-13"},{"fileName":"子序列","abstract":"","description":" 原题链接：子序列 题目大意：给定2个序列SSS和ppp，判断ppp是否为SSS的子序列。（SSS的长度一定大于等于ppp的长度） 子序列的定义：序列的一些项按原有次序排列而得的新序列，例如序列{a1,a3,a5}\\{a1,a3,a5\\}{...","title":"子序列","tags":[{"name":"双指针","slug":"_ryZST3v0","used":true,"link":"https://shaoyihao.github.io/blog/_ryZST3v0/"}],"feature":"","link":"https://shaoyihao.github.io/blog/子序列/","stats":{"text":"3 min read","time":164000,"words":600,"minutes":3},"isTop":false,"toc":"","date":"2022-09-13 20:28:21","dateFormat":"2022-09-13"},{"fileName":"两（三）数之和","abstract":"","description":" 原题链接：两数之和 题目大意：给定一个含nnn个元素的序列，找出其中一组和为ttt的两个元素。（保证一定有解） 思路：首先将该数列进行递增排序，此时我们来研究一下该数列中蕴含的单调性：令i,ji,ji,j（i&lt;ji&lt;ji&l...","title":"两（三）数之和","tags":[{"name":"双指针","slug":"_ryZST3v0","used":true,"link":"https://shaoyihao.github.io/blog/_ryZST3v0/"}],"feature":"","link":"https://shaoyihao.github.io/blog/两（三）数之和/","stats":{"text":"6 min read","time":321000,"words":1117,"minutes":6},"isTop":false,"toc":"","date":"2022-09-13 20:27:07","dateFormat":"2022-09-13"},{"fileName":"炸弹","abstract":"","description":" 原题链接：激光炸弹 #include &lt;iostream&gt; using namespace std; const int N = 5010; int s[N][N]; int main() { int cnt, ...","title":"炸弹","tags":[{"name":"前缀和","slug":"Up4xFrNqi","used":true,"link":"https://shaoyihao.github.io/blog/Up4xFrNqi/"}],"feature":"","link":"https://shaoyihao.github.io/blog/炸弹/","stats":{"text":"2 min read","time":66000,"words":209,"minutes":2},"isTop":false,"toc":"","date":"2022-09-13 19:47:54","dateFormat":"2022-09-13"},{"fileName":"领地选择","abstract":"","description":" 原题链接：领地选择 题目大意：给定一个 N×MN\\times MN×M 的矩阵，求其中元素和最大的规模为C×CC\\times CC×C的子矩阵。 （最大子矩阵简化版） 思路：左上角坐标为(i1,j1)(i_1,j_1)(i1​,j1​)...","title":"领地选择","tags":[{"name":"前缀和","slug":"Up4xFrNqi","used":true,"link":"https://shaoyihao.github.io/blog/Up4xFrNqi/"}],"feature":"","link":"https://shaoyihao.github.io/blog/领地选择/","stats":{"text":"2 min read","time":98000,"words":320,"minutes":2},"isTop":false,"toc":"","date":"2022-09-13 19:39:20","dateFormat":"2022-09-13"},{"fileName":"k倍区间","abstract":"","description":" 原题链接：k倍区间 题目大意：若一个区间中的元素之和是kkk的倍数，则称该区间是一个kkk倍区间。统计一个数组中有多少个kkk倍区间。 方法一：暴力O(n3)O(n^3)O(n3)，时间复杂度太大。 方法二：暴力枚举区间+前缀和优化：O...","title":"k倍区间","tags":[{"name":"前缀和","slug":"Up4xFrNqi","used":true,"link":"https://shaoyihao.github.io/blog/Up4xFrNqi/"},{"name":"数论","slug":"9zRsOEYa3","used":true,"link":"https://shaoyihao.github.io/blog/9zRsOEYa3/"}],"feature":"","link":"https://shaoyihao.github.io/blog/k倍区间/","stats":{"text":"3 min read","time":160000,"words":569,"minutes":3},"isTop":false,"toc":"","date":"2022-09-13 19:29:18","dateFormat":"2022-09-13"},{"fileName":"传送","abstract":"","description":"原题链接：分段 从起点到第 i+1i+1i+1 个城市之间有 iii 段路。设 S[i]S[i]S[i] 为走到 i+1i + 1i+1 城市（即走了 iii 段路）所需的时间。“传送”可以从第iii个城市直接跳到第i+ki+ki+k个城市...","title":"传送阵","tags":[{"name":"前缀和","slug":"Up4xFrNqi","used":true,"link":"https://shaoyihao.github.io/blog/Up4xFrNqi/"}],"feature":"","link":"https://shaoyihao.github.io/blog/传送/","stats":{"text":"2 min read","time":70000,"words":232,"minutes":2},"isTop":false,"toc":"","date":"2022-09-13 19:08:42","dateFormat":"2022-09-13"},{"fileName":"一号线上的地点","abstract":"","description":" 原题链接：一号线上的地点 题目大意：nnn 个地点在一条线上，n−1n-1n−1段路，从地点iii到相邻地点i+1i+1i+1的路费有2种：车票费AiA_iAi​ 或 刷卡BiB_iBi​（Bi&lt;AiB_i&lt;A_iBi​&lt...","title":"一号线上的地点","tags":[{"name":"差分","slug":"Yl6i0Qt_8","used":true,"link":"https://shaoyihao.github.io/blog/Yl6i0Qt_8/"},{"name":"前缀和","slug":"Up4xFrNqi","used":true,"link":"https://shaoyihao.github.io/blog/Up4xFrNqi/"}],"feature":"","link":"https://shaoyihao.github.io/blog/一号线上的地点/","stats":{"text":"3 min read","time":144000,"words":493,"minutes":3},"isTop":false,"toc":"","date":"2022-09-13 17:18:48","dateFormat":"2022-09-13"},{"fileName":"地毯","abstract":"","description":" 原题链接：地毯 题目大意：在 n×nn\\times nn×n 的格子上有 mmm 个矩形地毯。问每个点被多少个地毯覆盖。 思路：使用二维差分统计这 mmm 个操作，最后求一下二维前缀和即可。 #include &lt;iostream&...","title":"地毯","tags":[{"name":"差分","slug":"Yl6i0Qt_8","used":true,"link":"https://shaoyihao.github.io/blog/Yl6i0Qt_8/"},{"name":"前缀和","slug":"Up4xFrNqi","used":true,"link":"https://shaoyihao.github.io/blog/Up4xFrNqi/"}],"feature":"","link":"https://shaoyihao.github.io/blog/地毯/","stats":{"text":"2 min read","time":84000,"words":297,"minutes":2},"isTop":false,"toc":"","date":"2022-09-13 16:52:19","dateFormat":"2022-09-13"},{"fileName":"差分","abstract":"","description":"一维差分 对于一个数列ana_nan​，总可以构造出数列bnb_nbn​，使得：ana_nan​是bnb_nbn​的前缀和。即：an=b1+b2+...+bna_n = b_1+b_2 +...+b_nan​=b1​+b2​+...+bn​...","title":"差分","tags":[{"name":"差分","slug":"Yl6i0Qt_8","used":true,"link":"https://shaoyihao.github.io/blog/Yl6i0Qt_8/"},{"name":"模板","slug":"O4BIFblmXJ","used":true,"link":"https://shaoyihao.github.io/blog/O4BIFblmXJ/"}],"feature":"","link":"https://shaoyihao.github.io/blog/差分/","stats":{"text":"7 min read","time":366000,"words":1172,"minutes":7},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E4%B8%80%E7%BB%B4%E5%B7%AE%E5%88%86\">一维差分</a></li>\n<li><a href=\"#%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86\">二维差分</a></li>\n<li><a href=\"#%E4%B8%89%E7%BB%B4%E5%B7%AE%E5%88%86\">三维差分</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2022-09-13 16:42:23","dateFormat":"2022-09-13"},{"fileName":"前缀和","abstract":"","description":"前缀和是一种优化手段，当需要频繁求部分连续元素之和时，应想到用前缀和进行优化。 一维前缀和 对于一个数列ana_nan​，要想求下标区间 [l,r][ l, r ][l,r] 内元素的和 al+al+1+...+ara_l + a_{l+1...","title":"前缀和","tags":[{"name":"前缀和","slug":"Up4xFrNqi","used":true,"link":"https://shaoyihao.github.io/blog/Up4xFrNqi/"},{"name":"模板","slug":"O4BIFblmXJ","used":true,"link":"https://shaoyihao.github.io/blog/O4BIFblmXJ/"}],"feature":"","link":"https://shaoyihao.github.io/blog/前缀和/","stats":{"text":"4 min read","time":198000,"words":634,"minutes":4},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E4%B8%80%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C\">一维前缀和</a></li>\n<li><a href=\"#%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C\">二维前缀和</a></li>\n<li><a href=\"#%E4%B8%89%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C\">三维前缀和</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2022-09-13 16:37:54","dateFormat":"2022-09-13"},{"fileName":"函数","abstract":"","description":"函数的概念 设数集D⊆RD\\subseteq RD⊆R，则称映射 f:D→Rf:D\\rightarrow Rf:D→R 为定义在 DDD 上的函数，记为： y=f(x), x∈Dy=f(x),\\ \\ \\ x\\in D y=f(x), ...","title":"函数","tags":[{"name":"微积分","slug":"i8TzGFf2j","used":true,"link":"https://shaoyihao.github.io/blog/i8TzGFf2j/"}],"feature":"","link":"https://shaoyihao.github.io/blog/函数/","stats":{"text":"15 min read","time":863000,"words":2975,"minutes":15},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E5%87%BD%E6%95%B0%E7%9A%84%E6%A6%82%E5%BF%B5\">函数的概念</a></li>\n<li><a href=\"#%E5%87%BD%E6%95%B0%E7%9A%84%E6%80%A7%E8%B4%A8\">函数的性质</a></li>\n<li><a href=\"#%E4%B8%80%E4%BA%9B%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B0\">一些特殊函数</a></li>\n<li><a href=\"#%E5%8F%8D%E5%87%BD%E6%95%B0\">反函数</a></li>\n<li><a href=\"#%E5%A4%8D%E5%90%88%E5%87%BD%E6%95%B0\">复合函数</a></li>\n<li><a href=\"#%E5%9F%BA%E6%9C%AC%E5%88%9D%E7%AD%89%E5%87%BD%E6%95%B0\">基本初等函数</a>\n<ul>\n<li><a href=\"#%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0\">三角函数</a></li>\n<li><a href=\"#%E5%8F%8D%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0\">反三角函数</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2022-09-13 15:55:58","dateFormat":"2022-09-13"},{"fileName":"2的n次幂的位数","abstract":"","description":"2n=(10log⁡102)n=10nlog⁡1022^n=(10^{\\log_{10}2})^n=10^{n\\log_{10}2} 2n=(10log10​2)n=10nlog10​2 由于 10k10^k10k 的位数为 ⌊k⌋+1\\l...","title":"2的n次幂的位数","tags":[{"name":"数论","slug":"9zRsOEYa3","used":true,"link":"https://shaoyihao.github.io/blog/9zRsOEYa3/"}],"feature":"","link":"https://shaoyihao.github.io/blog/2的n次幂的位数/","stats":{"text":"1 min read","time":34000,"words":108,"minutes":1},"isTop":false,"toc":"","date":"2022-09-12 20:19:28","dateFormat":"2022-09-12"},{"fileName":"快速幂","abstract":"","description":" 原题链接：快速幂 计算：abmod pa^b\\mod pabmodp 。 关于取模运算 在程序设计竞赛中，通常都需要对结果取模。为什么不让你直接输出结果呢？难道仅仅只是为了增大题目的难度吗？当然不是。 原因是：结果可能会非常的大，大到...","title":"快速幂","tags":[{"name":"数论","slug":"9zRsOEYa3","used":true,"link":"https://shaoyihao.github.io/blog/9zRsOEYa3/"}],"feature":"","link":"https://shaoyihao.github.io/blog/快速幂/","stats":{"text":"7 min read","time":406000,"words":1359,"minutes":7},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E5%85%B3%E4%BA%8E%E5%8F%96%E6%A8%A1%E8%BF%90%E7%AE%97\">关于取模运算</a></li>\n<li><a href=\"#%E5%BF%AB%E9%80%9F%E5%B9%82\">快速幂</a>\n<ul>\n<li><a href=\"#%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%86%99%E6%B3%95\">另一种写法</a></li>\n</ul>\n</li>\n<li><a href=\"#%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%BF%AB%E9%80%9F%E5%B9%82\">高精度快速幂</a></li>\n<li><a href=\"#%E5%BA%94%E7%94%A8%E5%BF%AB%E9%80%9F%E5%B9%82%E6%B1%82%E9%80%86%E5%85%83\">应用：快速幂求逆元</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2022-09-12 19:48:57","dateFormat":"2022-09-12"},{"fileName":"最大乘积","abstract":"","description":" 原题链接：最大乘积 题目大意：将正整数 nnn（n≥2n\\ge 2n≥2）分解成若干个互不相同的自然数的和，且使这些自然数的乘积最大。 背景知识：整数划分 设 SSS 为最佳拆分方案，其中最小元为aaa，最大元为bbb，则有以下几个事实...","title":"最大乘积","tags":[{"name":"数论","slug":"9zRsOEYa3","used":true,"link":"https://shaoyihao.github.io/blog/9zRsOEYa3/"}],"feature":"","link":"https://shaoyihao.github.io/blog/最大乘积/","stats":{"text":"9 min read","time":494000,"words":1557,"minutes":9},"isTop":false,"toc":"","date":"2022-09-12 15:32:58","dateFormat":"2022-09-12"},{"fileName":"整数划分","abstract":"","description":" 原题链接：整数划分 题目大意：将正整数 nnn 分解成若干个自然数的和，且使这些自然数的乘积最大。 把一个数拆成若干个自然数之后，如果要使这些自然数的乘积最大，那么这些自然数应该全是222或者333，且222最多不超过两个。 证明：对于...","title":"整数划分","tags":[{"name":"数论","slug":"9zRsOEYa3","used":true,"link":"https://shaoyihao.github.io/blog/9zRsOEYa3/"}],"feature":"","link":"https://shaoyihao.github.io/blog/整数划分/","stats":{"text":"5 min read","time":262000,"words":981,"minutes":5},"isTop":false,"toc":"","date":"2022-09-11 16:35:59","dateFormat":"2022-09-11"},{"fileName":"映射","abstract":"","description":"映射的相关概念 设 XXX、YYY 是2个非空集合，如果存在一个法则 fff，使得对 XXX 中的每个元素 xxx，根据fff，在 YYY 中都有 唯一 确定的元素 yyy 与之对应，那么称 fff 为从 XXX 到 YYY 的映射。记作：...","title":"映射","tags":[{"name":"微积分","slug":"i8TzGFf2j","used":true,"link":"https://shaoyihao.github.io/blog/i8TzGFf2j/"}],"feature":"","link":"https://shaoyihao.github.io/blog/映射/","stats":{"text":"4 min read","time":234000,"words":854,"minutes":4},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E6%98%A0%E5%B0%84%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5\">映射的相关概念</a></li>\n<li><a href=\"#%E9%80%86%E6%98%A0%E5%B0%84\">逆映射</a></li>\n<li><a href=\"#%E5%A4%8D%E5%90%88%E6%98%A0%E5%B0%84\">复合映射</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2022-09-10 23:13:17","dateFormat":"2022-09-10"},{"fileName":"字符串的展开","abstract":"","description":" 原题链接：字符串的展开 题目大意： 一个字符串展开的例子：如果在输入的字符串中，含有类似于 d-h 或者 4-8 的字串，我们就把它当作一种简写，输出时，用连续递增的字母或数字串替代其中的减号，即，将上面两个子串分别输出为 defgh 和...","title":"字符串的展开","tags":[{"name":"模拟","slug":"RY2D2zS77","used":true,"link":"https://shaoyihao.github.io/blog/RY2D2zS77/"}],"feature":"","link":"https://shaoyihao.github.io/blog/字符串的展开/","stats":{"text":"5 min read","time":251000,"words":927,"minutes":5},"isTop":false,"toc":"","date":"2022-09-10 16:24:28","dateFormat":"2022-09-10"},{"fileName":"输出多项式","abstract":"","description":" 原题链接：输出多项式 题目大意：给定 n+1n+1n+1 个整数，输出其对应的 nnn 次多项式。 #include &lt;iostream&gt; using namespace std; int main() { int...","title":"输出多项式","tags":[{"name":"数论","slug":"9zRsOEYa3","used":true,"link":"https://shaoyihao.github.io/blog/9zRsOEYa3/"},{"name":"模拟","slug":"RY2D2zS77","used":true,"link":"https://shaoyihao.github.io/blog/RY2D2zS77/"}],"feature":"","link":"https://shaoyihao.github.io/blog/输出多项式/","stats":{"text":"2 min read","time":106000,"words":347,"minutes":2},"isTop":false,"toc":"","date":"2022-09-10 15:21:39","dateFormat":"2022-09-10"},{"fileName":"追赶奶牛","abstract":"","description":" 原题链接：追赶奶牛 题目大意：给定 10×1010\\times 1010×10 的网格图，农夫追赶奶牛，每遇到障碍边顺时针转向90°，初始时都向北（上），判断农夫需要多久才能追上奶牛。 思路：先定义4个方向： int dx[] = {-...","title":"追赶奶牛","tags":[{"name":"网格图","slug":"DIJJl1eXw","used":true,"link":"https://shaoyihao.github.io/blog/DIJJl1eXw/"},{"name":"模拟","slug":"RY2D2zS77","used":true,"link":"https://shaoyihao.github.io/blog/RY2D2zS77/"}],"feature":"","link":"https://shaoyihao.github.io/blog/追赶奶牛/","stats":{"text":"4 min read","time":233000,"words":777,"minutes":4},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95\">另一种方法</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2022-09-10 14:35:43","dateFormat":"2022-09-10"},{"fileName":"猜拳","abstract":"","description":" 原题链接：生活大爆炸版石头剪刀布 题目大意：一种含有555种招式（记作：0,1,2,3,40,1,2,3,40,1,2,3,4）的猜拳，胜负关系为： 已知甲，乙按一定周期出拳，求经过 nnn 轮后，二人的比分。 思路：本题重点就是如何...","title":"猜拳","tags":[{"name":"模拟","slug":"RY2D2zS77","used":true,"link":"https://shaoyihao.github.io/blog/RY2D2zS77/"}],"feature":"","link":"https://shaoyihao.github.io/blog/猜拳/","stats":{"text":"3 min read","time":124000,"words":414,"minutes":3},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%80%9D%E8%B7%AF\">另一种思路</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2022-09-09 22:07:49","dateFormat":"2022-09-09"},{"fileName":"旋转矩阵","abstract":"","description":" 原题链接：旋转矩阵 题目大意：给定一个 n×nn\\times nn×n 的矩阵，对于 x,y,r,zx,y,r,zx,y,r,z，把以第 xxx 行第 yyy 列的元素为中心的 2r+12r+12r+1 阶矩阵按照某种时针方向旋转（z=0...","title":"旋转矩阵","tags":[{"name":"模拟","slug":"RY2D2zS77","used":true,"link":"https://shaoyihao.github.io/blog/RY2D2zS77/"}],"feature":"","link":"https://shaoyihao.github.io/blog/旋转矩阵/","stats":{"text":"6 min read","time":312000,"words":994,"minutes":6},"isTop":false,"toc":"","date":"2022-09-09 21:12:46","dateFormat":"2022-09-09"},{"fileName":"扫雷","abstract":"","description":" 原题链接：扫雷 给出 nnn 行 mmm 列格子中的地雷分布，计算每个非地雷格中的数字。 #include &lt;iostream&gt; using namespace std; int dx[8] = {-1, -1, 0, 1...","title":"扫雷","tags":[{"name":"模拟","slug":"RY2D2zS77","used":true,"link":"https://shaoyihao.github.io/blog/RY2D2zS77/"}],"feature":"","link":"https://shaoyihao.github.io/blog/扫雷/","stats":{"text":"2 min read","time":64000,"words":185,"minutes":2},"isTop":false,"toc":"","date":"2022-09-09 13:27:50","dateFormat":"2022-09-09"},{"fileName":"11分制or21分制","abstract":"","description":" 原题链接：11分制or21分制 题目大意：输入一个表示胜负关系的字符串，其中W代表小w赢，L代表小l赢。分别输出在11分制下和21分制下的每局比分。 需要注意的是，在 uuu 分制下，当某一方的比方达到 uuu 后，还需要领先对方 22...","title":"11分制 or 21分制","tags":[{"name":"模拟","slug":"RY2D2zS77","used":true,"link":"https://shaoyihao.github.io/blog/RY2D2zS77/"}],"feature":"","link":"https://shaoyihao.github.io/blog/11分制or21分制/","stats":{"text":"2 min read","time":65000,"words":220,"minutes":2},"isTop":false,"toc":"","date":"2022-09-08 21:09:02","dateFormat":"2022-09-08"},{"fileName":"分巧克力","abstract":"","description":" 原题链接：分巧克力 题目大意：给定 nnn 块巧克力的尺寸 hi×wih_i\\times w_ihi​×wi​，从中切出 kkk 块一样的正方形，要求边长是整数且面积尽可能大。求最大的边长。 若指定的边长很大，则切出的巧克力数就会很少...","title":"分巧克力","tags":[{"name":"二分","slug":"LksFlx0sM","used":true,"link":"https://shaoyihao.github.io/blog/LksFlx0sM/"}],"feature":"","link":"https://shaoyihao.github.io/blog/分巧克力/","stats":{"text":"2 min read","time":74000,"words":291,"minutes":2},"isTop":false,"toc":"","date":"2022-09-08 20:03:11","dateFormat":"2022-09-08"},{"fileName":"四平方和","abstract":"","description":" 原题链接：四平方和 题目大意：四平方和定理（又称为拉格朗日定理）：每个正整数都可以表示为至多 4 个正整数的平方和。如果把0包括进去，那么就是每个正整数都可以表示为4个非负整数的平方和。 n=a2+b2+c2+d2n=a^2+b^2+c^...","title":"四平方和","tags":[{"name":"哈希","slug":"d-_7WSJQ2","used":true,"link":"https://shaoyihao.github.io/blog/d-_7WSJQ2/"},{"name":"二分","slug":"LksFlx0sM","used":true,"link":"https://shaoyihao.github.io/blog/LksFlx0sM/"}],"feature":"","link":"https://shaoyihao.github.io/blog/四平方和/","stats":{"text":"5 min read","time":256000,"words":861,"minutes":5},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E4%BA%8C%E5%88%86\">二分</a></li>\n<li><a href=\"#%E5%93%88%E5%B8%8C%E8%A1%A8\">哈希表</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2022-09-08 19:56:49","dateFormat":"2022-09-08"},{"fileName":"机器人跳跃","abstract":"","description":" 原题链接：机器人跳跃 题目大意：n+1n+1n+1座塔的高度存储于hhh数组，其中h[0]=0h[0]=0h[0]=0（起点）。 机器人起始时位于第000座塔，初始能量为E0E_0E0​，接下来会一座一座地在塔间跳跃。机器人在第iii座塔...","title":"机器人跳跃","tags":[{"name":"二分","slug":"LksFlx0sM","used":true,"link":"https://shaoyihao.github.io/blog/LksFlx0sM/"}],"feature":"","link":"https://shaoyihao.github.io/blog/机器人跳跃/","stats":{"text":"4 min read","time":190000,"words":664,"minutes":4},"isTop":false,"toc":"","date":"2022-09-08 19:47:17","dateFormat":"2022-09-08"},{"fileName":"手机充电","abstract":"","description":" 原题链接：kotori的设备 题目大意：有nnn部手机，初始电量为bib_ibi​，耗电速率为ai/sa_i/sai​/s，只有一个充电器，充电速率为p/sp/sp/s，求这nnn部手机可以同时工作的最长时间。（即存在一部手机电量为0时即...","title":"手机充电","tags":[{"name":"二分","slug":"LksFlx0sM","used":true,"link":"https://shaoyihao.github.io/blog/LksFlx0sM/"}],"feature":"","link":"https://shaoyihao.github.io/blog/手机充电/","stats":{"text":"3 min read","time":155000,"words":599,"minutes":3},"isTop":false,"toc":"","date":"2022-09-08 19:32:01","dateFormat":"2022-09-08"},{"fileName":"数组分段","abstract":"","description":" 原题链接：数列分段 题目大意：将某段中的元素元素之和称为“段元素和”。将数组qqq分段后，可以得到一个最大的段元素和sis_isi​。求的就是在所分段数不超过mmm 的所有分段方式中最小的sss。 首先确定sss的范围：[qmax,∑i...","title":"数组分段","tags":[{"name":"二分","slug":"LksFlx0sM","used":true,"link":"https://shaoyihao.github.io/blog/LksFlx0sM/"}],"feature":"","link":"https://shaoyihao.github.io/blog/数组分段/","stats":{"text":"3 min read","time":159000,"words":622,"minutes":3},"isTop":false,"toc":"","date":"2022-09-08 19:23:16","dateFormat":"2022-09-08"},{"fileName":"路标设置","abstract":"","description":" 原题链接：路标设置 题目大意：在已知一些点的线段上，添加KKK个点，使相邻两点之间的距离整体上最小。 思路：本题与跳石头类型，都是在区间内直接二分出结果，难点在于check(mid)函数的判断。 查找对象：“空旷指数” 二分区间：[0...","title":"路标设置","tags":[{"name":"二分","slug":"LksFlx0sM","used":true,"link":"https://shaoyihao.github.io/blog/LksFlx0sM/"}],"feature":"","link":"https://shaoyihao.github.io/blog/路标设置/","stats":{"text":"3 min read","time":151000,"words":591,"minutes":3},"isTop":false,"toc":"","date":"2022-09-08 19:14:39","dateFormat":"2022-09-08"},{"fileName":"跳石头","abstract":"","description":" 原题链接：跳石头 题目大意：在含有NNN个点（不包括端点）的线段上，删去MMM个点，使相邻两点之间的距离整体上最大。 思路： 明确查找对象：最短间隔的最大值lll 注意：“最短”指的是在当前状态下所有石头中的最小间隔ttt。每种状...","title":"跳石头","tags":[{"name":"二分","slug":"LksFlx0sM","used":true,"link":"https://shaoyihao.github.io/blog/LksFlx0sM/"}],"feature":"","link":"https://shaoyihao.github.io/blog/跳石头/","stats":{"text":"3 min read","time":172000,"words":673,"minutes":3},"isTop":false,"toc":"","date":"2022-09-08 19:08:01","dateFormat":"2022-09-08"},{"fileName":"木材加工","abstract":"","description":" 原题链接：木材加工 题目大意：给定数组 q1,...,qnq_1,...,q_nq1​,...,qn​，求出最大的整数LLL，满足： ⌊q1L⌋+⌊q2L⌋+...+⌊qnL⌋=k\\lfloor\\frac{q_1}{L}\\rfloor+\\...","title":"木材加工","tags":[{"name":"二分","slug":"LksFlx0sM","used":true,"link":"https://shaoyihao.github.io/blog/LksFlx0sM/"}],"feature":"","link":"https://shaoyihao.github.io/blog/木材加工/","stats":{"text":"2 min read","time":66000,"words":212,"minutes":2},"isTop":false,"toc":"","date":"2022-09-08 15:43:40","dateFormat":"2022-09-08"},{"fileName":"最接近的数","abstract":"","description":" 原题链接：烦恼的高考志愿 题目大意：给定一个长度为 mmm 的数组，再给定 nnn 个数（询问），对于每一个数，在数组中找到与其最接近的数，求nnn个差值的和。 思路：先将数组排序，然后利用二分进行搜索。 二分查找数组中最后一个小于等于...","title":"最接近的数","tags":[{"name":"二分","slug":"LksFlx0sM","used":true,"link":"https://shaoyihao.github.io/blog/LksFlx0sM/"}],"feature":"","link":"https://shaoyihao.github.io/blog/最接近的数/","stats":{"text":"4 min read","time":183000,"words":650,"minutes":4},"isTop":false,"toc":"","date":"2022-09-08 15:14:02","dateFormat":"2022-09-08"},{"fileName":"一元三次方程的根","abstract":"","description":" 原题链接：一元三次方程求解 题目大意：给定一元三次方程 ax3+bx2+cx+d=0a x^3 + b x^2 + c x + d = 0ax3+bx2+cx+d=0 的系数a,b,c,da,b,c,da,b,c,d ，并约定该方程存在...","title":"一元三次方程的根","tags":[{"name":"二分","slug":"LksFlx0sM","used":true,"link":"https://shaoyihao.github.io/blog/LksFlx0sM/"}],"feature":"","link":"https://shaoyihao.github.io/blog/一元三次方程的根/","stats":{"text":"2 min read","time":112000,"words":390,"minutes":2},"isTop":false,"toc":"","date":"2022-09-08 14:49:31","dateFormat":"2022-09-08"},{"fileName":"砍树","abstract":"","description":" 原题链接：砍树 题目大意： 思路：二分查找HHH的边界，使： max⁡{x1−H, 0}+max⁡{x2−H, 0}+...+max⁡{xn−H, 0}≥M\\max\\{x_1-H, \\ 0\\}+\\max\\{x_2-H, \\ 0\\}+....","title":"砍树","tags":[{"name":"二分","slug":"LksFlx0sM","used":true,"link":"https://shaoyihao.github.io/blog/LksFlx0sM/"}],"feature":"","link":"https://shaoyihao.github.io/blog/砍树/","stats":{"text":"2 min read","time":69000,"words":219,"minutes":2},"isTop":false,"toc":"","date":"2022-09-08 14:10:40","dateFormat":"2022-09-08"},{"fileName":"A-B数对","abstract":"","description":" 原题链接：A-B数对 给出一串数以及一个数字 C，求数列中存在多少组A、B，使满足A - B = C。 思路： 与「寻找指定和的整数对」类似，思路转化为，对于数列中的每一个数 xxx，二分查找数列中是否存在 x+Cx+Cx+C。 与上题...","title":"A-B数对","tags":[{"name":"二分","slug":"LksFlx0sM","used":true,"link":"https://shaoyihao.github.io/blog/LksFlx0sM/"}],"feature":"","link":"https://shaoyihao.github.io/blog/A-B数对/","stats":{"text":"3 min read","time":126000,"words":473,"minutes":3},"isTop":false,"toc":"","date":"2022-09-07 17:21:53","dateFormat":"2022-09-07"},{"fileName":"寻找指定和的整数对","abstract":"","description":" 原题链接 题目大意：给定长度为n的数组，判断其中是否有一对数的和等于给定的数targettargettarget。 思路： 判断数列中是否存在 x,yx,yx,y 满足 x+y==targetx + y == targetx+y==ta...","title":"寻找指定和的整数对","tags":[{"name":"二分","slug":"LksFlx0sM","used":true,"link":"https://shaoyihao.github.io/blog/LksFlx0sM/"}],"feature":"","link":"https://shaoyihao.github.io/blog/寻找指定和的整数对/","stats":{"text":"2 min read","time":79000,"words":266,"minutes":2},"isTop":false,"toc":"","date":"2022-09-07 17:04:31","dateFormat":"2022-09-07"},{"fileName":"二分查找","abstract":"","description":"二分本质上就是在一个区间中查找一个数，方式为：不断缩小查找的区间，缩小区间时根据的是：该数所满足的命题。 注意二分的区间只要包含正确答案即可，即所二分的区间不是唯一的（大一点较稳妥），根据题目而定。 例如求一个数x的平方根时，就要保证二分...","title":"二分查找","tags":[{"name":"二分","slug":"LksFlx0sM","used":true,"link":"https://shaoyihao.github.io/blog/LksFlx0sM/"},{"name":"模板","slug":"O4BIFblmXJ","used":true,"link":"https://shaoyihao.github.io/blog/O4BIFblmXJ/"}],"feature":"","link":"https://shaoyihao.github.io/blog/二分查找/","stats":{"text":"5 min read","time":298000,"words":1099,"minutes":5},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li><a href=\"#1%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86\">1，整数二分</a><br>\n*\n<ul>\n<li><a href=\"#%E4%BE%8B%E9%A2%981-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%90%E6%95%B0%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%87%BA%E7%8E%B0%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E6%AC%A1%E5%87%BA%E7%8E%B0%E7%9A%84%E4%BD%8D%E7%BD%AE\">例题1 找出数组中某数第一次出现和最后一次出现的位置</a></li>\n</ul>\n</li>\n<li><a href=\"#2%E6%B5%AE%E7%82%B9%E6%95%B0%E4%BA%8C%E5%88%86\">2，浮点数二分</a><br>\n*\n<ul>\n<li><a href=\"#%E4%BE%8B%E9%A2%981-%E6%B1%82%E5%B9%B3%E6%96%B9%E6%A0%B9\">例题1 求平方根</a></li>\n<li><a href=\"#%E4%BE%8B%E9%A2%982%E6%B1%82%E7%AB%8B%E6%96%B9%E6%A0%B9\">例题2，求立方根</a></li>\n</ul>\n</li>\n<li><a href=\"#3lower_bound%E4%B8%8Eupper_bound\">3，lower_bound与upper_bound</a></li>\n</ul>\n","date":"2022-09-07 16:16:21","dateFormat":"2022-09-07"},{"fileName":"拼数","abstract":"","description":" 原题链接：拼数 题目大意：给定 nnn 个整数，将它们联接成一排，求所能得到的最大整数。（例如13,312,34313,312,34313,312,343所能连成的最大整数就是：343312133433121334331213） 思路：...","title":"拼数","tags":[{"name":"字符串","slug":"TUNYViuyK","used":true,"link":"https://shaoyihao.github.io/blog/TUNYViuyK/"},{"name":"排序","slug":"C8jTnsHs8","used":true,"link":"https://shaoyihao.github.io/blog/C8jTnsHs8/"}],"feature":"","link":"https://shaoyihao.github.io/blog/拼数/","stats":{"text":"3 min read","time":151000,"words":561,"minutes":3},"isTop":false,"toc":"","date":"2022-09-07 15:52:48","dateFormat":"2022-09-07"},{"fileName":"分数线划定","abstract":"","description":" 原题链接：分数线划定 题目大意：从 nnn 人中选拔 mmm 人，给定 nnn 人的笔试成绩，面试分数线为第 m×150%m\\times 150\\%m×150% 名（下取整）的人的分数，输出所有进入面试的人的id和笔试成绩。 注意：由于...","title":"分数线划定","tags":[{"name":"排序","slug":"C8jTnsHs8","used":true,"link":"https://shaoyihao.github.io/blog/C8jTnsHs8/"}],"feature":"","link":"https://shaoyihao.github.io/blog/分数线划定/","stats":{"text":"2 min read","time":89000,"words":303,"minutes":2},"isTop":false,"toc":"","date":"2022-09-07 10:57:38","dateFormat":"2022-09-07"},{"fileName":"高精度运算","abstract":"","description":"将大整数的每一位存入数组，数组的第0位存个位。因为如果发生进位的话，在数组的末尾添上一位较为容易。 此处A, B均为正数。 2个大整数之间的比较（字符串） bool cmp(string &amp;A, string &amp;B) // ...","title":"高精度运算","tags":[{"name":"模板","slug":"O4BIFblmXJ","used":true,"link":"https://shaoyihao.github.io/blog/O4BIFblmXJ/"}],"feature":"","link":"https://shaoyihao.github.io/blog/高精度运算/","stats":{"text":"12 min read","time":718000,"words":2303,"minutes":12},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#2%E4%B8%AA%E5%A4%A7%E6%95%B4%E6%95%B0%E4%B9%8B%E9%97%B4%E7%9A%84%E6%AF%94%E8%BE%83%E5%AD%97%E7%AC%A6%E4%B8%B2\">2个大整数之间的比较（字符串）</a></li>\n<li><a href=\"#%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%8A%A0%E6%B3%95\">高精度加法</a></li>\n<li><a href=\"#%E9%AB%98%E7%B2%BE%E5%BA%A6%E5%87%8F%E6%B3%95\">高精度减法</a></li>\n<li><a href=\"#%E9%AB%98%E7%B2%BE%E5%BA%A6%E4%B9%98%E6%B3%95\">高精度乘法</a>\n<ul>\n<li><a href=\"#%E5%A4%A7%E6%95%B0%E4%B8%80%E8%88%AC%E6%95%B0\">大数×一般数</a>\n<ul>\n<li><a href=\"#%E5%BA%94%E7%94%A8%E6%B1%82%E9%98%B6%E4%B9%98\">应用：求阶乘</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%A4%A7%E6%95%B0%E5%A4%A7%E6%95%B0\">大数×大数</a></li>\n</ul>\n</li>\n<li><a href=\"#%E9%AB%98%E7%B2%BE%E5%BA%A6%E9%99%A4%E6%B3%95\">高精度除法</a></li>\n<li><a href=\"#%E5%8E%8B%E4%BD%8D\">压位？？？</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2022-09-06 18:43:34","dateFormat":"2022-09-06"},{"fileName":"结构体的排序规则","abstract":"","description":"在实际生活中进行排序时往往需要考虑多个关键字，体现在程序中就是2个结构体元素之间的比较规则。 当确定比较规则之后，可以直接调用sort函数对整个结构体数组进行排序。 举个例子：对于以下结构体，排序规则为： aaa越大的结构体元素越大 aa...","title":"结构体的排序规则","tags":[{"name":"排序","slug":"C8jTnsHs8","used":true,"link":"https://shaoyihao.github.io/blog/C8jTnsHs8/"},{"name":"模板","slug":"O4BIFblmXJ","used":true,"link":"https://shaoyihao.github.io/blog/O4BIFblmXJ/"}],"feature":"","link":"https://shaoyihao.github.io/blog/结构体的排序规则/","stats":{"text":"4 min read","time":209000,"words":695,"minutes":4},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD\">运算符重载</a></li>\n<li><a href=\"#cmp%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0\">cmp比较函数</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2022-09-06 17:50:09","dateFormat":"2022-09-06"},{"fileName":"去重","abstract":"","description":"const int N = 110, M = 1001; //M为数组元素的范围 int q[N]; bool st[M]; //for (int i = 0; i &lt; n; i ++) cin &gt;&gt; q[i]; int...","title":"去重","tags":[{"name":"模板","slug":"O4BIFblmXJ","used":true,"link":"https://shaoyihao.github.io/blog/O4BIFblmXJ/"}],"feature":"","link":"https://shaoyihao.github.io/blog/去重/","stats":{"text":"2 min read","time":82000,"words":315,"minutes":2},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#stl%E5%86%99%E6%B3%95\">STL写法</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2022-09-06 16:45:31","dateFormat":"2022-09-06"},{"fileName":"计数排序","abstract":"","description":" 计数排序的基本思想是：对每个元素 xxx，确定数组中小于 xxx 的元素个数。利用这一信息，就可以直接把 xxx 放到它在输出数组中的位置上了。例如：如果有17个元素小于 xxx，则 xxx 就应该在第18个位置上。（当有几个元素相同时，...","title":"计数排序","tags":[{"name":"排序","slug":"C8jTnsHs8","used":true,"link":"https://shaoyihao.github.io/blog/C8jTnsHs8/"},{"name":"模板","slug":"O4BIFblmXJ","used":true,"link":"https://shaoyihao.github.io/blog/O4BIFblmXJ/"}],"feature":"","link":"https://shaoyihao.github.io/blog/计数排序/","stats":{"text":"5 min read","time":257000,"words":971,"minutes":5},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E5%8F%A6%E4%B8%80%E7%A7%8D%E5%86%99%E6%B3%95\">另一种写法</a></li>\n<li><a href=\"#%E6%95%88%E7%8E%87%E5%88%86%E6%9E%90\">效率分析</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2022-09-06 15:36:04","dateFormat":"2022-09-06"},{"fileName":"一些O(n²)的排序方法","abstract":"","description":"选择排序 void selection_sort(int q[], int n) { for (int i = 0; i &lt; n - 1 ; i ++) { int min = i; for (...","title":"一些O(n²)的排序方式","tags":[{"name":"排序","slug":"C8jTnsHs8","used":true,"link":"https://shaoyihao.github.io/blog/C8jTnsHs8/"},{"name":"模板","slug":"O4BIFblmXJ","used":true,"link":"https://shaoyihao.github.io/blog/O4BIFblmXJ/"}],"feature":"","link":"https://shaoyihao.github.io/blog/一些O(n²)的排序方法/","stats":{"text":"5 min read","time":275000,"words":1100,"minutes":5},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F\">选择排序</a></li>\n<li><a href=\"#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F\">插入排序</a></li>\n<li><a href=\"#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F\">冒泡排序</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2022-09-05 21:34:06","dateFormat":"2022-09-05"},{"fileName":"逆序对的数目","abstract":"","description":"对分治思想的深入理解： 分治思想就是将问题拆分为若干个子问题，分开解决各个子问题，再将各子问题的结果进行合并，从而得到总问题的结果。在解决子问题的过程中，通常需要进行递归的处理。 而进行递归的关键是： 当子问题简化到最简情况时，结果应是已...","title":"逆序对的数目","tags":[{"name":"排序","slug":"C8jTnsHs8","used":true,"link":"https://shaoyihao.github.io/blog/C8jTnsHs8/"},{"name":"数论","slug":"9zRsOEYa3","used":true,"link":"https://shaoyihao.github.io/blog/9zRsOEYa3/"},{"name":"分治","slug":"ZTyqKdNcq","used":true,"link":"https://shaoyihao.github.io/blog/ZTyqKdNcq/"}],"feature":"","link":"https://shaoyihao.github.io/blog/逆序对的数目/","stats":{"text":"4 min read","time":220000,"words":889,"minutes":4},"isTop":false,"toc":"","date":"2022-09-05 21:14:31","dateFormat":"2022-09-05"},{"fileName":"归并排序的非递归实现","abstract":"","description":"已知一个含有nnn个元素的数组qqq。 基本思路： 首先取每个子列的长度为111，则qqq可以划分为nnn个子列。 由于每个子列的长度为1，因此每个子列都是有序的。 遍历数组，将子列①,②①,②①,②进行合并，将子列③,④③,④③,④进...","title":"归并排序的非递归实现","tags":[{"name":"排序","slug":"C8jTnsHs8","used":true,"link":"https://shaoyihao.github.io/blog/C8jTnsHs8/"},{"name":"模拟","slug":"RY2D2zS77","used":true,"link":"https://shaoyihao.github.io/blog/RY2D2zS77/"},{"name":"分治","slug":"ZTyqKdNcq","used":true,"link":"https://shaoyihao.github.io/blog/ZTyqKdNcq/"}],"feature":"","link":"https://shaoyihao.github.io/blog/归并排序的非递归实现/","stats":{"text":"2 min read","time":113000,"words":427,"minutes":2},"isTop":false,"toc":"","date":"2022-09-05 20:54:58","dateFormat":"2022-09-05"},{"fileName":"归并排序","abstract":"","description":"归并排序的主要思想也是分治，基本问题为：两个有序数组的合并。 主要步骤： 以数组中心（下标的中心）为分界点：mid=l+r2mid = \\frac {l+r} {2}mid=2l+r​ 递归排序左边与右边 归并，将两个有序的数组合并为一个...","title":"归并排序","tags":[{"name":"排序","slug":"C8jTnsHs8","used":true,"link":"https://shaoyihao.github.io/blog/C8jTnsHs8/"},{"name":"模板","slug":"O4BIFblmXJ","used":true,"link":"https://shaoyihao.github.io/blog/O4BIFblmXJ/"},{"name":"分治","slug":"ZTyqKdNcq","used":true,"link":"https://shaoyihao.github.io/blog/ZTyqKdNcq/"}],"feature":"","link":"https://shaoyihao.github.io/blog/归并排序/","stats":{"text":"3 min read","time":143000,"words":553,"minutes":3},"isTop":false,"toc":"","date":"2022-09-05 20:51:00","dateFormat":"2022-09-05"},{"fileName":"快速选择","abstract":"","description":"求第k小的数 最坏情形时间复杂度为：O(n2)O(n^2)O(n2)，绝大部分情况下是O(n)O(n)O(n)的。 #include &lt;iostream&gt; using namespace std; const int N = ...","title":"快速选择","tags":[{"name":"排序","slug":"C8jTnsHs8","used":true,"link":"https://shaoyihao.github.io/blog/C8jTnsHs8/"},{"name":"模板","slug":"O4BIFblmXJ","used":true,"link":"https://shaoyihao.github.io/blog/O4BIFblmXJ/"},{"name":"分治","slug":"ZTyqKdNcq","used":true,"link":"https://shaoyihao.github.io/blog/ZTyqKdNcq/"}],"feature":"","link":"https://shaoyihao.github.io/blog/快速选择/","stats":{"text":"4 min read","time":234000,"words":858,"minutes":4},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li><a href=\"#%E6%B1%82%E7%AC%ACk%E5%B0%8F%E7%9A%84%E6%95%B0\">求第k小的数</a>\n<ul>\n<li><a href=\"#%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%80%9D%E8%B7%AF\">另一种思路</a></li>\n<li><a href=\"#nth_element%E5%87%BD%E6%95%B0\"><code>nth_element</code>函数</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2022-09-05 20:35:48","dateFormat":"2022-09-05"},{"fileName":"快排and归并","abstract":"","description":"快速排序 快速排序的平均时间复杂度为O(nlg⁡n)O(n\\lg n)O(nlgn)，且其中隐含的常数因子非常小；最坏条件下的时间复杂度为O(n2)O(n^2)O(n2)。 快速排序是基于 分治 的思想： 分解：数组A[l∼r]A[l\\s...","title":"快速排序与归并排序","tags":[{"name":"排序","slug":"C8jTnsHs8","used":true,"link":"https://shaoyihao.github.io/blog/C8jTnsHs8/"},{"index":-1,"name":"算法理论","slug":"algo-theory","used":true,"link":"https://shaoyihao.github.io/blog/algo-theory/"}],"feature":"","link":"https://shaoyihao.github.io/blog/快排and归并/","stats":{"text":"12 min read","time":684000,"words":2527,"minutes":12},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li><a href=\"#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F\">快速排序</a>\n<ul>\n<li><a href=\"#%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90\">性能分析</a></li>\n<li><a href=\"#%E9%9A%8F%E6%9C%BA%E5%8C%96\">随机化</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F\">归并排序</a></li>\n</ul>\n</li>\n</ul>\n","date":"2022-09-05 20:21:57","dateFormat":"2022-09-05"},{"fileName":"分形图","abstract":"","description":" 原题链接：南蛮图腾 题目大意：已知 n=1n=1n=1时： /\\ /__\\ n=2n=2n=2时： /\\ /__\\ /\\ /\\ /__\\/__\\ n=3n=3n=3时： /\\ /__\\ ...","title":"分形图","tags":[{"name":"模拟","slug":"RY2D2zS77","used":true,"link":"https://shaoyihao.github.io/blog/RY2D2zS77/"},{"name":"分治","slug":"ZTyqKdNcq","used":true,"link":"https://shaoyihao.github.io/blog/ZTyqKdNcq/"}],"feature":"","link":"https://shaoyihao.github.io/blog/分形图/","stats":{"text":"3 min read","time":132000,"words":427,"minutes":3},"isTop":false,"toc":"","date":"2022-09-04 21:15:01","dateFormat":"2022-09-04"},{"fileName":"快速排序","abstract":"","description":"快排的主要思想——分治 主要步骤： 确定分界点x：q[lll]、q[rrr]、q[l+r2\\frac {l+r} {2}2l+r​]、或随机一点 将数组分为两段，使小于等于xxx的项在左侧，大于等于xxx的项在右侧 递归处理左右两段 ...","title":"快速排序","tags":[{"name":"排序","slug":"C8jTnsHs8","used":true,"link":"https://shaoyihao.github.io/blog/C8jTnsHs8/"},{"name":"模板","slug":"O4BIFblmXJ","used":true,"link":"https://shaoyihao.github.io/blog/O4BIFblmXJ/"},{"name":"分治","slug":"ZTyqKdNcq","used":true,"link":"https://shaoyihao.github.io/blog/ZTyqKdNcq/"}],"feature":"","link":"https://shaoyihao.github.io/blog/快速排序/","stats":{"text":"5 min read","time":274000,"words":1033,"minutes":5},"isTop":false,"toc":"","date":"2022-09-04 20:41:46","dateFormat":"2022-09-04"},{"fileName":"地毯填补","abstract":"","description":" 原题链接：地毯填补 题目大意：给定一个 2k×2k2^k\\times 2^k2k×2k 的正方形网格，其中一个格子不能被填充（“黑格”）。给定 444 种地毯： 如何将整个正方形网格填满？ 思路：首先从简单的情形开始考虑，对于 2×2...","title":"地毯填补","tags":[{"name":"分治","slug":"ZTyqKdNcq","used":true,"link":"https://shaoyihao.github.io/blog/ZTyqKdNcq/"},{"name":"递归","slug":"403zHyzYL","used":true,"link":"https://shaoyihao.github.io/blog/403zHyzYL/"}],"feature":"","link":"https://shaoyihao.github.io/blog/地毯填补/","stats":{"text":"6 min read","time":312000,"words":1128,"minutes":6},"isTop":false,"toc":"","date":"2022-09-04 20:00:44","dateFormat":"2022-09-04"},{"fileName":"棋子移动","abstract":"","description":" 原题链接：棋子移动 在处理长度为 nnn 的串时，其中包含了对 长度为 n−1n-1n−1 的串的处理，从而可以递归求解。 n=4n=4n=4 时直接打表即可。 #include &lt;iostream&gt; #include &l...","title":"棋子移动","tags":[{"name":"递归","slug":"403zHyzYL","used":true,"link":"https://shaoyihao.github.io/blog/403zHyzYL/"}],"feature":"","link":"https://shaoyihao.github.io/blog/棋子移动/","stats":{"text":"2 min read","time":81000,"words":240,"minutes":2},"isTop":false,"toc":"","date":"2022-09-04 15:06:19","dateFormat":"2022-09-04"},{"fileName":"无限字符串","abstract":"","description":" 原题链接：无限字符串 题目大意：给定一个字符串strstrstr，定义一种操作为：将strstrstr的最后一个字符移到字符串的首位置，将这个新得到的字符串接到strstrstr的后面，则每次执行完该操作都会使字符串的长度扩大 111 倍...","title":"无限字符串","tags":[{"name":"分治","slug":"ZTyqKdNcq","used":true,"link":"https://shaoyihao.github.io/blog/ZTyqKdNcq/"},{"name":"递归","slug":"403zHyzYL","used":true,"link":"https://shaoyihao.github.io/blog/403zHyzYL/"}],"feature":"","link":"https://shaoyihao.github.io/blog/无限字符串/","stats":{"text":"5 min read","time":248000,"words":835,"minutes":5},"isTop":false,"toc":"","date":"2022-09-03 23:30:30","dateFormat":"2022-09-03"},{"fileName":"组合搜索","abstract":"","description":" 原题链接：选数 题目大意：从 nnn 个数中任选 kkk 个相加，求所得的和中有多少个质数。 思路：本题就是在考察如何在 nnn 个数中枚举 kkk 元组，显然方案数有：CnkC_n^kCnk​ 种。 搜索时关键是要做到不重不漏。关键就...","title":"组合搜索","tags":[{"name":"枚举","slug":"aWawovFa5","used":true,"link":"https://shaoyihao.github.io/blog/aWawovFa5/"},{"name":"递归","slug":"403zHyzYL","used":true,"link":"https://shaoyihao.github.io/blog/403zHyzYL/"}],"feature":"","link":"https://shaoyihao.github.io/blog/组合搜索/","stats":{"text":"2 min read","time":81000,"words":291,"minutes":2},"isTop":false,"toc":"","date":"2022-09-02 22:11:41","dateFormat":"2022-09-02"},{"fileName":"用递归进行枚举","abstract":"","description":" 递归枚举的关键是顺序。 考虑如何将枚举的顺序转化为一个树的遍历。 考虑代码中递归函数需要有哪些参数。 组合型枚举 枚举所有子集 输出{1,2,...,n}\\{1, 2, ..., n\\}{1,2,...,n}的所有子集。 按1∼n1...","title":"用递归进行枚举","tags":[{"name":"枚举","slug":"aWawovFa5","used":true,"link":"https://shaoyihao.github.io/blog/aWawovFa5/"},{"name":"模板","slug":"O4BIFblmXJ","used":true,"link":"https://shaoyihao.github.io/blog/O4BIFblmXJ/"},{"name":"递归","slug":"403zHyzYL","used":true,"link":"https://shaoyihao.github.io/blog/403zHyzYL/"}],"feature":"","link":"https://shaoyihao.github.io/blog/用递归进行枚举/","stats":{"text":"7 min read","time":384000,"words":1375,"minutes":7},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E7%BB%84%E5%90%88%E5%9E%8B%E6%9E%9A%E4%B8%BE\">组合型枚举</a>\n<ul>\n<li><a href=\"#%E6%9E%9A%E4%B8%BE%E6%89%80%E6%9C%89%E5%AD%90%E9%9B%86\">枚举所有子集</a>\n<ul>\n<li><a href=\"#%E4%BD%8D%E8%BF%90%E7%AE%97%E4%BC%98%E5%8C%96\">位运算优化</a></li>\n</ul>\n</li>\n<li><a href=\"#%E6%9E%9A%E4%B8%BE%E5%85%83%E7%B4%A0%E6%95%B0%E7%9B%AE%E5%9B%BA%E5%AE%9A%E7%9A%84%E5%AD%90%E9%9B%86\">枚举元素数目固定的子集</a></li>\n</ul>\n</li>\n<li><a href=\"#%E6%8E%92%E5%88%97%E5%9E%8B%E6%9E%9A%E4%B8%BE\">排列型枚举</a>\n<ul>\n<li><a href=\"#%E6%9E%9A%E4%B8%BE%E5%85%A8%E6%8E%92%E5%88%97\">枚举全排列</a></li>\n<li><a href=\"#%E6%9E%9A%E4%B8%BE%E6%89%80%E6%9C%89%E6%8E%92%E5%88%97\">枚举所有排列</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2022-09-02 22:09:07","dateFormat":"2022-09-02"},{"fileName":"解压字符串","abstract":"","description":" 原题链接：外星密码 题目大意：对于连续的若干个相同的子串 SSS 会压缩为 nSnSnS 的形式（nnn 是一个整数且 1≤n≤991\\leq n\\leq991≤n≤99），例如：字符串 CBCBCBCB 就压缩为 [4CB] 或者 [...","title":"解压字符串","tags":[{"name":"递归","slug":"403zHyzYL","used":true,"link":"https://shaoyihao.github.io/blog/403zHyzYL/"}],"feature":"","link":"https://shaoyihao.github.io/blog/解压字符串/","stats":{"text":"6 min read","time":326000,"words":1224,"minutes":6},"isTop":false,"toc":"","date":"2022-08-31 22:03:44","dateFormat":"2022-08-31"},{"fileName":"基于递推的递归","abstract":"","description":"递归的基本思想是某个函数直接或者间接地调用自身，这样原问题的求解就转换为了许多类型相同但是规模更小的子问题。求解时只需要关注如何把原问题划分成符合条件的子问题，而不需要过分关注这个子问题是如何被解决的。最终base case定义了最简子问题...","title":"基于递推的递归","tags":[{"name":"记忆化搜索","slug":"dLl9sp826","used":true,"link":"https://shaoyihao.github.io/blog/dLl9sp826/"},{"name":"递归","slug":"403zHyzYL","used":true,"link":"https://shaoyihao.github.io/blog/403zHyzYL/"}],"feature":"","link":"https://shaoyihao.github.io/blog/基于递推的递归/","stats":{"text":"3 min read","time":174000,"words":662,"minutes":3},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E5%9F%BA%E4%BA%8E%E9%80%92%E6%8E%A8%E5%85%B3%E7%B3%BB%E7%9A%84%E9%80%92%E5%BD%92\">基于递推关系的递归</a><br>\n*\n<ul>\n<li><a href=\"#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97\">斐波那契数列</a></li>\n<li><a href=\"#%E6%B1%82n\">求<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mo>!</mo></mrow><annotation encoding=\"application/x-tex\">n!</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mclose\">!</span></span></span></span></a></li>\n<li><a href=\"#%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0\">最大公因数</a></li>\n</ul>\n</li>\n<li><a href=\"#%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2\">记忆化搜索</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2022-08-30 21:32:03","dateFormat":"2022-08-30"},{"fileName":"2的幂次方表示","abstract":"","description":" 原题链接：2的幂次方表示 题目大意：给定一个正整数，输出该数的2的幂次方表示。例如： 137=27+23+20=2(7)+2(3)+2(0)=2(22+2+20)+2(2+20)+2(0)=2(2(2)+2+2(0))+2(2+2(0))...","title":"2的幂次方表示","tags":[{"name":"递归","slug":"403zHyzYL","used":true,"link":"https://shaoyihao.github.io/blog/403zHyzYL/"}],"feature":"","link":"https://shaoyihao.github.io/blog/2的幂次方表示/","stats":{"text":"3 min read","time":166000,"words":563,"minutes":3},"isTop":false,"toc":"","date":"2022-08-30 20:41:44","dateFormat":"2022-08-30"},{"fileName":"汉诺塔","abstract":"","description":"把一个问题划分为一个或多个规模更小的子问题，然后用相同的方法求解这些规模更小的子问题。值得注意的是，这些规模更小的子问题应与原问题保持同一类型。 def Hanoi(n, A, B, C): # 将A柱上的前n个碟子借助B移到C上 if ...","title":"Hanoi塔","tags":[{"name":"分治","slug":"ZTyqKdNcq","used":true,"link":"https://shaoyihao.github.io/blog/ZTyqKdNcq/"},{"name":"递归","slug":"403zHyzYL","used":true,"link":"https://shaoyihao.github.io/blog/403zHyzYL/"}],"feature":"","link":"https://shaoyihao.github.io/blog/汉诺塔/","stats":{"text":"2 min read","time":79000,"words":294,"minutes":2},"isTop":false,"toc":"","date":"2022-08-30 19:30:43","dateFormat":"2022-08-30"},{"fileName":"波兰表达式","abstract":"","description":" 原题链接：波兰表达式 题目大意：求一个波兰表达式的结果。 背景知识 波兰表达式(Polish notation)、**逆波兰表达式(Reverse Polish notation，RPN)**是波兰数学家Jan Łukasiewicz的...","title":"波兰表达式（中序）","tags":[{"name":"分治","slug":"ZTyqKdNcq","used":true,"link":"https://shaoyihao.github.io/blog/ZTyqKdNcq/"},{"name":"递归","slug":"403zHyzYL","used":true,"link":"https://shaoyihao.github.io/blog/403zHyzYL/"}],"feature":"","link":"https://shaoyihao.github.io/blog/波兰表达式/","stats":{"text":"3 min read","time":124000,"words":521,"minutes":3},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86\">背景知识</a></li>\n<li><a href=\"#%E6%80%9D%E8%B7%AF\">思路</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2022-08-30 17:28:07","dateFormat":"2022-08-30"},{"fileName":"递归与调用栈","abstract":"","description":"调用栈 调用栈（Call Stack）描述的是函数之间的调用关系，它由多个栈帧（Stack Frame）组成。每个栈帧对应着一个未运行完的函数，栈帧中保存了该函数的返回地址和局部变量，因而不仅能在函数执行完毕后找到正确的返回地址，还很自然地...","title":"递归与调用栈","tags":[{"name":"递归","slug":"403zHyzYL","used":true,"link":"https://shaoyihao.github.io/blog/403zHyzYL/"},{"index":-1,"name":"算法理论","slug":"algo-theory","used":true,"link":"https://shaoyihao.github.io/blog/algo-theory/"}],"feature":"","link":"https://shaoyihao.github.io/blog/递归与调用栈/","stats":{"text":"3 min read","time":153000,"words":707,"minutes":3},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E8%B0%83%E7%94%A8%E6%A0%88\">调用栈</a></li>\n<li><a href=\"#%E9%80%92%E5%BD%92%E4%B8%8E%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8%E6%A0%88\">递归与递归调用栈</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2022-08-30 14:48:15","dateFormat":"2022-08-30"},{"fileName":"P与NP","abstract":"<h3 id=\"判定问题与最优化问题\">判定问题与最优化问题</h3>\n<p>若一个问题的答案只有是或否两种，则称该问题为<strong>判定问题</strong>（decision problem）。</p>\n<blockquote>\n<p>问题的输入其实就是一种问题的具体实例。</p>\n</blockquote>\n<p>把判定问题抽象为一个从实例集映射到<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>{</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo>}</mo></mrow><annotation encoding=\"application/x-tex\">\\{0, 1\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">}</span></span></span></span>上的布尔函数，可以得到该函数的<strong>成真输入构成的集合</strong>：</p>\n<p class='katex-block'><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msub><mi>L</mi><mi>f</mi></msub><mo>=</mo><mo>{</mo><mi>x</mi><mtext> </mtext><mi mathvariant=\"normal\">∣</mi><mtext> </mtext><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mn>1</mn><mo>}</mo></mrow><annotation encoding=\"application/x-tex\">L_f=\\{x\\ |\\ f(x)=1\\}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.969438em;vertical-align:-0.286108em;\"></span><span class=\"mord\"><span class=\"mord mathdefault\">L</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.3361079999999999em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.10764em;\">f</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathdefault\">x</span><span class=\"mspace\"> </span><span class=\"mord\">∣</span><span class=\"mspace\"> </span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">}</span></span></span></span></span></p>\n<p>若一个问题有很多组解，其中每一个可行的解都有一个关联的值，我们希望找出一个具有最佳值的可行解，这种问题就称为<strong>最优化问题</strong>（optimization problem）。</p>\n<blockquote>\n<p>通常，最优化问题都可以转化为一个判定问题（借助一个值<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding=\"application/x-tex\">k</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.03148em;\">k</span></span></span></span>）。</p>\n</blockquote>\n<p>一般认为，<strong>判定问题要“更容易一些”</strong>（或至少“不会更难”）。如果某个最优化问题很容易，那么其相关的判定问题也会很容易。</p>\n<blockquote>\n<p>因为若可以容易的解决出最优化问题，那么就可以将求出的最优值与所要验证的值进行比较，从而得到判定问题的答案，因此此时解决判定问题也是容易的。</p>\n</blockquote>\n<p>如果我们能够说明<strong>某个判定问题是个困难问题</strong>，那么也就说明了<strong>其相关的最优化问题也是困难的</strong>。</p>\n<h3 id=\"问题的归约\">问题的归约</h3>\n<p>对于2个<strong>判定问题</strong><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi><mo separator=\"true\">,</mo><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A,B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span>，假设有一个过程，它可以将<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span>的任意输入<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span>转化成<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span>的某种输入<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span>，并且满足：</p>\n<ul>\n<li>转换操作需要多项式时间。</li>\n<li>两个输入<strong>得到的结果是相同的</strong>：<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span>输入<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span>时得到的结果是true，当且仅当<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span>输入<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span>时得到的结果是true。</li>\n</ul>\n<p>这称为将问题<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span><strong>多项式时间归约</strong>到问题<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span>，记为：<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi><msub><mo>≤</mo><mi>p</mi></msub><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A\\le_pB</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.969438em;vertical-align:-0.286108em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\"><span class=\"mrel\">≤</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span>，表示的含义是：<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span>大于<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span>的难度不会超过一个多项式时间因子。</p>\n<p>归约（reduction）提供了一种在多项式时间内解决问题<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span>的方法：</p>\n<ul>\n<li>对于问题<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span>的某种输入<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span>，先以多项式时间将<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span>转化为问题<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span>的某种输入<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span></li>\n<li>再求问题<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span>在<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>b</mi></mrow><annotation encoding=\"application/x-tex\">b</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">b</span></span></span></span>下的结果</li>\n<li>将该结果作为问题<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span>在<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>a</mi></mrow><annotation encoding=\"application/x-tex\">a</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">a</span></span></span></span>下的结果<br>\n<img src=\"https://img-blog.csdnimg.cn/04ceb54b3aca400c939f3a50b91a465a.png\" alt=\"在这里插入图片描述\" loading=\"lazy\"></li>\n</ul>\n<blockquote>\n<p>注意：<strong><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span>问题通常是要比<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span>更加核心本质的</strong>。</p>\n</blockquote>\n<p><strong>定理</strong>：若<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi><msub><mo>≤</mo><mi>p</mi></msub><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">A\\le_p B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.969438em;vertical-align:-0.286108em;\"></span><span class=\"mord mathdefault\">A</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\"><span class=\"mrel\">≤</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15139200000000003em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\">p</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.286108em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span>，则 <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding=\"application/x-tex\">B</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.05017em;\">B</span></span></span></span>是<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span></span></span></span>类问题<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>⇒</mo></mrow><annotation encoding=\"application/x-tex\">\\Rightarrow</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.36687em;vertical-align:0em;\"></span><span class=\"mrel\">⇒</span></span></span></span><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding=\"application/x-tex\">A</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">A</span></span></span></span>是<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding=\"application/x-tex\">P</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span></span></span></span>类问题。</p>\n<h3 id=\"编码与形式语言体系\">编码与形式语言体系</h3>\n<p>给定一种抽象判定问题<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>Q</mi><mi mathvariant=\"normal\">：</mi><mi>I</mi><mo>→</mo><mo>{</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo>}</mo></mrow><annotation encoding=\"application/x-tex\">Q：I\\rightarrow\\{0,1\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathdefault\">Q</span><span class=\"mord cjk_fallback\">：</span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">I</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">}</span></span></span></span>，若将实例集<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>I</mi></mrow><annotation encoding=\"application/x-tex\">I</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.07847em;\">I</span></span></span></span>中的每种输入 编码为 01序列，得到<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>{</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><msub><mo>}</mo><mi>I</mi></msub><mo>→</mo><mo>{</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo>}</mo></mrow><annotation encoding=\"application/x-tex\">\\{0,1\\}_I\\rightarrow \\{0,1\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mclose\"><span class=\"mclose\">}</span><span class=\"msupsub\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.32833099999999993em;\"><span style=\"top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.07847em;\">I</span></span></span></span><span class=\"vlist-s\">​</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.15em;\"><span></span></span></span></span></span></span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">→</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">}</span></span></span></span>，称此时的问题为<strong>具体问题</strong>(concrete problem)，记为<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>e</mi><mo>(</mo><mi>Q</mi><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">e(Q)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\">e</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">Q</span><span class=\"mclose\">)</span></span></span></span>。</p>\n<p>若具体问题输入的是一个长度为<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.43056em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span></span></span></span>的01序列，存在一个算法可以在<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>n</mi><mi>k</mi></msup><mo>)</mo></mrow><annotation encoding=\"application/x-tex\">O(n^k)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.099108em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\">n</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.849108em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.03148em;\">k</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span>时间内求解该问题，则称该具体问题是<strong>多项式时间可解</strong>的(polynomial-time solvable)。</p>\n<p><strong>求解问题的效率与实例的编码方式有关</strong>，如果不先指定编码，就不可能真正谈及对一个抽象问题的求解。<br>\n对于几种<strong>多项式相关的</strong>编码方式，<strong>问题本身是否多项式时间可解与选用这其中哪一种编码无关</strong>。</p>\n<blockquote>\n<p>对一个抽象问题的实例，采用二进制或三进制来进行编码，对其“复杂性”都没有影响。但是如果对实例进行一元编码，则其复杂性可能会变化。<br>\n为了能够用一种与编码无关的方式进行描述，一般都假定用合理的、简洁的方式对问题实例进行编码。<br>\n通常默认的编码方式满足：一个整数的编码与其二进制表示是多项式相关的，并且一个有限集合的编码 与 相应的元素间用逗号隔开的列表的编码是多项式相关的 (ASCII 码就是这样的一种编码方案)。</p>\n</blockquote>\n<p>字母表<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>∑</mo></mrow><annotation encoding=\"application/x-tex\">\\sum</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.00001em;vertical-align:-0.25001em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span></span></span></span>是符号的<strong>有限</strong>集合，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mo>∑</mo><mo>∗</mo></msup></mrow><annotation encoding=\"application/x-tex\">\\sum^*</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.078606em;vertical-align:-0.25001em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.828596em;\"><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span>是由表中符号组成的所有串构成的全集，<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><msup><mo>∑</mo><mo>∗</mo></msup></mrow><annotation encoding=\"application/x-tex\">\\sum^*</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.078606em;vertical-align:-0.25001em;\"></span><span class=\"mop\"><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.828596em;\"><span style=\"top:-3.2029em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mbin mtight\">∗</span></span></span></span></span></span></span></span></span></span></span>的任一子集都是一种<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>∑</mo></mrow><annotation encoding=\"application/x-tex\">\\sum</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.00001em;vertical-align:-0.25001em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span></span></span></span>上的语言<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">L</span></span></span></span>。</p>\n<p>因为每一个判定问题都是对应一个映射，完全可以用<strong>成真输入构成的集合</strong>来描述，因此<strong>每个判定问题都是一个<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mo>∑</mo><mo>=</mo><mo>{</mo><mn>0</mn><mo separator=\"true\">,</mo><mn>1</mn><mo>}</mo></mrow><annotation encoding=\"application/x-tex\">\\sum=\\{0,1\\}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.00001em;vertical-align:-0.25001em;\"></span><span class=\"mop op-symbol small-op\" style=\"position:relative;top:-0.0000050000000000050004em;\">∑</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord\">0</span><span class=\"mpunct\">,</span><span class=\"mspace\" style=\"margin-right:0.16666666666666666em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">}</span></span></span></span>上的语言<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>L</mi></mrow><annotation encoding=\"application/x-tex\">L</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">L</span></span></span></span></strong>：</p>\n<p class='katex-block'><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>L</mi><mo>=</mo><mo>{</mo><mi>x</mi><mtext> </mtext><mi mathvariant=\"normal\">∣</mi><mtext> </mtext><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo><mo>=</mo><mn>1</mn><mo>}</mo></mrow><annotation encoding=\"application/x-tex\">L=\\{x\\ |\\ f(x)=1\\}\n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">L</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">{</span><span class=\"mord mathdefault\">x</span><span class=\"mspace\"> </span><span class=\"mord\">∣</span><span class=\"mspace\"> </span><span class=\"mord mathdefault\" style=\"margin-right:0.10764em;\">f</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\">x</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord\">1</span><span class=\"mclose\">}</span></span></span></span></span></p>\n","description":"判定问题与最优化问题 若一个问题的答案只有是或否两种，则称该问题为判定问题（decision problem）。 问题的输入其实就是一种问题的具体实例。 把判定问题抽象为一个从实例集映射到{0,1}\\{0, 1\\}{0,1}上的布尔函数...","title":"NP完全理论","tags":[{"index":-1,"name":"算法理论","slug":"algo-theory","used":true,"link":"https://shaoyihao.github.io/blog/algo-theory/"}],"feature":"","link":"https://shaoyihao.github.io/blog/P与NP/","stats":{"text":"19 min read","time":1106000,"words":4907,"minutes":19},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E5%88%A4%E5%AE%9A%E9%97%AE%E9%A2%98%E4%B8%8E%E6%9C%80%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98\">判定问题与最优化问题</a></li>\n<li><a href=\"#%E9%97%AE%E9%A2%98%E7%9A%84%E5%BD%92%E7%BA%A6\">问题的归约</a></li>\n<li><a href=\"#%E7%BC%96%E7%A0%81%E4%B8%8E%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%BD%93%E7%B3%BB\">编码与形式语言体系</a></li>\n<li><a href=\"#p-np\">P、NP</a></li>\n<li><a href=\"#np-hard%E4%B8%8Enp-complete\">NP-hard与NP-complete</a>\n<ul>\n<li><a href=\"#np-complete%E9%97%AE%E9%A2%98%E7%9A%84%E8%AF%81%E6%98%8E\">NP-complete问题的证明</a>\n<ul>\n<li><a href=\"#%E7%94%B5%E8%B7%AF%E5%8F%AF%E6%BB%A1%E8%B6%B3%E9%97%AE%E9%A2%98circuitsat\">电路可满足问题（CircuitSAT）</a></li>\n<li><a href=\"#%E5%85%AC%E5%BC%8F%E5%8F%AF%E6%BB%A1%E8%B6%B3%E6%80%A7%E9%97%AE%E9%A2%98sat\">公式可满足性问题（SAT）</a></li>\n<li><a href=\"#3-cnf%E5%8F%AF%E6%BB%A1%E8%B6%B3%E6%80%A7%E9%97%AE%E9%A2%983-cnf-sat\">3-CNF可满足性问题（3-CNF-SAT）</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%85%B6%E5%AE%83np-complete%E9%97%AE%E9%A2%98\">其它NP-complete问题</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2022-08-20 22:03:32","dateFormat":"2022-08-20"},{"fileName":"算法理论","abstract":"","description":"基本概念 一般可以将问题形式化描述为： f(x) , x∈Sf(x)\\ ,\\ \\ \\ \\ \\ \\ x\\in S f(x) , x∈S 其中f(x)f(x)f(x)是一个目标函数，它表示解决问题的目的。如果目标是使问题达到...","title":"算法的基础理论","tags":[{"index":-1,"name":"算法理论","slug":"algo-theory","used":true,"link":"https://shaoyihao.github.io/blog/algo-theory/"}],"feature":"","link":"https://shaoyihao.github.io/blog/算法理论/","stats":{"text":"9 min read","time":485000,"words":1879,"minutes":9},"isTop":false,"toc":"<ul class=\"markdownIt-TOC\">\n<li>\n<ul>\n<li>\n<ul>\n<li><a href=\"#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\">基本概念</a></li>\n<li><a href=\"#%E5%88%A9%E7%94%A8%E5%BE%AA%E7%8E%AF%E4%B8%8D%E5%8F%98%E9%87%8F%E6%9D%A5%E8%AF%81%E6%98%8E%E7%AE%97%E6%B3%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%80%A7\">利用循环不变量来证明算法的正确性</a></li>\n<li><a href=\"#%E7%AE%97%E6%B3%95%E7%9A%84%E6%95%88%E7%8E%87%E8%AF%84%E4%BB%B7\">算法的效率评价</a></li>\n<li><a href=\"#%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%8B%E7%95%8C\">问题的下界</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","date":"2022-08-20 16:51:29","dateFormat":"2022-08-20"}],"tags":[{"name":"html","slug":"wIxVuXypZ","used":true,"link":"https://shaoyihao.github.io/blog/wIxVuXypZ/","count":4},{"name":"Unix/Linux","slug":"2c0Sh6Yfq","used":true,"link":"https://shaoyihao.github.io/blog/2c0Sh6Yfq/","count":2},{"name":"微积分","slug":"i8TzGFf2j","used":true,"link":"https://shaoyihao.github.io/blog/i8TzGFf2j/","count":3},{"name":"其它","slug":"CZufz5lnM","used":true,"link":"https://shaoyihao.github.io/blog/CZufz5lnM/","count":1},{"name":"计算机组成原理","slug":"xWT85UO9c","used":true,"link":"https://shaoyihao.github.io/blog/xWT85UO9c/","count":1},{"name":"双指针","slug":"_ryZST3v0","used":true,"link":"https://shaoyihao.github.io/blog/_ryZST3v0/","count":7},{"name":"排序","slug":"C8jTnsHs8","used":true,"link":"https://shaoyihao.github.io/blog/C8jTnsHs8/","count":12},{"name":"模板","slug":"O4BIFblmXJ","used":true,"link":"https://shaoyihao.github.io/blog/O4BIFblmXJ/","count":13},{"name":"前缀和","slug":"Up4xFrNqi","used":true,"link":"https://shaoyihao.github.io/blog/Up4xFrNqi/","count":7},{"name":"数论","slug":"9zRsOEYa3","used":true,"link":"https://shaoyihao.github.io/blog/9zRsOEYa3/","count":7},{"name":"差分","slug":"Yl6i0Qt_8","used":true,"link":"https://shaoyihao.github.io/blog/Yl6i0Qt_8/","count":3},{"name":"模拟","slug":"RY2D2zS77","used":true,"link":"https://shaoyihao.github.io/blog/RY2D2zS77/","count":9},{"name":"网格图","slug":"DIJJl1eXw","used":true,"link":"https://shaoyihao.github.io/blog/DIJJl1eXw/","count":1},{"name":"二分","slug":"LksFlx0sM","used":true,"link":"https://shaoyihao.github.io/blog/LksFlx0sM/","count":14},{"name":"哈希","slug":"d-_7WSJQ2","used":true,"link":"https://shaoyihao.github.io/blog/d-_7WSJQ2/","count":1},{"name":"字符串","slug":"TUNYViuyK","used":true,"link":"https://shaoyihao.github.io/blog/TUNYViuyK/","count":1},{"name":"分治","slug":"ZTyqKdNcq","used":true,"link":"https://shaoyihao.github.io/blog/ZTyqKdNcq/","count":10},{"index":-1,"name":"算法理论","slug":"algo-theory","used":true,"link":"https://shaoyihao.github.io/blog/algo-theory/","count":4},{"name":"递归","slug":"403zHyzYL","used":true,"link":"https://shaoyihao.github.io/blog/403zHyzYL/","count":11},{"name":"枚举","slug":"aWawovFa5","used":true,"link":"https://shaoyihao.github.io/blog/aWawovFa5/","count":2},{"name":"记忆化搜索","slug":"dLl9sp826","used":true,"link":"https://shaoyihao.github.io/blog/dLl9sp826/","count":1}],"menus":[{"link":" ","name":"首页","openType":"Internal"},{"link":"/archives","name":"时间轴","openType":"Internal"},{"link":"/tags","name":"标签","openType":"Internal"},{"link":"aboutme","name":"关于","openType":"External"}],"themeConfig":{"themeName":"pure","postPageSize":30,"archivesPageSize":50,"siteName":"SYH's Blog","siteDescription":"","footerInfo":"©All rights reserved","showFeatureImage":true,"domain":"https://shaoyihao.github.io/blog/","postUrlFormat":"SHORT_ID","tagUrlFormat":"SHORT_ID","dateFormat":"YYYY-MM-DD","feedFullText":false,"feedCount":10,"archivesPath":"archives","postPath":"","tagPath":""},"customConfig":{"APP_ID":"","APP_KEY":"","about":"<p>Hi，我是shao，目前是厦门大学计算机专业大二在读，欢迎来到我的博客！</p>\n","avatar":"","caf":"","ccf":"#000000","ccs":"#495057","ctf":"#ffffff","cts":"#FFFFFF","customCss":"","descfriend":"","dribbble":"","facebook":"","friends":[],"ga":"","github":"","isEnabledCustomColor":false,"pageSize":"5","placeholder":"Just Go Go","recordIp":true,"skin":"white","twitter":"","vMaxWidth":"1000","vPadding":"2.5%","vPercentWidth":"100","valine":false,"visitor":true,"weibo":"","zhihu":""},"utils":{"now":1664201656961}}
