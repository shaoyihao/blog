{"posts":[{"title":"图像、视频的格式","content":"图像格式 世界上图像格式有很多，但Web上常用的只是其中的3种：jpeg、png、gif。 一般而言，相同质量下，jpeg照片一般比png、gif要小。对于logo图片，使用png或者gif一般而言效果更好，文件也可能更小。 PNG是最新的图片格式，既支持照片也支持logo，且提供了比gif更高级的透明性。目前所有主流浏览器都支持png。 png的压缩要稍稍优于gif，所以对于一个颜色数相同的图像，png文件可能会更小一些。 一般专业的图像处理软件在处理图片时都会有一个&quot; Mette（蒙版） &quot;选项，该选项允许你为文本周围的蒙版选择颜色，一般选择的蒙版颜色就是Web页面的背景色。 视频格式 一个视频文件包含两部分：视频部分和音频部分。每个部分都使用一种特定的编码类型来编码（如此可以缩小数据大小，并能更高效地播放)。不同浏览器制造商使用的编码可能不同。有些浏览器制造商推崇H.264编码，另外一些却喜欢VP8，还有一些倾向于开源的Theora。另外，包含视频、音频编码的容器也有自己的格式，这让情况更加复杂。 容器（container）：用来包装视频、音频和元数据信息的文件格式，常用的容器格式包括：MP4、WebM、Ogg、Flash Video等。 编解码器（codec）：用来对视频或音频进行特定编码和解码的软件。流行的Web编解码器有：H.264、VP8、Theora、AAC、Vorbis等。 尽管浏览器制造商对于HTML5中的&lt;video&gt;元素和API已经达成一致，但是并不是所有人都认可视频文件本身的具体格式。例如，Safari浏览器更接受H.264格式；Chrome浏览器更接受WebM格式；Firefox更接受ogv格式。因此如果想使视频在众多浏览器上都可以播放，就需要多种编码。 ","link":"https://shaoyihao.github.io/blog/图像、视频的格式/"},{"title":"一些标签(2)","content":"html5新增标签 article、nav、header、footer、time、aside、section、video、audio、progress、mark、meter、canvas、figure、main... 这些标签用&lt;div&gt;确实也能做到，不过这些新元秦有一个好处，例如如果使用&lt;article&gt;元素，那么浏览器、搜索引擎、屏幕阅读器，还有Web开发人员，他们就能很肯定地知道这是一个文章。记住，我们要物尽其用，要用最适合的元素来完成任务。使用这些新元素，就能最为明确地表示结构，而且我们的工具也能正确发挥作用。 以&lt;aside&gt;元素为例，这个元素用来标记页面上的补充内容。现在假设有一个屏幕大小有限的移动手机，如果浏览器知道这个内容是一个&lt;aside&gt;。你可能会看到，这个内容会“塞” 到页面最下面，这样你就能首先看到更重要的内容。 相反，如果这个内容放在&lt;div&gt;中，那就什么情况都有可能发生，要看这个内容在HTML文件中的具体位置。 现在浏览器就能知道页面上的主内容与&lt;aside&gt;之间的不同，所以它会对&lt;aside&gt;中的内容区别对待。例如搜索引擎可能会优先考虑页面上的主要内容，而不是&lt;aside&gt;中的内容。 time audio &lt;audio controls src=&quot;/music/路...一直都在.mp3&quot;&gt;BGM播放失败&lt;/audio&gt; 加上controls会显示控制栏。播放失败时会显示预置的文字。 另一种方式是用若干个sourse： &lt;audio controls&gt; &lt;source src=&quot;/audios/sound1&quot; type=&quot;audio/mpeg&quot;/&gt; &lt;!--此时必须要加上这个type属性--&gt; &lt;source src=&quot;/audios/sound2&quot; type=&quot;audio/mpeg&quot;/&gt; &lt;/audio&gt; 如果能够播放的话，浏览器就会试图去加载第一个source元素；如果不行，那就退而求其次去加载第二个。 video html5允许采用任何视频格式，具体支持哪些格式由浏览器决定。如果想支持所有视频，就需要多种编码。 ","link":"https://shaoyihao.github.io/blog/一些html5标签/"},{"title":"一些标签(1)","content":"元素的属性 元素一般会具有属性，属性用于提供元素的一些附加信息。属性之间的顺序任意。 属性总是以名称/值对的形式出现，比如：name=&quot;value&quot;。注意：属性值应该始终被包括在引号内。 HTML全称是“hypertext markup language”，其中&quot;markup language&quot;反映的是它是一种标记语言，用于描述网页的结构，而“hypertext”则是让我们可以摆脱单个页面的束缚，链接到其它页面。 例如超链接： &lt;a href=&quot;XXX&quot;&gt; &lt;/a&gt; 其中的属性href用于告诉浏览器该元素指向哪里。“href”的含义是“hypertext reference，超文本引用”，是互联网或本地计算机上的一个资源的别称。一般情况下，资源就是一个Web页面，不过href也可以指向PDF文档等各种各样的资源。 一些标签 style &lt;style type=&quot;text/css&quot;&gt; ... /* style标签有一个可选属性：type，它用于告诉浏览器你在使用什么类型的样式，此处使用css。 */ &lt;/style&gt; 之所以会有这个设计是因为从前的HTML的设计者认为以后应该还会有其他样式，然而如今事实上，完全可以只使用&lt;style&gt;属性而不带type属性，所有浏览器都知道你指的是CSS。 q：简单的引用 &lt;P&gt; You never know when you'll need a good quote, how about &lt;q&gt;To be or not to be&lt;/q&gt;. &lt;/p&gt; 一些浏览器的默认样式是给q标签内的文本加引号。 “使用&lt;q&gt;&lt;/q&gt;效果上只是加了一个双引号，不如直接使用双引号算了”，是这样吗？ 使用&lt;q&gt;&lt;/q&gt;可以使页面更结构化，更有意义。人们在文本中使用双引号，原因可能有很多。但是如果是使用&lt;q&gt;这就意味着这是特定的引用内容。 若只是使用双引号，则浏览器只知道这是一个文本段落；而我们使用了&lt;q&gt;后，为该文本增加了含义，浏览器知道了这些文字是引用。 知道了又有什么用处呢？ 既然浏览器知道了这是一个引用，它就能用最合适的方式来显示文本：譬如两边显示双引号，另外如果浏览器使用非英语语言或在一些移动设备上，可能还会使用其他方法。 搜索引擎可能需要搜寻包含引用的网页。 通过CSS，我们可以对引用设置样式，自定义它的外观。 总之，页面中增加结构和含义绝对是有意义的。 blockquote 与&lt;q&gt;元素的区别：&lt;q&gt;用于短引用，作为现有段落的一部分，而&lt;blockquote&gt;元素常用于较长的引用，需要单独显示。 本质上，二者事实上是两类不同的元素：blockquote是block元素，&lt;q&gt;是inline元素。 &lt;br&gt;、&lt;img&gt;等 这些元素是一个没有任何内容的元素，称为void元素。更确切地说，void元素是指开始标签与结束标签之间没有任何内容的元素。 浏览器对&lt;img&gt;元素的处理与其他元素稍有不同。以&lt;h1&gt;或&lt;p&gt;元 素为例，浏览器在页面上看到这些标记时，只需要把它们显示出来就可以了；而浏览器看到一个&lt;img&gt;元素时，在页面中显示图像之前，必须先获取这个图像。 浏览器读取一个含img的html文件，会先显示出所有非图像部分，再从服务器获取第一个图像，显示出来；再获取第2个图像...... 现代浏览器通常会同时获取图像，即同时请求多个图像。以目前计算机和网络的速度，加载的时间非常快以至于用户通常会看到页面和图像一同显示出来。&lt;img&gt;元素只是指向图像，图像并不是html页面本身的一部分。实际上，浏览器显示页面时，图像会取代img元素。 可以为一个图像增加width属性和height属性，如果没有指定宽高，则浏览器在页面中显示图像之前会自动确定该图像的大小。如果事先指定了width属性和height属性，则浏览器在显示页面图像之前就可以开始建立页面布局。如果没有指定，则浏览器在知道图像的大小之后，通常需要重新调整页面布局。要记住，浏览器是在下载了html文件并显示页面之后才加载图像。浏览器加载完图像之前，除非你告诉它，否则它无法知道图像的大小。 如果图像在浏览器中刚好能放下，说明该浏览器可能打开了&quot;auto image resize&quot;选项。 列表 &lt;ul&gt; &lt;!-- 无序ul，有序ol --&gt; &lt;li&gt;aaa&lt;/li&gt; &lt;!-- list item --&gt; &lt;li&gt;bbb&lt;/li&gt; &lt;li&gt;ccc&lt;/li&gt; &lt;/ul&gt; 超链接 可以为&lt;a&gt;提供title属性，用来提供链接信息。鼠标停留在链接上就会显示。 Read the &lt;a href=&quot;http://wickedlysmart.com/buzz&quot; title=&quot;Read all about us&quot;&gt;Buzz&lt;/a&gt; title属性在众多元素上都可以使用。 &lt;a&gt;还可以链接到页面的某个特定元素：只要该元素带有id属性。 &lt;a href=&quot;index.html#part2&quot;&gt;See Part2&lt;/a&gt; &lt;!-- 其它网页的某部分 --&gt; &lt;!-- &lt;a href=&quot;#part2&quot;&gt;See Part2&lt;/a&gt; 本文档内的某部分--&gt; ... &lt;h id=&quot;part2&quot;&gt;Part2&lt;/h&gt; 不论是相对链接还是URL，要链接到页面中的一个特定目标，只需在链接最后加一个#，再加上相应元素id。 要在一个新窗口中打开一个页面，需要告诉浏览器你要打开的窗口名。如果没有告诉浏览器要使用哪个特定的窗口，浏览器就会在同一个窗口中打开这个页面。可以为&lt;a&gt;元素增加一个target属性，告诉浏览器使用一个不同的窗口。target属性值会告诉浏览器页面的目标窗口。如果使用_blank作为目标，浏览器就总是打开一个新窗口显示页面。 &lt;a target=&quot;_blank&quot; href=&quot;...&quot;&gt;XXX&lt;/a&gt; ：我得到一个新的标签页，而不是新窗口。是不是哪里做错了? ：不，你没做错。大多数浏览器现在有都有一个默认设置，会在一个标签页中打开新窗口，而不是一个全新的浏览器窗口，因为用户好像更喜欢这样。不过新的标鉴页和新窗口实际上是一样的，只是标签页可以共享原窗口的窗口边框。如果想强制打开一个新的窗口，则大多数浏览器上可以通过首选项设置来实现。 不一定要把target都指定为_blank。如果指定另一个名字，如“coffee”，那么有target属性为“coffee”的所有链接都会在同一个窗口中打开。这是因为：为target指定一个特定的名字时（如&quot;coffee&quot;），实际上就是在对显示链接页面的新窗口命名。_blank则是一种特殊情况，告诉浏览器总是使用一个新窗口。 其它标签 bdo标签：改变文字方向 &lt;bdo dir=&quot;rtl&quot;&gt;该段落文字从右到左显示。&lt;/bdo&gt; &lt; br/ &gt; 标签——换行 &lt; hr/ &gt; 标签——水平线 b、strong标签——加粗 i、em标签——斜体 sub标签——下标 sup标签——上标 big——大字体 small——小字体 常用的编程显示的字体风格 code——计算机输出格式 kbd——键盘输入字体 tt——打字机字体 samp——计算机代码格式 var——计算机变量格式 pre标签——完全按照代码中的形式显示 abbr标签 &lt;abbr title=&quot;缩写&quot;&gt; 缩 &lt;/abbr&gt; 在某些浏览器中，当您把鼠标移至缩略词语上时，title 可用于展示表达的完整版本。 cite——引用、引证 del标签——删除线 ins标签——下划线 mark标签——高亮 dfn标签——定义 特殊字符 特殊字符 html代码 含义 &gt; &amp;gt; &lt; &amp;lt; © &amp;copy; 版权 ® &amp;reg; 已注册 &amp; &amp;amp; &quot; &amp;quot; ™ &amp;trade; 商标 &amp;nbsp; 空格 ","link":"https://shaoyihao.github.io/blog/一些html标签/"},{"title":"关于html","content":"html与浏览器 html文件、图片、视频...存储在web服务器上，浏览器可以通过互联网向web服务器发起请求。服务器收到这些请求时，会查找所请求的资源（html文档等）并将找到的资源发回浏览器，浏览器再显示出该页面。 浏览器怎么知道如何显示一个页面呢？这就要用到html了。 HTML 不是一种编程语言，而是一种标记语言，其标签可以告诉浏览器文档的结构和文本的含义，例如：标签可以告诉浏览器哪些是文本是标题，哪些文本是段落，哪些文本需要强调，...有了这些信息，浏览器会按照内置的默认规则显示各个元素。 &lt;h1&gt;Heading&lt;/h1&gt; &lt;!-- &lt;h1&gt;元素 --&gt; &lt;!-- 元素由标签和标签之间的内容组成。 --&gt; html文档的基本结构 一个html文档中的所有标签构成一个 树形结构，根结点为html标签。 &lt;!DOCTYPE html&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;!-- 说明文档的字符编码，否则浏览器可能不能正确解析--&gt; &lt;html lang=&quot;en&quot;&gt; &lt;!--lang属性用于为浏览器确定该网页的语言--&gt; &lt;head&gt; &lt;!-- ... --&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- ... --&gt; &lt;/body&gt; &lt;/html&gt; html 的结构主要分为两大部分：head 和 body。 网页的描述应放入 head 标签， 网页的内容（向用户展示的）则应放入 body 标签。 head 在 &lt;head&gt;元素中你可以插入脚本（scripts）, 样式文件（CSS），及各种meta信息。 meta标签 meta标签描述了一些基本的元数据。元数据不显示在页面上，但会被浏览器解析。 META 元素通常用于指定网页的描述，关键词，文件的最后修改时间，作者，和其他元数据。 元数据可以使用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他Web服务。 base标签 &lt;base&gt; 标签描述了基本的链接地址/链接目标，该标签作为HTML文档中所有的链接标签的 默认链接。 link标签 &lt;link&gt; 标签定义了文档与外部资源之间的关系，通常用于链接到样式表。 title标签：即打开网页时，网页的标题。 关于html5 万维网协会（World Wide Web Consortium，“W3C”） 制定和维护着HTML标准。 在旧版的html中，doctype的声明十分复杂，而在html5中，只需： &lt;!doctype html&gt; 浏览器看到这一句，它就认为你在使用标准HTML，不再考虑版本号。实际上HTML不会再有版本6、7、8......，制订标准的人已经把这个规范变成了一个活的标准，它会随着技术的发展形成相应文档，不过不再有版本号。你甚至可以不再把它叫做HTML5（HTML的最后一个版本），因为从现在开始它只是“HTML”。 HTML5除了使doctype声明更加简洁之外，还增加了一堆新元素、一些新属性。不仅可以建立web页面，还可以建立web应用，可以交互，用来完成具体工作。 当编写完一个html文档后，可以利用 W3C验证工具 来检查语法是否有误。(《Head First HTML&amp;CSS》P233介绍了该工具的相关用法。) html5中为页面指定字符编码也更加简便： &lt;!-- &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot;&gt; 旧版写法--&gt; &lt;meta charset=&quot;utf-8&quot;&gt; utf-8是Unicode编码系列中的一种编码，其中u表示的就是Unicode。 对于中文网页需要使用&lt;meta charset=&quot;utf-8&quot;&gt;声明编码，否则会出现乱码。有些浏览器(如 360 浏览器)会设置 GBK 为默认编码，则你需要设置为 &lt;meta charset=&quot;gbk&quot;&gt;。目前在大部分浏览器中，直接输出中文会出现中文乱码的情况，这时候我们就需要在头部将字符声明为 UTF-8 或 GBK。 项目文件的组织 即使是很小的网站，如果把网页、图片和其他资源分别放在不同文件夹中维护，网站也会更容易管理。 最大的、包含所有文件的 那个顶层文件夹 称为网站的 “根文件夹”，通常用 / 表示。 文件当前所处的文件夹可以用 . 来表示，不过在写相对路径时，.通常可以省略。 用 .. 表示文件当前所处的文件夹的父文件夹。 对于一个路径，若该路径以/开头，则是绝对路径；否则就是相对路径。 单击一个相对路径时，在后台浏览器会根据这个相对路径和当前页面的路径创建一个绝对路径。因此所有web服务器看到的都是绝对路径，这要归功于浏览器。 文件夹、文件之间的嵌套关系可以视为树结构。 ","link":"https://shaoyihao.github.io/blog/关于html/"},{"title":"Windows下安装虚拟机：VMware+Ubuntu","content":"安装VMware与Ubuntu 首先在Ubuntu官网上下载系统文件：下载链接 再安装VMware虚拟机软件：官网链接 VMware Workstation Pro正版是收费的，VMware Workstation Player是免费的。对于Mac系统，还有VMware Fusion。 （百度网盘） 激活VMware： 16版本： ZF3R0-FHED2-M80TY-8QYGC-NPKYF 15版本（以下任一均可） FG78K-0UZ15-085TQ-TZQXV-XV0CD ZA11U-DVY97-M81LP-4MNEZ-X3AW0 YU102-44D86-48D2Z-Z4Q5C-MFAWD 创建虚拟机 导入之前下载好的Ubuntu iso文件： 进行虚拟机的设置与安装 后面就一路continue 最终安装成功！ 修改apt源 apt-get 命令是Ubuntu系统中的包管理工具，可以用来安装、卸载包，也可以用来升级包，还可以用来把系统升级到新的版本。 默认的包安装源在国外，下载速度较慢，因此通常需要将其更换为国内一些镜像源，比如清华源、阿里源等。 参考视频 主要步骤就是：修改/etc/apt目录下的sources.list，该文件是apt用来记录软件包仓库位置的配置文件。 cd /etc/apt sudo cp sources.list sources.list.bak # 将原文件备份一下 sudo chmod +777 sources.list # 修改该文件的权限，使可以修改 进入 清华Ubuntu镜像源，将其中的内容复制。 vim sources.list # 进行修改 # 如果没有安装vim，可以使用 gedit sources.list 将其中的内容全部删除后，将复制的内容粘贴存入，保存。 再运行 sudo apt-get update 到此就成功将源修改了。 其它内容可以参考 关于apt 。 对虚拟机进行一些配置 vim的安装与配置 安装vim sudo apt install vim vim默认的缩进为8个空格，将其设置为4空格： sudo vim /etc/vim/vimrc 添加设置： set ts=4 # tabstop的缩写，设TAB宽度为4个空格 set softtabstop=4 # 在编辑模式的时候按退格键的时候退回缩进的长度，当使用 expandtab 时特别有用 set shiftwidth=4 # 每一级缩进的长度，一般设置成跟 softtabstop 一样 set expandtab # 缩进用空格来表示 set autoindent # 自动缩进 Filezilla连接虚拟机 先运行： sudo apt-get install openssh-server 再通过 ifconfig 获取ip地址（可能需要先安装 net-tools 才能使用该命令）。 下载 filezilla 软件 现在就可以很轻松地在主机与虚拟机之间传递文件了。 开启FTP服务 sudo apt-get install vsftpd 安装后，还需进行配置： sudo vim /etc/vsftpd.conf 在其中找到以下2行： local_enable=YES write_enable=YES 确保这2行没有被注释，如果有，就取消注释。完成后如图所示： 保存后退出。 运行以下命令来重启ftp服务： sudo /etc/init.d/vsftpd restart ssh配置与Putty连接 参考文章 检查已经系统已经存在的SSH Keys： ls -al ~/.ssh 如果没有，便生成一个新的SSH key（ubuntu通过以下命令直接可以生成一个SSH Key）： ssh-keygen 执行命令： cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys 连接本机： ssh localhost 在本机上使用putty连接虚拟机： Putty官网下载 安装java sudo apt-get install default-jdk 注意其中jdk的下载路径： 配置环境变量 参考文章 （其实Ubuntu中好像下载了jdk后就会自动加入环境变量，好像是，因为此时什么都不配置，就已经可以运行java等命令了。因此下面的步骤不一定要进行。） 运行命令 sudo gedit ~/.bashrc 在其中添加 export JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64 export JRE_HOME=$JAVA_HOME/jre export CLASSPATH=$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH 保存后退出。再运行： source .bashrc 现在就配置好了。 运行 echo $JAVA_HOME 可以看到： ","link":"https://shaoyihao.github.io/blog/VMware+Ubuntu/"},{"title":"Linux环境变量","content":"什么是环境变量？ 环境变量简单的说就是当前环境下的参数或者变量。如果说的专业一点就是指在操作系统中用来指定操作系统的一些参数。 举个我们最常见的环境变量 —— PATH，它的用途就是当用户要求系统运行一个程序而没有告诉它程序所在的完整路径时，系统除了在当前目录下寻找此程序外，还要到 PATH 变量 中指定的路径去寻找。用户可以通过设置 PATH 变量，来更好的运行进程。 举个常见的例子，在 Windows 系统中，当我们将 JDK 安装好后，如果直接在命令提示行（cmd）中输入 java 或 javac 相关的命令时，它会提示：“java 不是内部或外部命令，也不是可运行的程序或批处理文件。” 这时候我们就需要将 JDK 中 bin 目录的路径加入到 PATH 变量中去。 在 Linux 系统下配置环境变量最常用的两种方法： 修改家目录下的 .bashrc 文件 修改 /etc/profile 文件 修改家目录下的 .bashrc 文件 .bashrc 文件 主要保存着个人的一些个性化设置，如：命令别名、环境变量等。 cd ~ vi .bashrc # 修改 .bashrc 文件 在 .bashrc 文件的 最后 加入环境变量： 变量名=变量值 ...=... export 变量名 ... 如： JAVA_HOME=/usr/lib/jvm/java-11-openjdk-amd64 JRE_HOME=$JAVA_HOME/jre CLASSPATH=$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATH PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH export JAVA_HOME JRE_HOME CLASSPATH PATH 退出并保存 运行以下命令使其立即生效： source .bashrc 注：如果不执行 source 命令，则需重启系统才能生效 修改 /etc/profile 文件 /etc/profile 文件是系统为每个用户设置的环境信息，当用户第一次登录时，该文件被执行。此文件的改变会涉及到系统的环境，也就是有关 Linux 环境变量的东西。 sudo vi /etc/profile # 修改 /etc/profile 文件 在 /etc/profile 文件的 最后 加入环境变量。 立即生效 source /etc/profile 对比两种方法 修改. bashrc 文件，它可以把使用这些环境变量的权限控制到用户级别，只是针对某一个特定的用户。 修改 /etc/profile 文件，它是针对于所有的用户，使所有用户都有权使用这些环境变量。 相比较起来，第一种方法更加安全，因为如果采用第二种方法，它可能会给系统带来安全性的问题。 建议：如果你的计算机仅仅作为开发使用，则推荐第二种方法，否则最好使用 第一种方法。 ","link":"https://shaoyihao.github.io/blog/Linux环境变量/"},{"title":"数列极限","content":" 数列a1,a2,...,an,...a_1,a_2,...,a_n,...a1​,a2​,...,an​,...本质上就是一个定义域为 N+N_+N+​ 的 离散函数 的值域。 ax=f(x), x∈N+a_x=f(x),\\ \\ \\ \\ x\\in N_+ ax​=f(x), x∈N+​ 定义：对于数列{an}\\{a_n\\}{an​}，ccc是一个确定的常数，若∀ε&gt;0\\forall\\varepsilon&gt;0∀ε&gt;0（不论它多么小），总存在正整数NNN，使得当n&gt;Nn&gt;Nn&gt;N时，都有 ∣an−c∣&lt;ε|a_n-c|&lt;\\varepsilon∣an​−c∣&lt;ε 成立，则称 ccc 是数列{an}\\{a_n\\}{an​}的极限，记为：lim⁡n→∞an=c\\lim\\limits_{n\\rightarrow\\infin}a_n=cn→∞lim​an​=c 或 an→c (n→∞)a_n\\rightarrow c\\ (n\\rightarrow\\infin)an​→c (n→∞) 。 若不存在这样的常数，就称 该数列没有极限（习惯上也说 lim⁡n→∞an\\lim\\limits_{n\\rightarrow\\infin}a_nn→∞lim​an​不存在），或者说该数列是发散的。 深入理解：对于数列{an}\\{a_n\\}{an​}，若随着nnn的无限增大，项ana_nan​无限接近某 一个 常数ccc，则称该数列具有极限ccc。 正数ε\\varepsilonε反映的是距离的接近程度，如果极限存在，则距离应可以任意小，因此虽然定义中描述的是“∀ε&gt;0\\forall\\varepsilon&gt;0∀ε&gt;0”，但实际上只需要ε\\varepsilonε可以取到任意接近0的正值即可，所以ε\\varepsilonε的范围可以为(0,δ)(0,\\delta)(0,δ)（δ\\deltaδ为任意正数）。 只要能够描述出“∣an−c∣|a_n-c|∣an​−c∣任意小”即可，因此使用ε,ε2,ε\\varepsilon,\\varepsilon^2,\\sqrt{\\varepsilon}ε,ε2,ε​都可以（只要保证g(ε)g(\\varepsilon)g(ε)的范围可以取到任意接近0的正值），写作∣an−c∣≤ε|a_n-c|\\le\\varepsilon∣an​−c∣≤ε其实也可以。 先指定ε\\varepsilonε，再相应地对NNN进行取值，本质上NNN其实描述的是下标的某个分界：当n&gt;Nn&gt;Nn&gt;N时，之后的所有下标所对应的数列值都满足∣an−c∣&lt;ε|a_n-c|&lt;\\varepsilon∣an​−c∣&lt;ε 。因此其实换成n≥Nn\\ge Nn≥N也可以，NNN也可以不是整数。 几何意义：对于ccc的任意一个小邻域，处在邻域外的项是有限的，其余项（无限个）都在邻域内。 根据定义证明数列极限 在题目中，{an},c\\{a_n\\},c{an​},c已知，ε\\varepsilonε可视为已知，问题关键在于找到合适的正整数NNN，使n&gt;Nn&gt;Nn&gt;N时，∣an−c∣&lt;ε|a_n-c|&lt;\\varepsilon∣an​−c∣&lt;ε成立，即： ∣an−c∣&lt;ε⟸n&gt;N|a_n-c|&lt;\\varepsilon\\Longleftarrow n&gt;N ∣an​−c∣&lt;ε⟸n&gt;N 因此分析法是常用方法。 例1. 求证：lim⁡n→∞c=c\\lim\\limits_{n\\rightarrow\\infin}c=cn→∞lim​c=c 例2. 求证：lim⁡n→∞1nk=0\\lim\\limits_{n\\rightarrow\\infin}\\frac{1}{n^k}=0n→∞lim​nk1​=0（k&gt;0k&gt;0k&gt;0） 例3. 求证：lim⁡n→∞qn=0\\lim\\limits_{n\\rightarrow\\infin}q^n=0n→∞lim​qn=0（∣q∣&lt;1|q|&lt;1∣q∣&lt;1） 例4. 求证：lim⁡n→∞an=1\\lim\\limits_{n\\rightarrow\\infin}\\sqrt[n]{a}=1n→∞lim​na​=1（a&gt;0a&gt;0a&gt;0） 证明要点： 为贴合数列极限的定义，先假定ε&gt;0\\varepsilon&gt;0ε&gt;0，对∣an−c∣&lt;ε|a_n-c|&lt;\\varepsilon∣an​−c∣&lt;ε进行等价变换，得到n&gt;g(ε)n&gt;g(\\varepsilon)n&gt;g(ε)。为保证g(ε)g(\\varepsilon)g(ε)有意义，可能需要对ε\\varepsilonε的范围进行二次修改。 接下来要考虑的就是NNN的取值。对于任意给定的 ε\\varepsilonε，要能够指出定义中所说的 NNN 确实存在，常用的方法就是实实在在找出一个。NNN应为正整数（贴合定义）。考察g(ε)g(\\varepsilon)g(ε)的范围，若满足g(ε)≥1g(\\varepsilon)\\ge 1g(ε)≥1，则可直接取N=[g(ε)]N=[g(\\varepsilon)]N=[g(ε)]；若g(ε)g(\\varepsilon)g(ε)可能小于1，则有2种常见的方法： 通过修改ε\\varepsilonε的取值范围，使得g(ε)≥1g(\\varepsilon)\\ge 1g(ε)≥1，此时可以取N=[g(ε)]N=[g(\\varepsilon)]N=[g(ε)] 在NNN取值时运用一点trick：例如取N=max⁡{1,g(ε)}N=\\max\\{1,g(\\varepsilon)\\}N=max{1,g(ε)}、N=[g(ε)]+1N=[g(\\varepsilon)]+1N=[g(ε)]+1、... 常用技巧：适当放大法 当从 ∣an−c∣&lt;ε|a_n-c|&lt;\\varepsilon∣an​−c∣&lt;ε 难以变换得到 n&gt;g(ε)n&gt;g(\\varepsilon)n&gt;g(ε) 时，可以先变换为：∣an−c∣≤h(n), n&gt;N1|a_n-c|\\le h(n),\\ n&gt;N_1∣an​−c∣≤h(n), n&gt;N1​，再证明h(n)&lt;ε, n&gt;N2h(n)&lt;\\varepsilon,\\ n&gt;N_2h(n)&lt;ε, n&gt;N2​。如此，取正整数N=max⁡{N1,N2}N=\\max\\{N_1,N_2\\}N=max{N1​,N2​}，则n&gt;Nn&gt;Nn&gt;N时，∣an−c∣|a_n-c|∣an​−c∣ ≤h(n) &lt;ε&lt;\\varepsilon&lt;ε 。 所谓“适当”，是指放大所得的h(n)h(n)h(n)要满足：lim⁡n→∞h(n)=0\\lim\\limits_{n\\rightarrow\\infin}h(n)=0n→∞lim​h(n)=0 ，且h(n)h(n)h(n)应尽量简单。 例5. 求证：lim⁡n→∞n2sin⁡n!+100n40+2n32+1=0\\lim\\limits_{n\\rightarrow\\infin}\\frac{n^2\\sin n!+100}{n^{40}+2n^{32}+1}=0n→∞lim​n40+2n32+1n2sinn!+100​=0 重要的数列极限 lim⁡n→∞c=clim⁡n→∞1nk=0, k&gt;0lim⁡n→∞qn=0, ∣q∣&lt;1lim⁡n→∞an=1, a&gt;0lim⁡n→∞nn=1lim⁡n→∞ann!=0\\lim\\limits_{n\\rightarrow\\infin}c=c\\\\\\lim\\limits_{n\\rightarrow\\infin}\\frac{1}{n^k}=0,\\ \\ k&gt;0\\\\\\lim\\limits_{n\\rightarrow\\infin}q^n=0,\\ \\ |q|&lt;1\\\\\\textcolor{#F00}{\\lim\\limits_{n\\rightarrow\\infin}\\sqrt[n]{a}=1,\\ \\ a&gt;0}\\\\\\textcolor{#F00}{\\lim\\limits_{n\\rightarrow\\infin}\\sqrt[n]{n}=1}\\\\\\lim\\limits_{n\\rightarrow\\infin}\\frac{a^n}{n!}=0 n→∞lim​c=cn→∞lim​nk1​=0, k&gt;0n→∞lim​qn=0, ∣q∣&lt;1n→∞lim​na​=1, a&gt;0n→∞lim​nn​=1n→∞lim​n!an​=0 收敛数列的性质 极限唯一性：若数列{an}\\{a_n\\}{an​}有极限，则极限唯一。 若数列{an}\\{a_n\\}{an​}有极限，则称{an}\\{a_n\\}{an​}收敛，否则称{an}\\{a_n\\}{an​}发散。 对于一个数列，改变（或添加、删除）有限项，不影响该数列的收敛性。 lim⁡n→∞an=c ⟹ lim⁡n→∞an+m=c (m∈N+)\\lim\\limits_{n\\rightarrow\\infin}a_n=c\\ \\Longrightarrow\\ \\lim\\limits_{n\\rightarrow\\infin}a_{n+m}=c\\ \\ \\ \\ (m\\in N_+) n→∞lim​an​=c ⟹ n→∞lim​an+m​=c (m∈N+​) 若数列{an}\\{a_n\\}{an​}收敛，则{an}\\{a_n\\}{an​}有界。（逆命题不成立：有界不一定收敛） 数列是特殊的函数，因此有界数列的定义与有界函数的定义相似： 若存在常数M&gt;0M&gt;0M&gt;0，对于任意自然数nnn，都有∣an∣≤M|a_n|\\le M∣an​∣≤M，则称{an}\\{a_n\\}{an​}有界。 已知lim⁡n→∞an=a, lim⁡n→∞bn=b\\lim\\limits_{n\\rightarrow\\infin}a_n=a,\\ \\lim\\limits_{n\\rightarrow\\infin}b_n=bn→∞lim​an​=a, n→∞lim​bn​=b，若a&lt;ba&lt;ba&lt;b，则存在N0N_0N0​，当n&gt;N0n&gt;N_0n&gt;N0​时，都有an&lt;bna_n&lt;b_nan​&lt;bn​ 。 推论：∃N0, ∀n,m&gt;N0, an&lt;bm\\exist N_0,\\ \\forall n,m&gt;N_0,\\ a_n&lt;b_m∃N0​, ∀n,m&gt;N0​, an​&lt;bm​ 。 已知lim⁡n→∞an=a, lim⁡n→∞bn=b\\lim\\limits_{n\\rightarrow\\infin}a_n=a,\\ \\lim\\limits_{n\\rightarrow\\infin}b_n=bn→∞lim​an​=a, n→∞lim​bn​=b，若存在N0N_0N0​，当n&gt;N0n&gt;N_0n&gt;N0​时，都有bn≥anb_n\\ge a_nbn​≥an​，则b≥ab\\ge ab≥a 。 注意：若存在N0N_0N0​，当n&gt;N0n&gt;N_0n&gt;N0​时，都有bn&gt;anb_n&gt; a_nbn​&gt;an​也只能推出b≥ab\\ge ab≥a，而并不能推出b&gt;ab&gt; ab&gt;a 。 例如：an=−1n, bn=1na_n=-\\frac{1}{n},\\ b_n=\\frac{1}{n}an​=−n1​, bn​=n1​，则n&gt;1n&gt;1n&gt;1时，bn&gt;anb_n&gt;a_nbn​&gt;an​恒成立，但两数列的极限相等。 保号性 （保正号）若lim⁡n→∞an=c&gt;0\\lim\\limits_{n\\rightarrow\\infin}a_n=c&gt;0n→∞lim​an​=c&gt;0，对∀η∈(0,c)\\forall\\eta\\in(0,c)∀η∈(0,c)，∃N\\exist N∃N，当n&gt;Nn&gt;Nn&gt;N时，都有an&gt;η&gt;0a_n&gt;\\eta&gt;0an​&gt;η&gt;0 。 （保负号）若lim⁡n→∞an=c&lt;0\\lim\\limits_{n\\rightarrow\\infin}a_n=c&lt;0n→∞lim​an​=c&lt;0，对∀η∈(c,0)\\forall\\eta\\in(c,0)∀η∈(c,0)，∃N\\exist N∃N，当n&gt;Nn&gt;Nn&gt;N时，都有an&lt;η&lt;0a_n&lt;\\eta&lt;0an​&lt;η&lt;0 。 数列极限的四则运算：若lim⁡n→∞an=a, lim⁡n→∞bn=b\\lim\\limits_{n\\rightarrow\\infin}a_n=a,\\ \\ \\lim\\limits_{n\\rightarrow\\infin}b_n=bn→∞lim​an​=a, n→∞lim​bn​=b（前提是二者极限都存在），则： lim⁡n→∞(an±bn)=lim⁡n→∞an±lim⁡n→∞bn=a±b\\lim\\limits_{n\\rightarrow\\infin}(a_n\\pm b_n)=\\lim\\limits_{n\\rightarrow\\infin}a_n\\pm\\lim\\limits_{n\\rightarrow\\infin}b_n=a\\pm bn→∞lim​(an​±bn​)=n→∞lim​an​±n→∞lim​bn​=a±b lim⁡n→∞(an⋅bn)=lim⁡n→∞an⋅lim⁡n→∞bn=ab\\lim\\limits_{n\\rightarrow\\infin}(a_n\\cdot b_n)=\\lim\\limits_{n\\rightarrow\\infin}a_n\\cdot\\lim\\limits_{n\\rightarrow\\infin}b_n=abn→∞lim​(an​⋅bn​)=n→∞lim​an​⋅n→∞lim​bn​=ab 特别的，lim⁡n→∞(c⋅an)=lim⁡n→∞c⋅lim⁡n→∞an=ca\\lim\\limits_{n\\rightarrow\\infin}(c\\cdot a_n)=\\lim\\limits_{n\\rightarrow\\infin}c\\cdot\\lim\\limits_{n\\rightarrow\\infin}a_n=can→∞lim​(c⋅an​)=n→∞lim​c⋅n→∞lim​an​=ca lim⁡n→∞(anbn)=lim⁡n→∞anlim⁡n→∞bn=ab\\lim\\limits_{n\\rightarrow\\infin}(\\frac{a_n}{ b_n})=\\frac{\\lim\\limits_{n\\rightarrow\\infin}a_n}{\\lim\\limits_{n\\rightarrow\\infin}b_n}=\\frac{a}{b}n→∞lim​(bn​an​​)=n→∞lim​bn​n→∞lim​an​​=ba​（b≠0b\\ne0b​=0） 极限的四则运算可以推广到有限项，但不能推广到无限项。 重要公式： lim⁡n→∞a0np+a1np−1+...+ap−1n+apb0nq+b1nq−1+...+bq−1n+bq={0, p&lt;qa0b0, p=q∞, p&gt;q\\textcolor{#F00}{\\lim\\limits_{n\\rightarrow\\infin}\\frac{a_0n^p+a_1n^{p-1}+...+a_{p-1}n+a_p}{b_0n^q+b_1n^{q-1}+...+b_{q-1}n+b_q}=\\left\\{\\begin{matrix} 0, \\ \\ \\ \\ p&lt;q \\\\ \\frac{a_0}{b_0}, \\ \\ \\ p=q\\\\\\infin, \\ \\ \\ p&gt;q \\end{matrix}\\right.} n→∞lim​b0​nq+b1​nq−1+...+bq−1​n+bq​a0​np+a1​np−1+...+ap−1​n+ap​​=⎩⎨⎧​0, p&lt;qb0​a0​​, p=q∞, p&gt;q​ lim⁡n→∞a0np+a1np−1+...+ap−1n+apb0nq+b1nq−1+...+bq−1n+bq=lim⁡n→∞(npnq⋅a0+a11n+...+ap−11np−1+ap1npb0+b11n+...+bq−11nq−1+bq1nq)=a0b0lim⁡n→∞npnq\\lim\\limits_{n\\rightarrow\\infin}\\frac{a_0n^p+a_1n^{p-1}+...+a_{p-1}n+a_p}{b_0n^q+b_1n^{q-1}+...+b_{q-1}n+b_q}=\\lim\\limits_{n\\rightarrow\\infin}\\left(\\frac{n^p}{n^q}\\cdot\\frac{a_0+a_1\\frac{1}{n}+...+a_{p-1}\\frac{1}{n^{p-1}}+a_p\\frac{1}{n^p}}{b_0+b_1\\frac{1}{n}+...+b_{q-1}\\frac{1}{n^{q-1}}+b_q\\frac{1}{n^q}}\\right)=\\frac{a_0}{b_0}\\lim\\limits_{n\\rightarrow\\infin}\\frac{n^p}{n^q} n→∞lim​b0​nq+b1​nq−1+...+bq−1​n+bq​a0​np+a1​np−1+...+ap−1​n+ap​​=n→∞lim​(nqnp​⋅b0​+b1​n1​+...+bq−1​nq−11​+bq​nq1​a0​+a1​n1​+...+ap−1​np−11​+ap​np1​​)=b0​a0​​n→∞lim​nqnp​ 事实上，该公式中分子分母中nnn的指数只要是正数即可，并非只能是自然数。 判断数列收敛的2条准则 夹逼定理 定理：若存在N0N_0N0​，当n&gt;N0n&gt;N_0n&gt;N0​时，都有an≤cn≤bna_n\\le c_n\\le b_nan​≤cn​≤bn​，且lim⁡n→∞an=lim⁡n→∞bn=t\\lim\\limits_{n\\rightarrow\\infin}a_n=\\lim\\limits_{n\\rightarrow\\infin}b_n=tn→∞lim​an​=n→∞lim​bn​=t，则{cn}\\{c_n\\}{cn​}收敛且lim⁡n→∞cn=t\\lim\\limits_{n\\rightarrow\\infin}c_n=tn→∞lim​cn​=t 适用情况：若一个数列有很多项相加或相乘，但不能化简、不能用极限的四则运算法则，此时应尝试使用夹逼定理。 例1：求证 lim⁡n→∞an+bn+cnn=a (a≥b≥c&gt;0)\\textcolor{#F00}{\\lim\\limits_{n\\rightarrow\\infin}\\sqrt[n]{a^n+b^n+c^n}=a}\\ \\ \\ \\ \\ \\ \\ (a\\ge b\\ge c&gt;0)n→∞lim​nan+bn+cn​=a (a≥b≥c&gt;0) 例2：求lim⁡n→∞(1⋅2n2+1+2⋅3n2+2+...+n(n+1)n2+n)\\lim\\limits_{n\\rightarrow\\infin}\\left(\\frac{\\sqrt{1\\cdot2}}{n^2+1}+\\frac{\\sqrt{2\\cdot3}}{n^2+2}+...+\\frac{\\sqrt{n(n+1)}}{n^2+n}\\right)n→∞lim​(n2+11⋅2​​+n2+22⋅3​​+...+n2+nn(n+1)​​) 单调有界原理 若数列{an}\\{a_n\\}{an​}单调递增(a1≤a2≤...≤ana_1\\le a_2\\le...\\le a_na1​≤a2​≤...≤an​)有上界，则{an}\\{a_n\\}{an​}收敛； 若数列{an}\\{a_n\\}{an​}单调递减(a1≥a2≥...≥ana_1\\ge a_2\\ge...\\ge a_na1​≥a2​≥...≥an​)有下界，则{an}\\{a_n\\}{an​}收敛。 显然成立是：递增数列一定有下界：a1a_1a1​；递减数列一定有下界：a1a_1a1​ 。 总结：单调数列若有界 ⟹\\Longrightarrow⟹ 收敛。 该定理的条件可减弱为：{an}\\{a_n\\}{an​}当n&gt;N0n&gt;N_0n&gt;N0​时单调有界，则{an}\\{a_n\\}{an​}收敛。（数列的有限项不影响数列的收敛性） 适用情况： {an}\\{a_n\\}{an​}是由递推关系式给出的 求证{an}\\{a_n\\}{an​}收敛，并求极限（如果题目要用夹逼定理的话，何必先“求证收敛”呢？明明可以直接求出极限） 求证{an}\\{a_n\\}{an​}收敛（如果题目要用夹逼定理的话，为什么不让我们求出极限？说明该题极限可能求不出来，不能用夹逼定理。） 例1：证明 an=(1+1n)na_n=(1+\\frac{1}{n})^nan​=(1+n1​)n 收敛。 设a1,a2,...,ana_1,a_2,...,a_na1​,a2​,...,an​为正数，则： a1+a2+...+ann≥a1a2...ann (等号成立⟺a1=a2=...=an)\\frac{a_1+a_2+...+a_n}{n}\\ge\\sqrt[n]{a_1a_2...a_n}\\ \\ \\ (等号成立\\Longleftrightarrow a_1=a_2=...=a_n) na1​+a2​+...+an​​≥na1​a2​...an​​ (等号成立⟺a1​=a2​=...=an​) 重要结论： lim⁡n→∞(1+1n)n=e\\textcolor{#F00}{\\lim\\limits_{n\\rightarrow\\infin}(1+\\frac{1}{n})^n=e} n→∞lim​(1+n1​)n=e 例2：已知c&gt;0c&gt;0c&gt;0，证明 xn=c+c+...cx_n=\\sqrt{c+\\sqrt{c+...\\sqrt{c}}}xn​=c+c+...c​​​（nnn个根号）收敛，并求其极限。 证明单调递增 证明有界 求极限 例3：已知x0=2，xn=2xn−13+13xn−12，n=1,2,..x_0=2，x_n=\\frac{2x_{n-1}^3+1}{3x_{n-1}^2}，n=1,2,..x0​=2，xn​=3xn−12​2xn−13​+1​，n=1,2,..，求证{xn}\\{x_n\\}{xn​}收敛，并求其极限。 例4：xn=1+12!+13!+...+1n!x_n=1+\\frac{1}{2!}+\\frac{1}{3!}+...+\\frac{1}{n!}xn​=1+2!1​+3!1​+...+n!1​，求证{xn}\\{x_n\\}{xn​}收敛。 子数列 定义：设{an}\\{a_n\\}{an​}是一个给定数列，从该数列中挑选出 无限项 按原来的顺序 排成一无限列：an1,an2,...,ank,...a_{n_1},a_{n_2},...,a_{n_k},...an1​​,an2​​,...,ank​​,... 该数列称为{an}\\{a_n\\}{an​}的一个子数列，记作{ank}\\{a_{n_k}\\}{ank​​}。 注意：nkn_knk​是在原数列中的下标，kkk是在子数列中的下标，显然满足：nk≥kn_k\\ge knk​≥k 。 定理：数列{an}\\{a_n\\}{an​}收敛 ⟺\\Longleftrightarrow⟺ {an}\\{a_n\\}{an​}的所有子数列均收敛且极限相同。 该定理通常用于证明数列发散：存在某个子数列极限不存在 或 存在两个子数列的极限不同。 例1：求证{sin⁡nπ4}\\{\\sin\\frac{n\\pi}{4}\\}{sin4nπ​}发散。 定理：数列{an}\\{a_n\\}{an​}收敛 ⟺\\Longleftrightarrow⟺ {an}\\{a_n\\}{an​}的奇子数列{a2k−1}\\{a_{2k-1}\\}{a2k−1​}和偶子数列{a2k}\\{a_{2k}\\}{a2k​}均收敛且极限相同。 ","link":"https://shaoyihao.github.io/blog/数列极限/"},{"title":"关于开源","content":"简单来说，开源软件的特点就是把软件程序与源代码文件一起打包提供给用户，让用户在不受限制地使用某个软件功能的基础上还可以按需进行修改，或编制成衍生产品再发布出去。用户具有使用自由、修改自由、重新发布自由以及创建衍生品的自由。 开源软件最重要的特性有： 低风险 使用闭源软件无疑把命运交付给他人，一旦封闭的源代码没有人来维护，你将进退维谷；而且相较于商业软件公司，开源社区很少存在倒闭的问题。 高品质 相较于闭源软件产品，开源项目通常是由开源社区来研发及维护的，参与编写、维护、测试的用户量众多，一般的bug还没有等爆发就已经被修补。 低成本 开源工作者都是在幕后默默且无偿地付出劳动成果，为美好的世界贡献一份力量，因此使用开源社区推动的软件项目可以节省大量的人力、物力和财力。 更透明 没有哪个笨蛋会把木马、后门等放到开放的源代码中，这样无疑是把自己的罪行暴露在阳光之下。 为保证开源工作者的权益，世界上现在有60多种被**开源促进组织（Open Source Initiative）**认可的开源许可协议： GNU GPL（GNU General Public License，GNU通用公共许可证） 只要软件中包含了遵循GPL协议的产品或代码，那么该软件就必须也遵循GPL许可协议且开源、免费。因此这个协议并不适合商用软件。遵循该协议的开源软件数量极其庞大，包括Linux系统在内的大多数的开源软件都是基于这个协议的。 GPL开源许可协议特点有： 复制自由：允许把软件复制到任何人的电脑中，并且不限制复制的数量。 传播自由：允许软件以各种形式进行传播。 收费传播：允许在各种媒介上出售该软件，但必须提前让买家知道这个软件是可以免费获得的。因此一般来讲，开源软件都是通过为用户提供有偿服务的形式来盈利的。 修改自由：允许开发人员增加或删除软件的功能，但软件修改后必须依然基于GPL许可协议授权。 BSD（Berkeley Software Distribution，伯克利软件发布版）许可协议 用户可以使用、修改和重新发布遵循该许可的软件，并且可以将软件作为商业软件发布和销售，前提是需要满足下面3个条件： 如果再发布的软件中包含源代码，则源代码必须继续遵循BSD许可协议。 如果再发布的软件中只有二进制程序，则需要在相关文档或版权文件中声明原始代码遵循了BSD协议。 不允许用原始软件的名字、作者名字或机构名称进行市场推广。 Apache许可证版本（Apache License Version）许可协议 在为开发人员提供版权及专利许可的同时，允许用户拥有修改代码及再发布的自由。该许可协议适用于商业软件。程序开发人员在开发遵循该协议的软件时，要严格遵守下面的4个条件： 该软件及其衍生品必须继续使用Apache许可协议。 如果修改了程序源代码，需要在文档中进行声明。 若软件是基于他人的源代码编写而成的，则需要保留原始代码的协议、商标、专利声明及其他原作者声明的内容信息。 如果再发布的软件中有声明文件，则需在此文件中标注Apache许可协议及其他许可协议。 MPL（Mozilla Public License，Mozilla公共许可）许可协议 相较于GPL许可协议，MPL更加注重对开发者的源代码需求和收益之间的平衡。 MIT（Massachusetts Institute of Technology）许可协议 目前限制最少的开源许可协议之一，只要程序的开发者在修改后的源代码中保留原作者的许可信息即可，因此普遍被商业软件所使用。 ","link":"https://shaoyihao.github.io/blog/关于开源/"},{"title":"数制","content":" 每一位的权由基数的幂次决定，不同位上的数有着不同的权值，这称为位权表示法，同时基数也代表着数码的个数。 特点为： 基数为 RRR 的数制中，包含 0,1,...,R−10,1,...,R-10,1,...,R−1 共 RRR 个数码 每个数字都要乘以基数的幂次，该幂次由每个数字所在的位置决定 小数点向右移动一位，数就扩大 RRR 倍；小数点向左移动一位，数就缩小 RRR 倍 每个数码只能有一个字符，多个字符就含有进位关系 对于任意一个 kkk 进制数 AAA： A=AnAn−1...A1A0 . A−1A−2...A−m（并列表示法） =An×kn+An−1×kn−1+...+A1×k1+A0×k0+A−1×k−1+...+A−m×k−m（多项式表示法）=∑i=n−mAi×ki A = A_nA_{n-1}...A_1A_0\\ .\\ A_{-1}A_{-2}...A_{-m}（并列表示法） \\\\\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ =A_n\\times k^n+A_{n-1}\\times k^{n-1}+...+ A_1\\times k^1+A_0\\times k^0+A_{-1}\\times k^{-1}+...+A_{-m}\\times k^{-m}（多项式表示法）\\\\=\\sum_{i = n}^{-m}A_i\\times k^i\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ A=An​An−1​...A1​A0​ . A−1​A−2​...A−m​（并列表示法） =An​×kn+An−1​×kn−1+...+A1​×k1+A0​×k0+A−1​×k−1+...+A−m​×k−m（多项式表示法）=i=n∑−m​Ai​×ki 位权表示法并不能精确地表示所有小数，例如十进制下无法表示出无限小数。也有许多小数无法用二进制精确表示，例如 0.10.10.1。 基于此的二（可以是k）进制转化为十进制程序： #include &lt;iostream&gt; #include &lt;cmath&gt; using namespace std; int main() { string num; cin &gt;&gt; num; bool flag = false; //记录是否为小数 int n, m = 0; // m为小数部分的位数，n为整数部分的位数 for (int i = 0; i &lt; (int)num.size(); i ++) { if (flag) m ++; if (num[i] == '.') flag = true; } if (flag) n = num.size() - m - 1; //字符串中含小数点 else n = num.size() - m; //不含小数点 double ans = 0; for (int i = 0, j = n - 1; i &lt; (int)num.size(); i ++) { if (num[i] == '.') continue; //跳过小数点 ans += (num[i] - '0') * pow(2, j); //二进制 j --; } cout &lt;&lt; ans; return 0; } 常见进制 十进制 —— decimal system 二进制 —— binary system 八进制 —— octal system 十六进制 —— hexadecimal system 通常用数字后面跟一个英文字母来表示该数的数制：d, D, b, B, o, O, h, H。 二进制的加法、乘法 加法 乘法 0 + 0 = 0 0 ×\\times× 0 = 0 0 + 1 = 1 0 ×\\times× 1 = 0 1 + 0 = 1 1 ×\\times× 0 = 0 1 + 1 = 10 1 ×\\times× 1 = 1 十进制转化为k进制数 void f(int x) //递归（逆序输出） { int t = x % 2; if (x / 2) f(x / 2); cout &lt;&lt; t; //输出余数 } 2n2^n2n 的二进制表示就是：1后面跟nnn个0 注意到：十进制小数并不是都能够用有限位的其它进制数精确地表示，这时应根据精度要求转换到一定的位数为止。 要求精度为10−k10^{-k}10−k时，设二进制小数位数为mmm，有：2−m≤10−k⟹m≥klg⁡2≈3.32k2^{-m}\\le 10^{-k}\\Longrightarrow m\\ge\\frac{k}{\\lg2}\\approx3.32k2−m≤10−k⟹m≥lg2k​≈3.32k，根据这种方法可以很方便的求出转换后的二进制小数的位数。 一般当要求二进制数取mmm位小数时，可求出m+1m+1m+1位，然后对最低位做0舍1入处理。 如果一个十进制数既有整数部分又有小数部分，则应将整数部分和小数部分分别进行转化，再把两者结果相加。 技巧： 一个数除以2n2^n2n，就是将该数的二进制表示中的小数点左移nnn位。 例如 131313（8+4+1）的二进制形式为：1101，因此1316\\frac{13}{16}1613​的二进制表示为：0.1101。 一个数乘以2n2^n2n，就是将该数的二进制表示中的小数点右移nnn位。 还有一种常用方法：降幂法。 例如，对于十进制数117117117，先提取出 64=2664=2^664=26；剩下 117−64=53117-64=53117−64=53，提取出 32=2532=2^532=25；剩下 53−32=2153-32=2153−32=21，提取出 16=2416=2^416=24；剩下 21−16=521-16=521−16=5，提取出 4=224=2^24=22；剩下 5−4=15-4=15−4=1，提取出 1=201=2^01=20。因此：117=26+25+24+22+20117=2^6+2^5+2^4+2^2+2^0117=26+25+24+22+20，所以其二进制为：111010111101011110101 。 二进制、八进制、十六进制之间的转换 3位二进制数是1位八进制数，因此将二进制数转换为八进制数的方法为： 以小数点为界 将小数点左侧（整数部分）从右往左分别按每3位为1组，不足3位用0补足，转为8进制 将小数点右侧（小数部分）从左往右分别按每3位为1组，不足3位用0补足，转为8进制 八进制转换为二进制，只需将每一位转换为对应的二进制数即可。 4位二进制数是1位十六进制数，则转换方法类似于二进制、八进制之间的转换。 计算机中使用二进制 对于有 101010 个手指的人类来说，使用十进制表示法是很自然的事情。但是当构造存储和处理信息的机器时，二进制工作得更好。 二值信号能够很容易地被表示、存储和传输。例如可以表示为：穿孔卡片上有洞或无洞、导线上的高电压或低电压、顺时针或逆时针的磁场。 对二值信号进行存储和执行计算的电子电路非常简单和可靠。 ","link":"https://shaoyihao.github.io/blog/数制/"},{"title":"选出最多的数","content":" 原题链接：钻石收藏家 题目大意：在nnn个数中选出最多的数，满足任意两数的差值≤k\\le k≤k。 思路： 首先将这nnn个数进行从小到大排序。 对于元素aia_iai​，使指针jjj指向最远的满足aj−ai≤ka_j-a_i\\le kaj​−ai​≤k的元素。 记录r[i]=jr[i] = jr[i]=j，表示以aia_iai​为左端点时，最右能到达aja_jaj​，即[ai...aj][a_i...a_j][ai​...aj​]是以aia_iai​为左端点的极大区间，区间的长度为 len[i]=r[i]−i+1len[i]=r[i]-i+1len[i]=r[i]−i+1。 每个元素都对应着一个极大区间，nnn个极大区间中的最大者即答案。 注意到：当r[i]=jr[i]=jr[i]=j时，一定有：r[i+1]&gt;jr[i+1]&gt;jr[i+1]&gt;j，即jjj指针不断递增，只需扫描一遍数组即可。 #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 50010; int a[N], r[N]; int main() { int n, k; cin &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; n; i ++) cin &gt;&gt; a[i]; sort(a, a + n); for (int i = 0, j = 0; i &lt; n; i ++) { while (j &lt; n &amp;&amp; a[j] - a[i] &lt;= k) j ++; r[i] = j - 1; } int res = 0; for (int i = 0; i &lt; n; i ++) res = max(res, r[i] - i + 1); cout &lt;&lt; res; return 0; } 原题链接：钻石收藏家2 题目大意：从nnn个数中选出元素总数最多的2组数，每组都满足任意两数的差值≤k\\le k≤k 。 思路： 对于元素aia_iai​，可以求出其对应的极大区间[ai, ari][a_i,\\ a_{r_i}][ai​, ari​​]，从而可以得出该区间中的元素数目len[i]=ri−i+1len[i]=r_i-i+1len[i]=ri​−i+1，这是第1组。 对于第2组，我们需要在ari+1...ana_{r_i+1}...a_nari​+1​...an​中选出最大的区间，求出其元素数目mri+1m_{r_i+1}mri​+1​。由于ari+1...ana_{r_i+1}...a_nari​+1​...an​中每一个元素都对应着一个极大区间，也就对应一个极大区间元素数lenlenlen，因此：mri+1=max⁡ri+1≤j≤n{lenj}m_{r_i+1}=\\max\\limits_{r_i+1\\le j\\le n}\\{len_j\\}mri​+1​=ri​+1≤j≤nmax​{lenj​}。 因此，以aia_iai​为首元素的选法的元素总数为：leni+mri+1len_i+m_{r_i+1}leni​+mri​+1​。 最终答案就是：max⁡1≤i≤n{len[i]+m[ri+1]}\\max\\limits_{1\\le i\\le n}\\{len[i]+m[r_i+1]\\}1≤i≤nmax​{len[i]+m[ri​+1]}。 对于数组aaa中的每个元素，我们可以预处理出数组rrr和lenlenlen。 数组mmm中的元素m[i]m[i]m[i]就是子数组len[i∼n]len[i\\sim n]len[i∼n]中的最大值。参考子数组的最值，可以由lenlenlen数组快速得到mmm数组。 #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 50010; int a[N], r[N], len[N], m[N]; int main() { int n, k; cin &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; n; i ++) cin &gt;&gt; a[i]; sort(a, a + n); for (int i = 0, j = 0; i &lt; n; i ++) { while (j &lt; n &amp;&amp; a[j] - a[i] &lt;= k) j ++; r[i] = j - 1; len[i] = r[i] - i + 1; } m[n - 1] = len[n - 1]; for (int i = n - 2; i &gt;= 0; i --) m[i] = max(m[i + 1], len[i]); int res = 0; for (int i = 0; i &lt; n; i ++) res = max(res, len[i] + m[r[i] + 1]); cout &lt;&lt; res; return 0; } ","link":"https://shaoyihao.github.io/blog/选出最多的数/"},{"title":"替换空格","content":" 原题链接：替换空格 题目大意：请实现一个函数，把字符串中的每个空格替换成&quot;%20&quot; (线性扫描) O(n)O(n)O(n) 这个题在 C++ 里比较好做，我们可以从前往后枚举原字符串： 如果遇到空格，则在 string 类型的答案中添加 &quot;%20&quot; 如果遇到其他字符，则直接将它添加在答案中 string replaceSpaces(string &amp;str) { string res; for (auto x : str) if (x == ' ') res += &quot;%20&quot;; else res += x; return res; } 但在 C 语言中，我们没有 string 这种好用的模板，需要自己 malloc 出 char 数组来存储答案。 此时我们就需要分成三步来做： 遍历一遍原字符串，计算出答案的最终长度； malloc 出该长度的 char 数组； 再遍历一遍原字符串，计算出最终的答案数组； (双指针扫描) O(n)O(n)O(n) 优点：需要的额外空间很少，空间复杂度低。 在部分编程语言中，我们可以动态地将原数组长度扩大，此时我们就可以使用双指针算法，来降低空间的使用： 首先遍历一遍原数组，求出最终答案的长度 length； 将原数组 resize 成 length 大小； 使用两个指针，指针i指向原字符串的末尾，指针j指向 length 的位置； 两个指针分别都从后往前遍历， 如果str[i] == ' '，则指针j的位置上依次填充'0', '2', '%'，这样倒着看就是&quot;%20&quot;； 如果str[i] != ' '，则指针j的位置上填充该字符即可。 由于变换之后的字符串长度一定不小于原字符串，所以遍历过程中总存在i &lt;= j，这样可以保证str[j]不会覆盖还未遍历过的str[i]。 string replaceSpaces(string &amp;str) { int len = 0, temp = str.size(); for (char c : str) if (c == ' ') len += 3; else len += 1; str.resize(len); for (int i = temp - 1, j = len - 1; i &gt;= 0; i --) { if (str[i] == ' ') { str[j --] = '0'; str[j --] = '2'; str[j --] = '%'; } else str[j --] = str[i]; } return str; } ","link":"https://shaoyihao.github.io/blog/替换空格/"},{"title":"最长连续不重复子列","content":" 原题链接：最长连续不重复子列 题目大意：给定一个长度为 nnn 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。 即每次处理的是区间[j,i][j,i][j,i]中的元素，判断该区间（子列)中是否含有重复元素。由于iii指针后移，因此发生重复的元素一定是iii当前所指的元素xxx。 此时[j,i][j,i][j,i]之内总含有重复元素，直到jjj后移到经过xxx。 每次iii移动之前，子列[j,i][j,i][j,i]都是不重复子列。iii指针的移动可能会带来重复元素。 const int N = 100010; int a[N], s[N]; int main() { int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i ++) cin &gt;&gt; a[i]; int res = 0; for (int i = 0, j = 0; i &lt; n; i ++) { s[a[i]] ++; //i向后移动一次，该数的出现次数+1，且i,j之间多了一个数 // while (j &lt;= i &amp;&amp; check(i, j) j ++ 此处的check()就是判断一下j、i之间有无重复元素，如果有的话就 j++ while (s[a[i]] &gt; 1)//当i，j之间存在数时，j&lt;=i总成立，因此此处没有必要把它写入判断条件 { s[a[j ++]] --;//j向后移动时，则i,j之间就少了一个数（j当前指向的数） /* int temp = j; j ++; s[a[temp]] --; */ } res = max(res, i - j + 1); } cout &lt;&lt; res; return 0; } ","link":"https://shaoyihao.github.io/blog/最长连续不重复子列/"},{"title":"输出被空格隔开的单词","content":" int main() { char str[1000]; gets(str); int n = strlen(str); for (int i = 0; i &lt; n; i ++) { int j = i; while (j &lt; n &amp;&amp; str[j] != ' ') j ++; for (int k = i; k &lt; j; k ++) cout &lt;&lt; str[k]; cout &lt;&lt; endl; i = j; } return 0; } ","link":"https://shaoyihao.github.io/blog/输出被空格隔开的单词/"},{"title":"双指针算法","content":"双指针算法大体上分为两类: 两个指针指向两个序列 两个指针指向同一个序列，操作的是同一个序列中的不同区间 通常的写法： for (i = 0, j = k; i &lt; n; i ++)//i遍历一遍 { while (j &lt; i &amp;&amp; check(i, j)) j ++; /*...不同题目的独有逻辑...*/ } 双指针算法的两个指针的移动次数均不会超过n，加在一起不超过2n，因此双指针算法都是O(n)O(n)O(n)的。 核心用途就是：运用某些性质，将暴力的二重循环O(n2)O(n^2)O(n2)优化到O(n)O(n)O(n) 做题时，可以先想一下暴力解法，再找 i 和 j 之间有什么规律（单调关系），从而优化为双指针解法。 ","link":"https://shaoyihao.github.io/blog/双指针/"},{"title":"子序列","content":" 原题链接：子序列 题目大意：给定2个序列SSS和ppp，判断ppp是否为SSS的子序列。（SSS的长度一定大于等于ppp的长度） 子序列的定义：序列的一些项按原有次序排列而得的新序列，例如序列{a1,a3,a5}\\{a1,a3,a5\\}{a1,a3,a5}是序列{a1,a2,a3,a4,a5}\\{a1,a2,a3,a4,a5\\}{a1,a2,a3,a4,a5}的一个子序列。 变式题：判断一个字符串是否为另一个字符串的子串。 思路： 令 iii指针 指向SSS的首端，jjj指针 指向ppp的首端。iii指针遍历SSS数组，而jjj指针只有当S[i]=p[j]S[i]=p[j]S[i]=p[j]时才向后移动1位。 若jjj指针最终可以移到ppp数组的末尾，则说明ppp数列是SSS数列的子序列；若iii指针已经将SSS遍历完而jjj却未到ppp的末尾，这就说明：ppp比SSS长 或 ppp中存在某个元素是SSS所没有的，无论是哪种情况，都说明ppp不是SSS的子序列。 简写方式：puts(flag ? &quot;Yes&quot; : &quot;No&quot;); const int N = 100010; int p[N], S[N]; int n, m; int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i ++) cin &gt;&gt; p[i]; for (int i = 0; i &lt; m; i ++) cin &gt;&gt; S[i]; bool flag = false; for (int i = 0, j = 0; i &lt; m; i ++) { if (S[i] == p[j]) j ++; if (j == n) { flag = true; break; } } puts(flag ? &quot;Yes&quot; : &quot;No&quot;); return 0; } string S, p; cin &gt;&gt; S &gt;&gt; p; bool flag = false; for (int i = 0, j = 0; i &lt; S.size(); i ++) { if (S[i] == p[j]) j ++; if (j == p.size()) { flag = true; break; } } puts(flag ? &quot;Yes&quot; : &quot;No&quot;); 另一种思路： 若ppp是SSS的子序列，则ppp中每个元素都可以按顺序在SSS中找到。因此枚举ppp每个元素，在SSS中查找该元素，直到找到后，再处理ppp的下一个元素；若在SSS中找不到，则ppp比SSS长 或 该元素是SSS所没有的，总之ppp不是SSS的子序列。 string S, p; cin &gt;&gt; S &gt;&gt; p; bool flag = true; for (int i = 0, j = 0; i &lt; p.size(); i ++) { while (j &lt; S.size() &amp;&amp; S[j] != p[i]) j ++; if (j == S.size()) //到最后也没找到，说明不是子序列 { flag = false; break; } else j ++; // S[j] == p[i]，j指向下一个元素 //若j已经是S的最后一个元素，则i++后指向的元素显然不能在S中找到 } puts(flag ? &quot;Yes&quot; : &quot;No&quot;); ","link":"https://shaoyihao.github.io/blog/子序列/"},{"title":"两（三）数之和","content":" 原题链接：两数之和 题目大意：给定一个含nnn个元素的序列，找出其中一组和为ttt的两个元素。（保证一定有解） 思路：首先将该数列进行递增排序，此时我们来研究一下该数列中蕴含的单调性：令i,ji,ji,j（i&lt;ji&lt;ji&lt;j）分别指向数列中的2个元素，则 若 q[i]+q[j]&gt;tq[i]+q[j]&gt;tq[i]+q[j]&gt;t，则 q[i]+q[j→]q[i]+q[j\\rightarrow]q[i]+q[j→] 也一定大于ttt 若 q[i]+q[j]&lt;tq[i]+q[j]&lt;tq[i]+q[j]&lt;t，则 q[←i]+q[j]q[\\leftarrow i]+q[j]q[←i]+q[j] 也一定小于ttt 算法步骤为： 初始时让 iii 指向首元素，jjj 指向尾元素。 若q[i]+q[j]&gt;tq[i]+q[j]&gt;tq[i]+q[j]&gt;t，则j -- 若q[i]+q[j]&lt;tq[i]+q[j]&lt;tq[i]+q[j]&lt;t，则i ++ 可以证明：对于排好序且有解的数组，该双指针法一定能遍历到最优解。 设最优解的下标分别为 l, rl,\\ rl, r。由于初始时 iii 指向首元素，jjj 指向末元素，则 i≤l&lt;r≤ji\\le l&lt;r\\le ji≤l&lt;r≤j，i,ji,ji,j指针在l,rl,rl,r两侧。根据上述算法步骤，i,ji,ji,j 指针会逐渐向中间靠拢： 若右指针已经移动到了 rrr 时，左指针仍在 lll 左边，则此时q[i]+q[j]&lt;tq[i]+q[j]&lt;tq[i]+q[j]&lt;t， 算法会一直执行i ++直到 i=li=li=l，达到最优解。 若左指针已经移动到了 lll 时，右指针仍在 rrr 右边，则此时q[i]+q[j]&gt;tq[i]+q[j]&gt;tq[i]+q[j]&gt;t， 算法会一直执行j --直到 j=rj=rj=r，达到最优解。 每轮迭代指针必须移动一个，所以最终双指针一定会收敛在 l,rl,rl,r。 【注意到：双指针在任何时候都不可能处于(l,r)( l , r )(l,r) 之间】 时间复杂度：O(n)O(n)O(n) #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 100010; int q[N]; int main() { int n, t; cin &gt;&gt; t &gt;&gt; n; for (int i = 1; i &lt;= n; i ++) cin &gt;&gt; q[i]; sort(q + 1, q + 1 + n); int i = 1, j = n; while (i &lt; j) //循环最多进行到将数组完整扫描一遍（两指针碰撞） { if (q[i] + q[j] &gt; t) j --; else if (q[i] + q[j] &lt; t) i ++; else break; } cout &lt;&lt; q[i] &lt;&lt; ' ' &lt;&lt; q[j]; return 0; } 另一种写法： for (int i = 1, j = n; i &lt;= n; i ++) { while (j &gt; i &amp;&amp; q[i] + q[j] &gt; target) j --; if (q[i] + q[j] == target) { cout &lt;&lt; q[i] &lt;&lt; ' ' &lt;&lt; q[j]; break; } } 若该数列具有多组解，则解的分布一定满足：l1&lt;l2&lt;⋯&lt;lk&lt;rk&lt;⋯&lt;r2&lt;r1l_1&lt;l_2&lt;\\cdots&lt;l_k&lt;r_k&lt;\\cdots&lt;r_2&lt;r_1l1​&lt;l2​&lt;⋯&lt;lk​&lt;rk​&lt;⋯&lt;r2​&lt;r1​，呈现一种层层嵌套的特点。本算法所找出的最优解就是最外层的那个解。 若要找出所有解，只需再找出一个解后，再将指针移动一下即可（打破平衡）。 int i = 1, j = n; while (i &lt; j) { if (q[i] + q[j] &gt; t) j --; else if (q[i] + q[j] &lt; t) i ++; else { cout &lt;&lt; q[i] &lt;&lt; ' ' &lt;&lt; q[j] &lt;&lt; endl; i ++; //i++或j--任写一个（只要让指针向中间移动一下即可） } } 原题链接：三数之和 题目大意：给定一个含nnn个元素的序列，找出所有 和为ttt的三个元素。（保证一定有解） 先固定一个元素q[i]q[i]q[i]，再利用双指针法在剩余元素中寻找2个元素满足元素和为t−q[i]t-q[i]t−q[i]。 时间复杂度为：O(n2)O(n^2)O(n2) #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 100010; int q[N]; int main() { int n, t; cin &gt;&gt; t &gt;&gt; n; for (int i = 1; i &lt;= n; i ++) cin &gt;&gt; q[i]; sort(q + 1, q + 1 + n); for (int i = 1; i &lt;= n; i ++) //“固定”i { int l = i + 1, r = n; while (l &lt; r) { if (q[l] + q[r] == t - q[i]) { cout &lt;&lt; q[i] &lt;&lt; ' ' &lt;&lt; q[l] &lt;&lt; ' ' &lt;&lt; q[r] &lt;&lt; endl; r --; } else if (q[l] + q[r] &gt; t - q[i]) r --; else l ++; } } return 0; } xmuoj上还有一道四数之和也可以利用这种双指针法以O(n3)O(n^3)O(n3)的时间复杂度AC（没啥意思）。 ","link":"https://shaoyihao.github.io/blog/两（三）数之和/"},{"title":"炸弹","content":" 原题链接：激光炸弹 #include &lt;iostream&gt; using namespace std; const int N = 5010; int s[N][N]; int main() { int cnt, R; cin &gt;&gt; cnt &gt;&gt; R; R = min(5001, R); //缩小R的范围 while (cnt --) { int x, y, w; cin &gt;&gt; x &gt;&gt; y &gt;&gt; w; s[x + 1][y + 1] += w; //本题中x,y从0开始，因此存储时下标+1 //因为不同目标可能在同一位置，所以此处为 '+=' } int n = 5001, m = 5001; for (int i = 1; i &lt;= n; i ++) for (int j = 1; j &lt;= m; j ++) s[i][j] += s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1]; // 预处理前缀和 int res = 0; for (int i = R; i &lt;= n; i ++) // 暴力枚举所有边长是R的矩形，枚举(i, j)为右下角 for (int j = R; j &lt;= m; j ++) res = max(res, s[i][j] - s[i - R][j] - s[i][j - R] + s[i - R][j - R]); cout &lt;&lt; res; return 0; } ","link":"https://shaoyihao.github.io/blog/炸弹/"},{"title":"领地选择","content":" 原题链接：领地选择 题目大意：给定一个 N×MN\\times MN×M 的矩阵，求其中元素和最大的规模为C×CC\\times CC×C的子矩阵。 （最大子矩阵简化版） 思路：左上角坐标为(i1,j1)(i_1,j_1)(i1​,j1​)，边长为ccc的正方形的右下角坐标为：(i1+c−1, j1+c−1)(i_1+c-1,\\ j_1+c-1)(i1​+c−1, j1​+c−1). 当数据中存在负数时，求最小值时，初始值千万不要想当然设为0，应设为−inf⁡-\\inf−inf。 #include &lt;iostream&gt; #include &lt;climits&gt; using namespace std; typedef long long LL; const int N = 1010; LL a[N][N], S[N][N]; int main() { int n, m, c; cin &gt;&gt; n &gt;&gt; m &gt;&gt; c; for (int i = 1; i &lt;= n; i ++) for (int j = 1; j &lt;= m; j ++) { cin &gt;&gt; a[i][j]; S[i][j] = S[i - 1][j] + S[i][j - 1] - S[i - 1][j - 1] + a[i][j]; } LL res = INT_MIN; int x, y; for (int i1 = 1; i1 + c - 1 &lt;= n; i1 ++) for (int j1 = 1; j1 + c - 1 &lt;= m; j1 ++) //枚举左上角点的坐标 { int i2 = i1 + c - 1, j2 = j1 + c - 1; //求出右下角点的坐标 LL sum = S[i2][j2] - S[i2][j1 - 1] - S[i1 - 1][j2] + S[i1 - 1][j1 - 1]; //该正方形区域内的数字之和 if (res &lt; sum) { res = sum; x = i1, y = j1; } } cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y; return 0; } ","link":"https://shaoyihao.github.io/blog/领地选择/"},{"title":"k倍区间","content":" 原题链接：k倍区间 题目大意：若一个区间中的元素之和是kkk的倍数，则称该区间是一个kkk倍区间。统计一个数组中有多少个kkk倍区间。 方法一：暴力O(n3)O(n^3)O(n3)，时间复杂度太大。 方法二：暴力枚举区间+前缀和优化：O(n2)O(n^2)O(n2)，时间复杂度也较大。 int res = 0; for (int l = 1; l &lt;= n; l ++) for (int r = l; r &lt;= n; r ++) if ((S[r] - S[l - 1]) % k == 0) res ++; cout &lt;&lt; res; 方法三： 在枚举区间时，若采用先枚举左端点再枚举右端点的方式，左端点的枚举过程中的信息对枚举右端点毫无帮助，这是一种信息的浪费。因此推荐先枚举右端点，再枚举左端点： for (int r = 1; r &lt;= n; r ++) for (int l = 1; l &lt;= r; l ++) ... 注意到：kkk倍区间即区间的端点l,rl,rl,r满足：(S[r]−S[l−1]) % k=0(S[r]-S[l-1])\\ \\%\\ k=0(S[r]−S[l−1]) % k=0，也就是：S[r] % k=S[l−1] % kS[r]\\ \\%\\ k=S[l-1]\\ \\%\\ kS[r] % k=S[l−1] % k。 因此每枚举一个右端点rrr，只需求出有多少个左端点lll(1≤l≤r1\\le l\\le r1≤l≤r) 满足S[l−1] % k=S[r] % kS[l-1]\\ \\%\\ k=S[r]\\ \\%\\ kS[l−1] % k=S[r] % k（1≤l−1&lt;r1\\le l-1&lt; r1≤l−1&lt;r），这便是以rrr为右端点的kkk倍区间的数目。 在枚举右端点的过程中，可以维护一个数组cnt，cnt[x]cnt[x]cnt[x]表示模kkk为xxx的数的个数。 #include &lt;iostream&gt; using namespace std; const int N = 100010; int a[N], cnt[N]; long long S[N]; //前缀和可能会爆int int main() { int n, k; cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n; i ++) { cin &gt;&gt; a[i]; S[i] = S[i - 1] + a[i]; } long long res = 0; cnt[0] = 1; //S[0]=0，则S[0]%K=0，所以cnt[0]初始值为1 for (int r = 1; r &lt;= n; r ++) { int t = S[r] % k; res += cnt[t]; //cnt[t]即之前遍历过的点中 模k为t 的点的数目，也就是模k为t的左端点的数目 （不包括r本身，因为l-1&lt;r。因此先计算res，后更新cnt[t]） cnt[t] ++; //更新 } cout &lt;&lt; res; return 0; } ","link":"https://shaoyihao.github.io/blog/k倍区间/"},{"title":"传送阵","content":"原题链接：分段 从起点到第 i+1i+1i+1 个城市之间有 iii 段路。设 S[i]S[i]S[i] 为走到 i+1i + 1i+1 城市（即走了 iii 段路）所需的时间。“传送”可以从第iii个城市直接跳到第i+ki+ki+k个城市，之间的用时为0。因此用时为：S[n−1]−(S[i+k−1]−S[i−1])S[n-1]-(S[i+k-1]-S[i-1])S[n−1]−(S[i+k−1]−S[i−1]) 。 枚举所有的传送情况，取最小值。 #include &lt;iostream&gt; #include &lt;climits&gt; using namespace std; typedef long long LL; const int N = 1000010; LL a[N], S[N]; int main() { int n, k; cin &gt;&gt; n &gt;&gt; k; for (int i = 1; i &lt;= n - 1; i ++) { cin &gt;&gt; a[i]; S[i] = S[i - 1] + a[i]; } LL res = LONG_MAX; for (int i = 1; i + k &lt;= n; i ++) //枚举所有的传送情况，取总时间的最小值 res = min(res, S[i - 1] + S[n - 1] - S[i + k - 1]); cout &lt;&lt; res; return 0; } ","link":"https://shaoyihao.github.io/blog/传送/"},{"title":"一号线上的地点","content":" 原题链接：一号线上的地点 题目大意：nnn 个地点在一条线上，n−1n-1n−1段路，从地点iii到相邻地点i+1i+1i+1的路费有2种：车票费AiA_iAi​ 或 刷卡BiB_iBi​（Bi&lt;AiB_i&lt;A_iBi​&lt;Ai​），而办卡需要 CiC_iCi​ 元。给定访问地点的顺序，求路费最少是多少。 思路：对于一段路 pi—pi+1p_i—p_{i+1}pi​—pi+1​，只有2种乘车方式：买票或办卡。具体哪一种更便宜取决于这条路要走多少次，若该段路走xxx次，则该路段所耗的费用为：min{ax, c+bx}min\\{ax, \\ c+bx\\}min{ax, c+bx}。 因此问题就转化为统计每段路走了多少次。可以用一维差分和前缀和统计集合中元素的使用次数。 用S[i]S[i]S[i]表示 pi—pi+1p_i—p_{i+1}pi​—pi+1​ 这段路的经过次数。 若起终点为[l,r][l,r][l,r]（注意：l≤rl\\le rl≤r)，则应使S[l],S[l+1],...,S[r−1]S[l], S[l+1], ..., S[r-1]S[l],S[l+1],...,S[r−1]都+1，根据差分，即：q[l]+1,q[r]−1q[l]+1, q[r]-1q[l]+1,q[r]−1。 #include &lt;iostream&gt; using namespace std; typedef long long LL; const int N = 100010; int p[N], a[N], b[N], c[N]; int q[N], S[N]; void insert(int l, int r) //差分 { q[l] += 1; q[r] -= 1; } int main() { int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= m; i ++) //m个途径城市（起始点） { cin &gt;&gt; p[i]; if (i &gt;= 2) insert(min(p[i - 1], p[i]), max(p[i - 1], p[i])); //保证起点小于终点 } for (int i = 1; i &lt;= n - 1; i ++) S[i] = S[i - 1] + q[i]; //前缀和，统计每段路的经过次数 for (int i = 1; i &lt;= n - 1; i ++) cin &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; c[i]; LL res = 0; for (int i = 1; i &lt;= n - 1; i ++) //求出n-1段路的总费用 res += min((LL)S[i] * a[i], (LL)S[i] * b[i] + c[i]); cout &lt;&lt; res; return 0; } ","link":"https://shaoyihao.github.io/blog/一号线上的地点/"},{"title":"地毯","content":" 原题链接：地毯 题目大意：在 n×nn\\times nn×n 的格子上有 mmm 个矩形地毯。问每个点被多少个地毯覆盖。 思路：使用二维差分统计这 mmm 个操作，最后求一下二维前缀和即可。 #include &lt;iostream&gt; using namespace std; const int N = 1010; int a[N][N], S[N][N]; void insert(int x1, int y1, int x2, int y2, int c) { a[x1][y1] += c; a[x2 + 1][y1] -= c; a[x1][y2 + 1] -= c; a[x2 + 1][y2 + 1] += c; } int main() { int n, m; cin &gt;&gt; n &gt;&gt; m; while (m --) { int x1, y1, x2, y2; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2; insert(x1, y1, x2, y2, 1); //所加的数总为1 } for (int i = 1; i &lt;= n; i ++) { for (int j = 1; j &lt;= n; j ++) { S[i][j] = S[i - 1][j] + S[i][j - 1] - S[i - 1][j - 1] + a[i][j]; cout &lt;&lt; S[i][j] &lt;&lt; ' '; } puts(&quot;&quot;); } return 0; } 通过本题，我们可以发现差分与前缀和的一个用途：统计集合中某个元素的使用次数。 例如本题中：每块地被地毯覆盖一次就相当于该块地被使用了一次。求一块地被多少块地毯覆盖就是求该块地被使用了多少次。 ","link":"https://shaoyihao.github.io/blog/地毯/"},{"title":"差分","content":"一维差分 对于一个数列ana_nan​，总可以构造出数列bnb_nbn​，使得：ana_nan​是bnb_nbn​的前缀和。即：an=b1+b2+...+bna_n = b_1+b_2 +...+b_nan​=b1​+b2​+...+bn​ 此时bnb_nbn​称为ana_nan​的差分，可以理解为bnb_nbn​是ana_nan​的基础组成成分，因此对bnb_nbn​进行操作，可以对ana_nan​产生影响。 注意到： 若将 blb_lbl​ 加上 ccc，则从 ala_lal​ 起，al,al+1,al+2,...,ana_l, a_{l+1}, a_{l + 2}, ... , a_nal​,al+1​,al+2​,...,an​ 都会加上c 若将 brb_rbr​ 减去 ccc，则从 ara_rar​ 起，ar,ar+1,ar+2,...,ana_r, a_{r+1}, a_{r + 2}, ... , a_nar​,ar+1​,ar+2​,...,an​都会减去c 因此如果要实现将al∼ara_l\\sim a_ral​∼ar​之间的元素都加上c，可以先将blb_lbl​加上ccc，再将br+1b_{r+1}br+1​减去ccc，此时再对bnb_nbn​求一遍前缀和，即可得到操作后的ana_nan​数组。 差分数组的求法有两种考虑方式： 正向：初始化数组SSS时，对于SSS数组中的每一个数，考虑aaa数组应该如何变化才能达到效果。 起始时SnS_nSn​各项均为0，ana_nan​各项也均为0。则元素SiS_iSi​的初始化 也可理解为：将S[i∼i]S[i\\sim i]S[i∼i]中的每一个数（其实只有一个数）都加上要赋的SiS_iSi​的值。 根据之前的分析，这个操作等价于对差分数组的这般操作：将aia_iai​加上要赋的SiS_iSi​的值，将ai+1a_{i+1}ai+1​减去要赋的SiS_iSi​的值。 int a[N]; //初始化全为0 void insert(int l, int r, int c)//将l~r之间的元素均加上c { a[l] += c; a[r + 1] -= c; } for (int i = 1; i &lt;= n; i ++) insert(i, i, S[i]); const int N = 100010; int a[N], b[N];//初始值为0 void insert(int l, int r, int c)//将al~ar之间的元素均加上c { b[l] += c; b[r + 1] -= c; } int main() { int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;a[i]); for (int i = 1; i &lt;= n; i ++) insert(i, i, a[i]);//b[i]（差分）的求法 while (m --)//m次操作 { int l, r, c; scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;c); insert(l, r, c); } for (int i = 1; i &lt;= n; i ++) a[i] = a[i - 1] + b[i];//前缀和的求法 for (int i = 1; i &lt;= n; i ++) printf(&quot;%d &quot;, a[i]);//输出最终的前缀和数组 return 0; } 反向：由SSS数组 逆求 aaa数组：a1=S1−S0a2=S2−S1a3=S3−S2...an=Sn−Sn−1a_1 = S_1-S_0\\\\ a_2 = S_2 - S_1\\\\ a_3 = S_3 - S_2\\\\ ...\\\\ a_n = S_n - S_{n-1} a1​=S1​−S0​a2​=S2​−S1​a3​=S3​−S2​...an​=Sn​−Sn−1​ int a[N]; for (int i = 1; i &lt;= n; i ++) { cin &gt;&gt; S[i]; a[i] = S[i] - S[i - 1]; } const int N = 100010; int S[N], q[N]; int main() { int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i ++) { cin &gt;&gt; S[i]; q[i] = S[i] - S[i - 1]; } while (m --) { int l, r, c; cin &gt;&gt; l &gt;&gt; r &gt;&gt; c; q[l] += c; q[r + 1] -= c; } for (int i = 1; i &lt;= n; i ++) { S[i] = S[i - 1] + q[i]; cout &lt;&lt; S[i] &lt;&lt; ' '; } return 0; } 二维差分 #include &lt;iostream&gt; using namespace std; const int N = 1010; int a[N][N], b[N][N];//初始值为0 void insert(int x1, int y1, int x2, int y2, int c)//将矩阵从(x1,y1)到(x2,y2)间的元素均加上c { b[x1][y1] += c; b[x2 + 1][y1] -= c; b[x1][y2 + 1] -= c; b[x2 + 1][y2 + 1] += c; } int main() { int n, m, q; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;q); for (int i = 1; i &lt;= n; i ++) for (int j = 1; j &lt;= m; j ++) scanf(&quot;%d&quot;, &amp;a[i][j]); for (int i = 1; i &lt;= n; i ++) for (int j = 1; j &lt;= m; j ++) insert(i, j, i, j, a[i][j]);// b[n][m]（差分矩阵）的求法 while (q --)//q次操作 { int x1, y1, x2, y2, c; scanf(&quot;%d%d%d%d%d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2, &amp;c); insert(x1, y1, x2, y2, c);//将矩阵从(x1,y1)到(x2,y2)间的元素均加上c } for (int i = 1; i &lt;= n; i ++) for (int j = 1; j &lt;= m; j ++) a[i][j] = a[i][j - 1] + a[i - 1][j] - a[i - 1][j - 1] + b[i][j];//前缀和的求法 for (int i = 1; i &lt;= n; i ++) { for (int j = 1; j &lt;= m; j ++) printf(&quot;%d &quot;, a[i][j]); printf(&quot;\\n&quot;); } return 0; } 三维差分 一个立方体可以用其体对角线的端点坐标来描述：(x1,y1,z1),(x2,y2,z2)(x_1,y_1,z_1),(x_2,y_2,z_2)(x1​,y1​,z1​),(x2​,y2​,z2​)。 若要将立方体(x1,y1,z1)∼(x2,y2,z2)(x_1,y_1,z_1)\\sim (x_2,y_2,z_2)(x1​,y1​,z1​)∼(x2​,y2​,z2​)中的每一个位置都+c+c+c，方法为： void insert(int x1, int y1, int z1, int x2, int y2, int z2, int c) { a[x1][y1][z1] += c; a[x2 + 1][y1][z1] -= c; a[x1][y2 + 1][z1] -= c; a[x1][y1][z2 + 1] -= c; a[x2 + 1][y2 + 1][z1] += c; a[x2 + 1][y1][z2 + 1] += c; a[x1][y2 + 1][z2 + 1] += c; a[x2 + 1][y2 + 1][z2 + 1] -= c; } 注意规律。 ","link":"https://shaoyihao.github.io/blog/差分/"},{"title":"前缀和","content":"前缀和是一种优化手段，当需要频繁求部分连续元素之和时，应想到用前缀和进行优化。 一维前缀和 对于一个数列ana_nan​，要想求下标区间 [l,r][ l, r ][l,r] 内元素的和 al+al+1+...+ara_l + a_{l+1} +...+a_ral​+al+1​+...+ar​ 可以通过前n项和SnS_nSn​来快速计算： al+al+1+...+ar=Sr−Sl−1a_l + a_{l+1} +...+a_r = S_r - S_{l-1} al​+al+1​+...+ar​=Sr​−Sl−1​ 其中应注意 定义S0=0S_0=0S0​=0 ，使得a1+⋯+an=Sn−S0=Sna_1+\\cdots +a_n=S_n - S_0 = S_na1​+⋯+an​=Sn​−S0​=Sn​，使计算更统一。 const int N = 100010; int a[N], s[N];//定义在全局区的数组自动被初始化为0 int main() { int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i ++) { scanf(&quot;%d&quot;, &amp;a[i]); s[i] = s[i - 1] + a[i];//初始化an，紧随其后为Sn初始化 } /*另一种简便写法：直接得到前缀和数组 for (int i = 1; i &lt;= n; i ++) { cin &gt;&gt; s[i]; s[i] += s[i - 1]; } */ int l, r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); printf(&quot;%d\\n&quot;, s[r] - s[l - 1]);//一次查询即可求出结果 return 0; } 二维前缀和 对于一个矩阵，要想求子矩阵所有元素的和，也可以采用类似的思想。 关键即这两个公式： Si,j=Si,j−1+Si−1,j−Si−1,j−1+ai,jS′=Sx2,y2−Sx2,y1−1−Sx1−1,y2+Sx1−1,y1−1S_{i, j} = S_{i, j-1} + S_{i-1, j} - S_{i-1, j-1} + a_{i, j}\\\\ S&#x27;= S_{x_2, y_2} - S_{x_2, y_1-1} - S_{x_1-1, y2} + S_{x_1-1, y_1-1} Si,j​=Si,j−1​+Si−1,j​−Si−1,j−1​+ai,j​S′=Sx2​,y2​​−Sx2​,y1​−1​−Sx1​−1,y2​+Sx1​−1,y1​−1​ const int N = 1010; int a[N][N], s[N][N];//定义在全局区的数组自动被初始化为0 int main() { int n, m; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++) for (int j = 1; j &lt;= m; j ++) { scanf(&quot;%d&quot;, &amp;a[i][j]); s[i][j] = s[i][j - 1] + s[i - 1][j] - s[i - 1][j - 1] + a[i][j];//初始化a，紧随其后为S初始化 } int x1, y1, x2, y2; scanf(&quot;%d%d%d%d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2); printf(&quot;%d\\n&quot;, s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]);//一次查询即可求出结果 return 0; } 三维前缀和 S[x][y][z]=a[x][y][z]+S[x-1][y][z]+S[x][y-1][z]+S[x][y][z-1]\\\\\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ -S[x-1][y-1][z]-S[x-1][y][z-1]-S[x][y-1][z-1]\\\\ +S[x-1][y-1][z-1]\\ \\ \\ \\ \\ \\ 初始化：S[0][0][0]=0S[0][0][0]=0S[0][0][0]=0 ","link":"https://shaoyihao.github.io/blog/前缀和/"},{"title":"函数","content":"函数的概念 设数集D⊆RD\\subseteq RD⊆R，则称映射 f:D→Rf:D\\rightarrow Rf:D→R 为定义在 DDD 上的函数，记为： y=f(x), x∈Dy=f(x),\\ \\ \\ x\\in D y=f(x), x∈D DDD 称为定义域，记作 DfD_fDf​，即：Df=DD_f=DDf​=D 。 函数值f(x)f(x)f(x)的全体所构成的集合称为函数fff的值域，记作 RfR_fRf​ 或 f(D)f(D)f(D)，即： Rf=f(D)={y ∣ y=f(x),x∈D}R_f=f(D)=\\{y\\ |\\ y=f(x),x\\in D\\} Rf​=f(D)={y ∣ y=f(x),x∈D} 函数是一种特殊的映射：数集 →\\rightarrow→ 数集。 因变量 yyy 与自变量 xxx 之间的这种依赖关系，称为 函数关系。 至于自变量、因变量用什么字母表示，不影响函数本质。 函数的要素：定义域DfD_fDf​ 和 对应法则fff。 两个函数相同 当且仅当 这两个函数的定义域相同且对应法则也相同。 若一个函数没有显式给出定义域，则通常约定该函数的定义域就是使函数有意义的一切实数组成的集合，称其为函数的自然定义域。 函数的性质 有界性 设 XXX 是函数 fff 定义域的某子集， 若 ∃K1\\exist K_1∃K1​，使得 ∀x∈X\\forall x\\in X∀x∈X，都有 f(x)≤K1f(x)\\le K_1f(x)≤K1​，则称 fff在XXX上有上界，K1K_1K1​是fff在XXX上的一个上界。 若 ∃K2\\exist K_2∃K2​，使得 ∀x∈X\\forall x\\in X∀x∈X，都有 f(x)≥K2f(x)\\ge K_2f(x)≥K2​，则称 fff在XXX上有下界，K2K_2K2​是fff在XXX上的一个下界。 若 ∃M&gt;0\\exist M &gt;0∃M&gt;0，使得 ∀x∈X\\forall x\\in X∀x∈X，都有 ∣f(x)∣≤M|f(x)|\\le M∣f(x)∣≤M，则称 fff在XXX上有界。 若这样的 MMM 不存在，则称 fff在XXX上 无界。即：∀M&gt;0\\forall M&gt;0∀M&gt;0，∃x0∈X\\exist x_0\\in X∃x0​∈X，使 ∣f(x0)∣&gt;M|f(x_0)|&gt;M∣f(x0​)∣&gt;M。 有界 ⟺\\Longleftrightarrow⟺ 既有上界，又有下界。 有界函数的上界、下界有无穷多个，但上确界、下确界是唯一的。 例1：证明f(x)=sin⁡80x−6cos⁡602xf(x)=\\sin^{80}x-6\\cos^{60}2xf(x)=sin80x−6cos602x有界。 例2：证明f(x)=x1+x2sin⁡xf(x)=\\frac{x}{1+x^2}\\sin xf(x)=1+x2x​sinx有界。 例3：证明f(x)=1xf(x)=\\frac{1}{\\sqrt{x}}f(x)=x​1​在(0,1](0,1](0,1]上无界。 分析法：若满足&quot;A⇒BA\\Rightarrow BA⇒B&quot;，则要证BBB成立，只要证AAA成立。 单调性 对于区间 I⊆DI\\subseteq DI⊆D 上的2点 x1,x2x_1,x_2x1​,x2​，若 x1&lt;x2x_1&lt;x_2x1​&lt;x2​，恒有 f(x1)&lt;f(x2)f(x_1)&lt;f(x_2)f(x1​)&lt;f(x2​)，则称 f(x)f(x)f(x) 在 III 上是单调增加的。 周期性 并非每个周期函数都有最小正周期。（狄利克雷函数） 奇偶性 奇函数：f(−x)=−f(x)f(-x)=-f(x)f(−x)=−f(x)，图像关于 原点 对称。 偶函数：f(−x)=f(x)f(-x)=f(x)f(−x)=f(x)，图像关于 yyy轴 对称。 偶函数 + 偶函数 = 偶函数；奇函数 + 奇函数 = 奇函数 偶函数 × 偶函数 = 偶函数；奇函数 × 奇函数 = 偶函数；偶函数 × 奇函数 = 奇函数 y=ax+a−xy=a^x+a^{-x}y=ax+a−x 是偶函数；y=ax−a−xy=a^x-a^{-x}y=ax−a−x 是奇函数。 若函数 f(x)f(x)f(x) 的定义域为 (−l,l)(-l,l)(−l,l)，则必存在(−l,l)(-l,l)(−l,l)上的偶函数g(x)g(x)g(x)和奇函数h(x)h(x)h(x)，使得：g(x)+h(x)=f(x)g(x)+h(x)=f(x)g(x)+h(x)=f(x) 。 证明： 设 f(x)f(x)f(x) 为定义在 (−l,l)(-l,l)(−l,l) 上的奇函数，若f(x)f(x)f(x)在(0,l)(0,l)(0,l)内单调递增，则f(x)f(x)f(x)在(−l,0)(-l,0)(−l,0)内也单调递增。 证明：任取 x1,x2x_1,x_2x1​,x2​ 满足 −l&lt;x1&lt;x2&lt;0-l&lt;x_1&lt;x_2&lt;0−l&lt;x1​&lt;x2​&lt;0，则 0&lt;−x2&lt;−x1&lt;l0&lt;-x_2&lt;-x_1&lt;l0&lt;−x2​&lt;−x1​&lt;l。又因为 f(x)f(x)f(x) 在(0,l)(0,l)(0,l)内单调递增，所以 f(−x2)&lt;f(−x1)f(-x_2)&lt;f(-x_1)f(−x2​)&lt;f(−x1​)。又因为f(x)f(x)f(x)是奇函数，所以 f(x2)−f(x1)=−f(−x2)+f(−x1)&gt;0f(x_2)-f(x_1)=-f(-x_2)+f(-x_1) &gt;0f(x2​)−f(x1​)=−f(−x2​)+f(−x1​)&gt;0，因此f(x)f(x)f(x)在(−l,0)(-l,0)(−l,0)内也单调递增。 一些特殊函数 符号函数 y=sgn x={−1,x&lt;00,x=01,x&gt;0y=sgn\\ x=\\left\\{\\begin{matrix} -1,&amp;x&lt;0 \\\\0,&amp;x=0\\\\1,&amp;x&gt;0 \\end{matrix}\\right. y=sgn x=⎩⎨⎧​−1,0,1,​x&lt;0x=0x&gt;0​ 性质：x=sgn x⋅∣x∣x=sgn\\ x\\cdot |x|x=sgn x⋅∣x∣ 取整函数 y=[x], x∈Ry=[x],\\ x\\in Ry=[x], x∈R 称为取整函数，[x][x][x]表示不超过xxx的最大整数，即：x−1&lt;[x]≤xx-1&lt;[x]\\le xx−1&lt;[x]≤x。 推论：[x]≤x&lt;[x]+1[x]\\le x&lt;[x] + 1[x]≤x&lt;[x]+1。 狄利克雷函数 D(x)={1, x是有理数0, x是无理数D(x)=\\left\\{\\begin{matrix} 1,\\ \\ \\ \\ x是有理数 \\\\ 0,\\ \\ \\ \\ x是无理数 \\end{matrix}\\right. D(x)={1, x是有理数0, x是无理数​ 特点：是周期函数，但不存在最小正周期（任何正有理数都是它的周期）。 幂指函数 已知 u(x)&gt;0u(x)&gt;0u(x)&gt;0，则 y=u(x)v(x)=eln⁡u(x)v(x)=ev(x)ln⁡u(x)y=u(x)^{v(x)}=e^{\\ln u(x)^{v(x)}}=e^{v(x)\\ln u(x)}y=u(x)v(x)=elnu(x)v(x)=ev(x)lnu(x) 若A&gt;0A&gt;0A&gt;0，则A=alog⁡aA (a&gt;0且a≠1)A=a^{\\log_aA}\\ \\ (a&gt;0且a\\ne 1)A=aloga​A (a&gt;0且a​=1)。特别的，a=ea=ea=e时，A=eln⁡AA=e^{\\ln A}A=elnA。 反函数 定义：设函数 f:D→f(D)f:D\\rightarrow f(D)f:D→f(D) 是单射，则称逆映射 f(D)→Df(D)\\rightarrow Df(D)→D 为函数fff的反函数。（将原函数称为 直接函数。） 只有单射函数才有反函数。单射函数中自变量xxx与因变量yyy之间是一种一一对应的关系，从而值域中的任意一个yyy都唯一对应着一个xxx，这便形成了一个新的函数，即反函数。 fff 和 f−1f^{-1}f−1 描述的是2个不同的函数。（f−1f^{-1}f−1只是一个记号） 原函数的值域即反函数的定义域，反函数的值域即原函数的定义域。 性质：f(f−1(y))=yf(f^{-1}(y))=yf(f−1(y))=y f−1(f(x))=xf^{-1}(f(x))=xf−1(f(x))=x （从映射角度理解） 注意：y=f(x)y=f(x)y=f(x)与x=f−1(y)x=f^{-1}(y)x=f−1(y)描述的是同一个曲线；y=f(x)y=f(x)y=f(x)与y=f−1(x)y=f^{-1}(x)y=f−1(x)的图像关于y=xy=xy=x对称 。 证明：若 P(a,b)P(a, b)P(a,b) 是 y=f(x)y=f(x)y=f(x) 图像上的点，则有：b=f(a)b=f(a)b=f(a)。由反函数的定义有：a=f−1(b)a=f^{-1}(b)a=f−1(b)，因此 Q(b,a)Q(b,a)Q(b,a) 是 y=f−1(x)y=f^{-1}(x)y=f−1(x) 图像上的点。反之同理，若 Q(b,a)Q(b,a)Q(b,a) 是 y=f−1(x)y=f^{-1}(x)y=f−1(x) 图像上的点，则 P(a,b)P(a, b)P(a,b) 是 y=f(x)y=f(x)y=f(x) 图像上的点。而 P(a,b)P(a,b)P(a,b) 和 Q(b,a)Q(b,a)Q(b,a) 是关于直线y=xy=xy=x对称的。 对于反函数的理解应基于集合间的映射，fff与f−1f^{-1}f−1表示的是两个互逆的映射（对应关系）。若定义域相同，由于对应关系不同，因此生成的函数也不同。 单调函数一定是单射，因此单调函数一定有反函数，且反函数也是单调函数。事实上，单调递增（递减）函数的反函数也单调递增（递减）。 证明： 若 fff 是定义在 DDD 上的单调递增函数，任取 y1,y2∈f(D)y_1,y_2\\in f(D)y1​,y2​∈f(D)，且 y1&lt;y2y_1&lt;y_2y1​&lt;y2​，则在 DDD 内存在唯一的 x1,x2x_1,x_2x1​,x2​ 使得 f(x1)=y1f(x_1)=y_1f(x1​)=y1​，f(x2)=y2f(x_2)=y_2f(x2​)=y2​ 。因此 f−1(y1)=x1f^{-1}(y_1)=x_1f−1(y1​)=x1​，f−1(y2)=x2f^{-1}(y_2)=x_2f−1(y2​)=x2​ 。 若 x1&gt;x2x_1&gt;x_2x1​&gt;x2​，则 y1&gt;y2y_1&gt;y_2y1​&gt;y2​；若 x1=x2x_1=x_2x1​=x2​，则 y1=y2y_1=y_2y1​=y2​。上述2种情况都与假设的y1&lt;y2y_1&lt;y_2y1​&lt;y2​不符，因此一定是 x1&lt;x2x_1&lt;x_2x1​&lt;x2​，即 f−1(y1)&lt;f−1(y2)f^{-1}(y_1)&lt;f^{-1}(y_2)f−1(y1​)&lt;f−1(y2​)，这就证明了 f−1f^{-1}f−1 在 f(D)f(D)f(D) 上是单调递增的。 （从几何角度看，关于 y=xy=xy=x 对称的2个函数图像 的单调性相同。） 反之，具有反函数的函数不一定单调。例如：y=1xy=\\frac{1}{x}y=x1​具有反函数，但并非单调函数。一些由离散点构成的函数也具有反函数，但却不一定具有单调性。 y=1−x1+xy=\\frac{1-x}{1+x}y=1+x1−x​ 的反函数为：y=1−x1+xy=\\frac{1-x}{1+x}y=1+x1−x​ 。 复合函数 定义：设y=f(u),u∈Dfy=f(u),u\\in D_fy=f(u),u∈Df​，w=φ(x),x∈Dφw=\\varphi(x),x\\in D_{\\varphi}w=φ(x),x∈Dφ​，若Rφ⊆DfR_{\\varphi}\\subseteq D_fRφ​⊆Df​，则由下式确定的函数： y=f(φ(x)), x∈Dφy=f(\\varphi(x)),\\ \\ \\ x\\in \\textcolor{#F00}{D_{\\varphi}} y=f(φ(x)), x∈Dφ​ 称为由 φ\\varphiφ 和 fff 构成的复合函数 （先 φ\\varphiφ 后 fff ），记为 f∘φf\\circ \\varphif∘φ，即： f∘φ (x)=f(φ(x))f\\circ\\varphi\\ \\ (x)=f(\\varphi(x)) f∘φ (x)=f(φ(x)) φ\\varphiφ 和 fff 能构成复合函数 的条件：Rφ⊆DfR_{\\varphi}\\subseteq D_fRφ​⊆Df​ ，否则不能构成。 基本初等函数 三角函数 余切函数：y=cot⁡x=1tan⁡x, x≠kπ,k∈Zy=\\cot x=\\frac{1}{\\tan x},\\ x\\ne k\\pi,k\\in Zy=cotx=tanx1​, x​=kπ,k∈Z 正割函数：y=sec⁡x=1cos⁡x, x≠kπ+π2y=\\sec x=\\frac{1}{\\cos x},\\ x\\ne k\\pi +\\frac{\\pi}{2}y=secx=cosx1​, x​=kπ+2π​ 余割函数：y=csc⁡x=1sin⁡x, x≠kπy=\\csc x=\\frac{1}{\\sin x}, \\ x\\ne k\\piy=cscx=sinx1​, x​=kπ 常用公式： 1+tan⁡2x=1cos⁡2x=sec⁡2x 1+cot⁡2x=1sin⁡2x=csc⁡2x1+\\tan^2x=\\frac{1}{\\cos^2x}=\\sec^2x\\\\\\ \\\\ 1+\\cot^2x=\\frac{1}{\\sin^2x}=\\csc^2x 1+tan2x=cos2x1​=sec2x 1+cot2x=sin2x1​=csc2x 反三角函数 反正弦 函数y=sin⁡x, x∈Ry=\\sin x,\\ x\\in Ry=sinx, x∈R不是单射函数，因此不存在反函数；但y=sin⁡x, x∈[−π2,π2]y=\\sin x,\\ x\\in[-\\frac{\\pi}{2},\\frac{\\pi}{2}]y=sinx, x∈[−2π​,2π​]上是单射函数，因此该函数具有反函数，记为：y=arcsin⁡xy=\\arcsin xy=arcsinx，定义域为[−1,1][-1,1][−1,1]，值域为[−π2,π2][-\\frac{\\pi}{2},\\frac{\\pi}{2}][−2π​,2π​]。 反余弦 y=cos⁡x,x∈[0,π]y=\\cos x, x\\in[0,\\pi]y=cosx,x∈[0,π]的反函数记为：y=arccos⁡xy=\\arccos xy=arccosx，定义域为[−1,1][-1,1][−1,1]，值域为[0,π][0,\\pi][0,π]。 反正切 y=tan⁡x, x∈(−π2,π2)y=\\tan x,\\ x\\in(-\\frac{\\pi}{2},\\frac{\\pi}{2})y=tanx, x∈(−2π​,2π​)的反函数记为：y=arctan⁡xy=\\arctan xy=arctanx，定义域为RRR，值域为(−π2,π2)(-\\frac{\\pi}{2},\\frac{\\pi}{2})(−2π​,2π​)。 5种基本初等函数：指数函数、对数函数、幂函数（包含常数函数）、三角函数、反三角函数。 初等函数：由基本初等函数经过有限次四则运算或复合得到 并 可用一个式子表示的函数。（一般情况下，分段函数是非初等函数。） 某些分段函数可以由函数复合得到，譬如绝对值函数y=∣x∣=x2y=|x|=\\sqrt{x^2}y=∣x∣=x2​，可以由y1=u和y2=x2y_1=\\sqrt{u}和y_2=x^2y1​=u​和y2​=x2复合得到。 ","link":"https://shaoyihao.github.io/blog/函数/"},{"title":"2的n次幂的位数","content":"2n=(10log⁡102)n=10nlog⁡1022^n=(10^{\\log_{10}2})^n=10^{n\\log_{10}2} 2n=(10log10​2)n=10nlog10​2 由于 10k10^k10k 的位数为 ⌊k⌋+1\\lfloor k\\rfloor + 1⌊k⌋+1，因此 2n2^n2n 的位数为：⌊nlog⁡102⌋+1\\lfloor n\\log_{10}2\\rfloor + 1⌊nlog10​2⌋+1 。 cout &lt;&lt; (int)log10(2) * n + 1; 2n−12^n-12n−1 与 2n2^n2n 的位数相同，因为 2n2^n2n（n&gt;0n&gt;0n&gt;0） 的个位只可能是2,4,6,8，总足够减一。 ","link":"https://shaoyihao.github.io/blog/2的n次幂的位数/"},{"title":"快速幂","content":" 原题链接：快速幂 计算：abmod pa^b\\mod pabmodp 。 关于取模运算 在程序设计竞赛中，通常都需要对结果取模。为什么不让你直接输出结果呢？难道仅仅只是为了增大题目的难度吗？当然不是。 原因是：结果可能会非常的大，大到没有任何类型可以承载。 可是既然最终结果都无法得出，又如何求出结果的模呢？ 这需要借助取模的运算法则： (a+b) % p=(a % p+b % p) % p(a−b) % p=(a % p−b % p) % p(a×b) % p=(a % p×b % p) % p(a + b)\\ \\%\\ p = (a\\ \\%\\ p + b\\ \\%\\ p)\\ \\% \\ p\\\\(a - b)\\ \\%\\ p = (a\\ \\%\\ p - b\\ \\%\\ p)\\ \\% \\ p\\\\(a \\times b)\\ \\%\\ p = (a\\ \\%\\ p \\times b\\ \\%\\ p)\\ \\% \\ p (a+b) % p=(a % p+b % p) % p(a−b) % p=(a % p−b % p) % p(a×b) % p=(a % p×b % p) % p 可见，我们只需要在运算过程中不断进行取模，就可以使得最终结果与先计算再取模的结果相同。 求akmod pa^k\\mod pakmodp，朴素写法 O(k)O(k)O(k)： int res = 1; for (int i = 1; i &lt;= k; i ++) res = res * a % p; 快速幂 快速幂算法可以以 O(log⁡k)O(\\log k)O(logk) 快速地求出 akmod pa^k\\mod pakmodp 算法思想：分治 ak={1k=0ak=1(ak2)2k为偶数ak−1⋅ak为奇数a^k=\\left\\{\\begin{matrix} 1 &amp; k=0\\\\ a&amp;k=1\\\\(a^{\\frac{k}{2}})^2 &amp; k为偶数\\\\a^{k-1} \\cdot a&amp;k为奇数\\end{matrix}\\right. ak=⎩⎪⎪⎨⎪⎪⎧​1a(a2k​)2ak−1⋅a​k=0k=1k为偶数k为奇数​ 容易通过递归实现： int qmi(int a, int k, int p) { if (k == 0) return 1; else if (k == 1) return a; else if (k % 2 == 0) { int t = qmi(a, k / 2, p); return (LL) t * t % p; } else if (k % 2 == 1) return (LL) qmi(a, k - 1, p) * a % p; } 另一种写法 预处理得出 a2i %p,(0≤i≤log⁡k)a^{2^i}\\ \\% p,(0\\le i\\le \\log k)a2i %p,(0≤i≤logk)，至多需要log⁡k\\log klogk个值。 如何进行预处理？——根据递推关系：a20=a, a2i=a2i−1×2=(a2i−1)2a^{2^0}=a,\\ a^{2^i}=a^{2^{i-1}\\times 2}=(a^{2^{i-1}})^2a20=a, a2i=a2i−1×2=(a2i−1)2 （实际上即数列：a,a2,a4,...,aka, a^2,a^4,...,a^{k}a,a2,a4,...,ak） 由这些数如何得出 ak%pa^k \\% pak%p 呢？ 找出x1,x2,...,xtx_1,x_2,...,x_tx1​,x2​,...,xt​，使得k=2x1+2x2+...+2xtk=2^{x_1}+2^{x_2}+...+2^{x_t}k=2x1​+2x2​+...+2xt​，从而ak=a2x1⋅a2x2⋅...⋅a2xta^k=a^{2^{x_1}}·a^{2^{x_2}}·...·a^{2^{x_t}}ak=a2x1​⋅a2x2​⋅...⋅a2xt​。 即：将aka^kak拆分为a2x1,a2x2,...,a2xta^{2^{x_1}},a^{2^{x_2}},...,a^{2^{x_t}}a2x1​,a2x2​,...,a2xt​的乘积。（算法核心） 例如：95=922⋅920=94⋅919^5=9^{2^2}·9^{2^0}=9^4·9^195=922⋅920=94⋅91 如何找出满足条件的x1,x2,...,xtx_1,x_2,...,x_tx1​,x2​,...,xt​呢？——将kkk转为二进制即可。 例如：k=(110110)2=21+22+24+25k=(110110)_2=2^1+2^2+2^4+2^5k=(110110)2​=21+22+24+25. 因此：a54=a2⋅a4⋅a16⋅a32a^{54}=a^2\\cdot a^4\\cdot a^{16}\\cdot a^{32}a54=a2⋅a4⋅a16⋅a32 算法过程就是：aaa要不要乘入答案，a2a^2a2要不要，a4a^4a4要不要，a8a^8a8要不要，...... int qmi(int a, int k, int p) { int res = 1; while (k) { if (k &amp; 1) res = (LL) res * a % p; k &gt;&gt;= 1; a = (LL) a * a % p; //a不断进行着平方操作 } return res; } 高精度快速幂 求 aka^kak 的低 ppp 位。 vector&lt;int&gt; qmi(vector&lt;int&gt; a, int k, int p) { vector&lt;int&gt; res = vector&lt;int&gt;(1, 1); while (k) { if (k &amp; 1) { res = mul(res, a); if (res.size() &gt; p) res.erase(res.begin() + p, res.end()); //高于p位的，全部截除 } k &gt;&gt;= 1; a = mul(a, a); if (a.size() &gt; p) a.erase(a.begin() + p, a.end()); //高于p位的，全部截除 } return res; } 应用：快速幂求逆元 逆元： 若aaa被bbb整除，且存在xxx满足：ab≡a⋅x (mod m)\\frac{a}{b}\\equiv a·x \\ \\ (\\mod m)ba​≡a⋅x (modm)，即：(ab) % m=(a⋅x) % m(\\frac{a}{b})\\ \\% \\ m=(a·x)\\ \\%\\ m(ba​) % m=(a⋅x) % m，则称xxx为bbb的逆元。（bbb与mmm互质）。 性质：b⋅x≡1 (mod m)b·x\\equiv 1\\ \\ (\\mod m)b⋅x≡1 (modm)。 因此，求数bbb的逆元，就是找到一个xxx，使得bxbxbx除以mmm的余数为1. 注意：若bbb是mmm的倍数，则bbb不存在逆元. 特别的，若mmm为质数，根据费马定理：bm−1≡1 (mod m)b^{m-1}\\equiv 1\\ \\ (\\mod m)bm−1≡1 (modm)，有 b⋅bm−2≡1 (mod m)b·b^{m-2}\\equiv 1\\ \\ (\\mod m) b⋅bm−2≡1 (modm) 因此此时 bbb 的逆元为 bm−2b^{m-2}bm−2 。 注意：只有当模数mmm为质数时，才能用快速幂求逆元！ 否则只能用扩展欧几里得算法求逆元。 int a, p; cin &gt;&gt; a &gt;&gt; p; int res = qmi(a, p - 2, p); if (a % p == 0) puts(&quot;impossible&quot;); //a是p的倍数，a不存在逆元 else cout &lt;&lt; res &lt;&lt; endl; 当我们已知一个数bbb的逆元b−1b^{-1}b−1时，我们在求 ab %p\\frac{a}{b}\\ \\%pba​ %p时，就可以转化为算 ab−1 %pab^{-1} \\ \\% pab−1 %p. 例如：在模7的情况下，63 % 7=2\\frac{6}{3}\\ \\%\\ 7=236​ % 7=2，3的逆元为555，6×3−1=6×5=306\\times 3^{-1}=6\\times 5=306×3−1=6×5=30，30 % 7=230\\ \\%\\ 7=230 % 7=2。 事实上，当最终答案是取模后的结果时，若计算过程中存在除法，必须转化为乘以逆元。（注意是整除！）原因是：【ab % p≠a % pb % p % p\\frac{a}{b}\\ \\%\\ p \\neq \\frac{a\\ \\%\\ p}{b\\ \\%\\ p}\\ \\%\\ pba​ % p​=b % pa % p​ % p】。 逆元的性质：若aaa的逆元为a−1a^{-1}a−1，bbb的逆元为b−1b^{-1}b−1，则ababab的逆元为a−1b−1a^{-1}b^{-1}a−1b−1。 ","link":"https://shaoyihao.github.io/blog/快速幂/"},{"title":"最大乘积","content":" 原题链接：最大乘积 题目大意：将正整数 nnn（n≥2n\\ge 2n≥2）分解成若干个互不相同的自然数的和，且使这些自然数的乘积最大。 背景知识：整数划分 设 SSS 为最佳拆分方案，其中最小元为aaa，最大元为bbb，则有以下几个事实： a&gt;1a&gt;1a&gt;1。 若a=1a=1a=1，则把111和bbb去掉，替换为b+1b+1b+1，总和不变，而乘积变大，和“SSS是最佳方案”相矛盾。 a&lt;5a&lt; 5a&lt;5。 若a≥5a\\ge 5a≥5，则aaa可以继续拆分【a=2+(a−2)a=2+(a-2)a=2+(a−2)】，乘积可以更大，矛盾。 (a,b)(a,b)(a,b) 范围内的正整数至多有一个不在SSS中。 若(a,b)(a,b)(a,b) 范围内存在多个正整数不在SSS中，假设∃x,y∈(a,b)\\exist x,y\\in(a,b)∃x,y∈(a,b)且均∉S\\notin S∈/​S。不妨设x&lt;yx&lt;yx&lt;y。设 ppp 为 SSS 中最大的&lt;x&lt;x&lt;x的正整数（可得 p+1∉Sp+1\\notin Sp+1∈/​S），qqq 为 SSS 中最小的&gt;y&gt;y&gt;y的正整数（可得 q−1∉Sq-1\\notin Sq−1∈/​S），有：q&gt;y&gt;x&gt;pq&gt;y&gt;x&gt;pq&gt;y&gt;x&gt;p，因此 q−p≥3q-p\\ge 3q−p≥3，则： (p+1)(q−1)=pq+q−p−1≥pq+2&gt;pq(p+1)(q-1)=pq+q-p-1\\ge pq+2&gt;pq (p+1)(q−1)=pq+q−p−1≥pq+2&gt;pq 因此将 p,qp,qp,q 换成 p+1,q−1p+1,q-1p+1,q−1 可以使乘积更大，矛盾。 a=4 ⟺ a=b=n=4a=4\\ \\Longleftrightarrow\\ a=b=n=4a=4 ⟺ a=b=n=4。 a=4a=4a=4 时，则一定有 5∉S5\\notin S5∈/​S，因为将 555 换成 2+32+32+3，可以使乘积更大，矛盾。也一定有 6∉S6\\notin S6∈/​S，因为将 4+64+64+6 换成 2+3+52+3+52+3+5 可以使总乘积增大，矛盾。而若 b≥7b\\ge 7b≥7，则根据第三点可得 5,65,65,6至少有一个在SSS中，产生矛盾。 因此 b=4b=4b=4。 综上分析，若 n=1,2,3,4n=1,2,3,4n=1,2,3,4，则 S={n}S=\\{n\\}S={n} 。 当n≥5n\\ge 5n≥5时：a=2a=2a=2或333 。 若a=3a=3a=3，根据第三点可得2种情况： 第一种情况：(a,b)(a,b)(a,b)范围内所有元素都在SSS中：S={3,4,…,b}\\textcolor{#F00}{S=\\{3,4,…,b\\}}S={3,4,…,b}，此时 n=(1+b)b2−3n=\\frac{(1+b)b}{2}-3n=2(1+b)b​−3 。 第二种情况，(a,b)(a,b)(a,b)范围内存在一个元素xxx（x≥4x\\ge 4x≥4）不在SSS中：S={3,…,x−1,x+1,…,b}S=\\{3,…,x-1,x+1,…,b\\}S={3,…,x−1,x+1,…,b}，n=(1+b)b2−3−xn=\\frac{(1+b)b}{2}-3-xn=2(1+b)b​−3−x。 下面证明x=b−1x=b-1x=b−1：若x+2≤bx+2\\le bx+2≤b，又因为x+2≥6x+2\\ge 6x+2≥6，则可以将x+2x+2x+2拆成xxx和222（二者均不在SSS中），总乘积会增大，矛盾。因此x+2&gt;bx+2&gt;bx+2&gt;b，又x+1≤bx+1\\le bx+1≤b，可得 x+1=b, x=b−1x+1=b,\\ \\ x=b-1x+1=b, x=b−1。 因此 S={3,…,b−2,b}\\textcolor{#F00}{S=\\{3,…,b-2,b\\}}S={3,…,b−2,b}，n=(1+b)b2−b−2n=\\frac{(1+b)b}{2}-b-2n=2(1+b)b​−b−2 。 若a=2a=2a=2，同理也有2种情况： S={2,…,b}\\textcolor{#F00}{S=\\{2,…,b\\}}S={2,…,b}，此时 n=(1+b)b2−1n=\\frac{(1+b)b}{2}-1n=2(1+b)b​−1 。 S={2,…,x−1,x+1,…,b}\\textcolor{#F00}{S=\\{2,…,x-1,x+1,…,b\\}}S={2,…,x−1,x+1,…,b}，此时 n=(1+b)b2−1−xn=\\frac{(1+b)b}{2}-1-xn=2(1+b)b​−1−x, (2&lt;x&lt;b)(2&lt;x&lt;b)(2&lt;x&lt;b)。 对于 nnn（n≥5n\\ge 5n≥5） ，其最佳拆分方案一定是上述4种形式之一。因为上述集合 SSS 和 元素和nnn 之间是一种 一一映射，因此当 nnn 确定时，其对应的集合形式 SSS 是唯一的。所以我们只需知道 nnn 是由哪种算式计算而来，便可得出其最佳拆分方案。 假设 ttt 满足： 2+⋯+t≤n&lt;2+⋯t+(t+1)2+\\cdots+t\\le n&lt;2+\\cdots t+(t+1) 2+⋯+t≤n&lt;2+⋯t+(t+1) 令 k=n−∑i=2tik=n-\\sum\\limits_{i=2}^tik=n−i=2∑t​i，则 0≤k≤t0≤k≤t0≤k≤t。 若 k=tk=tk=t，即：n=2+⋯+t+t=3+⋯+t+(t+2)n=2+\\cdots+t+t=3+\\cdots+t+(t+2)n=2+⋯+t+t=3+⋯+t+(t+2)，则 S={3,4,…,t,t+2}S=\\{3,4,…,t,t+2\\}S={3,4,…,t,t+2} 若 k=t−1k=t-1k=t−1，即：n=2+⋯+t+(t−1)=3+⋯+t+(t+1)n=2+\\cdots+t+(t-1)=3+\\cdots+t+(t+1)n=2+⋯+t+(t−1)=3+⋯+t+(t+1)，则 S={3,4,…,t+1}S=\\{3,4,…,t+1\\}S={3,4,…,t+1} 若 k=0k=0k=0，即：n=2+⋯+tn=2+\\cdots+tn=2+⋯+t，则 S={2,…,t}S=\\{2,…,t\\}S={2,…,t} 若 1≤k≤t−21\\le k\\le t-21≤k≤t−2，即：n=2+⋯+t+k=2+⋯+(t−k)+(t−k+2)+⋯+(t+1)n=2+\\cdots+t+k=2+\\cdots+(t-k)+(t-k+2)+\\cdots+(t+1)n=2+⋯+t+k=2+⋯+(t−k)+(t−k+2)+⋯+(t+1)，则 S={2,…,t−k,t−k+2,…,t+1}S=\\{2,…,t-k,t-k+2,…,t+1\\}S={2,…,t−k,t−k+2,…,t+1} #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; const int N = 10010; bool st[N]; // st[i]=true表示最佳划分方案中含有该和数 int main() { int n; cin &gt;&gt; n; int t = 2, sum = 0; while (1) { st[t] = true; sum += t; if (sum + t + 1 &gt; n) break; t ++; } //此时 sum = 2+...+t ≤ n &lt; 2+...+t+t+1 //微调最佳方案 int k = n - sum; if (k == t) st[2] = false, st[t + 2] = true; else if (k == t - 1) st[2] = false, st[t + 1] = true; else if (1 &lt;= k &amp;&amp; k &lt;= t - 2) st[t - k + 1] = false, st[t + 1] = true; //求最佳方案的乘积（高精度） vector&lt;int&gt; res; bool first = true; for (int i = 1; i &lt;= n; i ++) { // if (st[i] == true) cout &lt;&lt; i &lt;&lt; ' '; 输出最佳方案 if (st[i] == true &amp;&amp; first) { res = vector&lt;int&gt;(1, i); first = false; } else if (st[i] == true) res = mul(res, i); } //puts(&quot;&quot;); //for (int i = res.size() - 1; i &gt;= 0; i --) cout &lt;&lt; res[i]; return 0; } 更简单的写法： int sum = 0; for (int x = 2; sum &lt;= n; x ++) { st[x] = true; sum += x; } // sum = 2+...+t+t+1 &gt; n st[sum - n] = false; //最佳方案： n = 2 + 3 + ... + sum-n-1 + sum-n+1 + ... + t + t+1 ","link":"https://shaoyihao.github.io/blog/最大乘积/"},{"title":"整数划分","content":" 原题链接：整数划分 题目大意：将正整数 nnn 分解成若干个自然数的和，且使这些自然数的乘积最大。 把一个数拆成若干个自然数之后，如果要使这些自然数的乘积最大，那么这些自然数应该全是222或者333，且222最多不超过两个。 证明：对于任意正整数 nnn，若将其分为2个数的和：n−xn-xn−x 和 xxx，则： (n−x)x=−(x−n2)2+n24≤n24 (等号成立⇔x=n2)(n-x)x=-(x-\\frac{n}{2})^2+\\frac{n^2}{4}\\le \\frac{n^2}{4}\\ \\ \\ (等号成立\\Leftrightarrow x=\\frac{n}{2}) (n−x)x=−(x−2n​)2+4n2​≤4n2​ (等号成立⇔x=2n​) 由于要拆分为自然数，我们便得出了获得最大乘积的拆分方案： 当 nnn 是偶数时，将其拆分为 n2+n2\\frac{n}{2}+\\frac{n}{2}2n​+2n​，乘积最大。 当 nnn 时奇数时，将其拆分为 n+12+n−12\\frac{n+1}{2} + \\frac{n-1}{2}2n+1​+2n−1​，乘积最大。 如果要想使一个数拆分后的最大乘积会大于该数本身，则应满足： {n2⋅n2&gt;n , n为偶数n+12⋅n−12&gt;n , n为奇数 ⟹ n≥5\\left\\{\\begin{matrix} \\frac{n}{2}\\cdot\\frac{n}{2}&gt; n\\ \\ ,\\ \\ \\ \\ \\ \\ \\ n为偶数 \\\\ \\frac{n+1}{2}\\cdot \\frac{n-1}{2}&gt; n\\ ,\\ \\ n为奇数\\end{matrix}\\right.\\ \\Longrightarrow\\ n\\ge 5 {2n​⋅2n​&gt;n , n为偶数2n+1​⋅2n−1​&gt;n , n为奇数​ ⟹ n≥5 也就是说，对于 1,2,3,41,2,3,41,2,3,4 都没必要拆，拆了所得的乘积甚至会更小；只有对≥5\\ge 5≥5的数进行拆分，所得的最大乘积会大于该数本身。 因此对于任意正整数 nnn，若其拆出的和数中含有x≥5x\\ge 5x≥5，必定可以将xxx再进行拆分，从而使总乘积更大。即：若一个数的拆分方案中含有≥5\\ge 5≥5的和数，则所得乘积一定不是最大的。 特别的，注意到：对444进行拆分不会使乘积小于它本身，因此为了简化问题，我们对 444 也进行拆分。如此最终所拆出的所有和数只有：222或333。 不可能拆出 111，因为拆到 222 和 333 不拆的话，不可能出现 111 。 对于正整数nnn，它的最佳拆分方案一定只由2,32,32,3构成，但是由2,32,32,3构成的拆分方案不一定就是最佳拆分方案，因为：2×2×2&lt;3×32\\times 2\\times 2&lt;3\\times 32×2×2&lt;3×3。 最佳拆分方案⟸⟹由2,3构成最佳拆分方案\\stackrel{\\Longrightarrow}{\\not\\Longleftarrow} 由2,3构成 最佳拆分方案​⟸⟹​由2,3构成 因此对于所得的“ppp个222和qqq个333”的拆分方案，对于出现的ppp个222，按照3个3个的方式转换成⌊2p3⌋\\lfloor\\frac{2p}{3}\\rfloor⌊32p​⌋个333。此时方案中最多剩余两个222，其余的都是333。这就是乘积最大的拆分方案。 综上，我们的策略就是，对于正整数 nnn，先求出它能拆出多少个 333 ：⌊n3⌋\\lfloor\\frac{n}{3}\\rfloor⌊3n​⌋， 若余数为2，则最佳方案就是：⌊n3⌋\\lfloor\\frac{n}{3}\\rfloor⌊3n​⌋个3、111个2 若余数为0，则最佳方案就是：n3\\frac{n}{3}3n​个3 若余数为1，则最佳方案并非⌊n3⌋\\lfloor\\frac{n}{3}\\rfloor⌊3n​⌋个3、111个1，而是⌊n3⌋−1\\lfloor\\frac{n}{3}\\rfloor-1⌊3n​⌋−1个3、111个4 总结： Tm={3kn=3k4⋅3k−1n=3k+12⋅3kn=3k+2T_m=\\left\\{\\begin{matrix} 3^k &amp; n=3k\\\\ 4\\cdot 3^{k-1} &amp; n=3k+1\\\\2\\cdot 3^k &amp; n=3k+2 \\end{matrix}\\right. Tm​=⎩⎨⎧​3k4⋅3k−12⋅3k​n=3kn=3k+1n=3k+2​ vector&lt;int&gt; res; int t = n / 3; //3的个数 if (n % 3 == 2) res = vector&lt;int&gt;(1, 2); else if (n % 3 == 0) res = vector&lt;int&gt;(1, 1); else { res = vector&lt;int&gt;(1, 4); t --; } while (t --) res = mul(res, 3); // for (int i = res.size() - 1; i &gt;= 0; i --) cout &lt;&lt; res[i]; ","link":"https://shaoyihao.github.io/blog/整数划分/"},{"title":"映射","content":"映射的相关概念 设 XXX、YYY 是2个非空集合，如果存在一个法则 fff，使得对 XXX 中的每个元素 xxx，根据fff，在 YYY 中都有 唯一 确定的元素 yyy 与之对应，那么称 fff 为从 XXX 到 YYY 的映射。记作： f:X→Yf:X\\rightarrow Y f:X→Y 其中，yyy 称为元素 xxx 在映射fff下的 像，记作 f(x)f(x)f(x)，即：y=f(x)y=f(x)y=f(x) ；而 xxx 称为 yyy 在映射fff下的 一个原像。 集合 XXX 称为 映射 fff 的定义域，记作 DfD_fDf​，即： Df=XD_f\\textcolor{#F00}{=}X Df​=X XXX 中所有元素的像 所组成的集合称为映射 fff 的值域，记作 RfR_fRf​或f(X)f(X)f(X)，即： Rf=f(X)={f(x) ∣ x∈X} ⊆ YR_f=f(X)=\\{f(x)\\ |\\ x\\in X\\}\\ \\textcolor{#F00}{\\subseteq\\ } Y Rf​=f(X)={f(x) ∣ x∈X} ⊆ Y 注意： 映射是一种 对应法则。 当给定 定义域XXX 和 法则fff，则值域f(X)f(X)f(X)也就随之确定。 对每个 x∈Xx\\in Xx∈X，它在fff下的像yyy是唯一的；而对每个 y∈Rfy\\in R_fy∈Rf​，它在fff下的原像不一定是唯一的。 f:X→Yf:X\\rightarrow Yf:X→Y，YYY不一定是值域。 若 Rf=YR_f=YRf​=Y，即 YYY 中任意元素 yyy 都是 XXX 中某元素的像，则称 fff 为 XXX到YYY上的映射 或 满射。 若对 XXX 中任意2个元素x1,x2x_1,x_2x1​,x2​，若x1≠x2x_1\\ne x_2x1​​=x2​，则f(x1)≠f(x2)f(x_1)\\ne f(x_2)f(x1​)​=f(x2​)，则称 fff 为 XXX到YYY的 单射。 若 fff 既是满射，也是单射，则称 fff 为 一一映射 或 双射。 推论：∣X∣=∣Y∣|X|=|Y|∣X∣=∣Y∣ 逆映射 对于单射 fff，对每个 y∈Rfy\\in R_fy∈Rf​，都对应唯一的 x∈Xx\\in Xx∈X，满足f(x)=yf(x)=yf(x)=y。因此可以定义一个新映射 f−1f^{-1}f−1： f−1:Rf→Xf^{-1}:\\textcolor{#F00}{R_f}\\rightarrow X f−1:Rf​→X 对每个 y∈Rfy\\in R_fy∈Rf​，规定 f−1(y)=xf^{-1}(y)=xf−1(y)=x，该xxx满足f(x)=yf(x)=yf(x)=y。将这个映射称为fff的逆映射。 f−1f^{-1}f−1只是一个记号，与g,h,...g,h,...g,h,...无异。 注意： 只有单射才存在逆映射。 Df−1=RfD_{f^{-1}}=R_fDf−1​=Rf​而不是YYY；Rf−1=XR_{f^{-1}}=XRf−1​=X 。 一个映射若存在逆映射，则该逆映射一定是双射。（深入思考） 复合映射 设有两个映射：g:X→Y1g:X\\rightarrow Y_1g:X→Y1​， f:Y2→Zf:Y_2\\rightarrow Zf:Y2​→Z ，其中 Y1⊆Y2\\textcolor{#F00}{Y_1\\subseteq Y_2}Y1​⊆Y2​。则由g,fg,fg,f可以构造出一个从 XXX 到 ZZZ 的对应法则，它将每个 x∈Xx\\in Xx∈X 映到 f(g(x))∈Zf(g(x))\\in Zf(g(x))∈Z 。 显然 X,ZX,ZX,Z以及这个对应法则这3者可以构成一个映射，将其称为 ggg 和 fff 构成的复合映射，记作 f∘gf\\circ gf∘g： f∘g:X→Zf\\circ g: X\\rightarrow Z f∘g:X→Z 注意： 映射fff和ggg构成复合映射的条件：Rg⊆DfR_g\\subseteq D_fRg​⊆Df​ 。 两映射之间的复合是有顺序的，f∘gf\\circ gf∘g 有意义并不代表 g∘fg\\circ fg∘f 也有意义（事实上这2者基本毫无关系）。 注意顺序，是XXX先根据 ggg 映到 Y1Y_1Y1​，在根据 fff 映到 ZZZ，之所以记号为 f∘gf\\circ gf∘g 是因为 f∘g (x)=f(g(x))\\textcolor{#F00}{f\\circ g\\ \\ (x)=f(g(x))}f∘g (x)=f(g(x)) 。 ","link":"https://shaoyihao.github.io/blog/映射/"},{"title":"字符串的展开","content":" 原题链接：字符串的展开 题目大意： 一个字符串展开的例子：如果在输入的字符串中，含有类似于 d-h 或者 4-8 的字串，我们就把它当作一种简写，输出时，用连续递增的字母或数字串替代其中的减号，即，将上面两个子串分别输出为 defgh 和 45678。本题在此基础上增加一些参数，使字符串的展开更为灵活。具体约定如下： 遇到下面的情况需要做字符串的展开：在输入的字符串中，出现了减号 - ，减号两侧同为小写字母或同为数字，且按照 ASCII 码的顺序，减号右边的字符严格大于左边的字符。 参数 p1p_1p1​设置展开方式。 p1=1p_1=1p1​=1 时，对于字母子串，填充小写字母。 p1=2p_1=2p1​=2 时，对于字母子串，填充大写字母。这两种情况下数字子串的填充方式相同。 p1=3p_1=3p1​=3 时，不论是字母子串还是数字字串，都用与要填充的字母个数相同的星号 * 来填充。 参数 p2p_2p2​设置填充字符的重复个数。 p2=kp_2=kp2​=k 表示同一个字符要连续填充 kkk 个。例如，当 p2=3p_2=3p2​=3 时，子串d-h 应扩展为 deeefffgggh。减号两边的字符不变。 参数 p3p_3p3​设置是否改为逆序。 p3=1p_3=1p3​=1 表示维持原来顺序。 p3=2p_3=2p3​=2 表示采用逆序输出。注意这时候仍然不包括减号两端的字符。例如当 p1=1p_1=1p1​=1、p2=2p_2=2p2​=2、p3=2p_3=2p3​=2 时，子串 d-h 应扩展为 dggffeeh。 如果减号右边的字符恰好是左边字符的后继，只删除中间的减号，例如：d-e 应输出为 de，3-4 应输出为 34。（实际上，这就是将其展开后的结果。） 如果减号右边的字符按照 ASCII 码的顺序小于或等于左边字符，输出时，要保留中间的减号，例如：d-d 应输出为 d-d，3-1 应输出为 3-1。（也就是不展开） #include &lt;iostream&gt; using namespace std; int p1, p2, p3; //参数 string s; string f(char a, char b) { string res; if (p1 == 3) { for (int i = a + 1; i &lt; b; i ++) for (int k = 0; k &lt; p2; k ++) res += '*'; } else if (p1 == 1 &amp;&amp; p3 == 1) //小写、顺序 { for (int i = a + 1; i &lt; b; i ++) for (int k = 0; k &lt; p2; k ++) res += char(i); } else if (p1 == 2 &amp;&amp; p3 == 1) //大写、顺序 { for (int i = a + 1; i &lt; b; i ++) for (int k = 0; k &lt; p2; k ++) res += isalpha(i) ? char(i - 32) : char(i); //大写字母的ASCII码比相应小写字母小32 } else if (p1 == 1 &amp;&amp; p3 == 2) //小写、逆序 { for (int i = b - 1; i &gt; a; i --) for (int k = 0; k &lt; p2; k ++) res += char(i); } else if (p1 == 2 &amp;&amp; p3 == 2) //大写、逆序 { for (int i = b - 1; i &gt; a; i --) for (int k = 0; k &lt; p2; k ++) res += isalpha(i) ? char(i - 32) : char(i); } return res; } bool check(int i) //判断这个'-'能否展开 { if (i == 0 || i == (int)s.size() - 1) return false; //位于首尾位置 if (!((isalpha(s[i - 1]) &amp;&amp; isalpha(s[i + 1])) || (isdigit(s[i - 1]) &amp;&amp; isdigit(s[i + 1])))) return false; //不同类 if (isalpha(s[i - 1]) &amp;&amp; isalpha(s[i + 1]) &amp;&amp; s[i - 1] &gt;= s[i + 1]) return false; if (isdigit(s[i - 1]) &amp;&amp; isdigit(s[i + 1]) &amp;&amp; s[i - 1] &gt;= s[i + 1]) return false; //不满足前者小于后者 return true; } int main() { cin &gt;&gt; p1 &gt;&gt; p2 &gt;&gt; p3; cin &gt;&gt; s; string res; for (int i = 0; i &lt; (int)s.size(); i ++) //遍历每个字母 if (s[i] != '-') res += s[i]; //不是'-' else if (s[i] == '-' &amp;&amp; !check(i)) res += '-'; //'-'且不能展开 else res += f(s[i - 1], s[i + 1]); //'-'且能展开 cout &lt;&lt; res; return 0; } ","link":"https://shaoyihao.github.io/blog/字符串的展开/"},{"title":"输出多项式","content":" 原题链接：输出多项式 题目大意：给定 n+1n+1n+1 个整数，输出其对应的 nnn 次多项式。 #include &lt;iostream&gt; using namespace std; int main() { int n; cin &gt;&gt; n; for (int k = n; k &gt;= 0; k --) { int a; cin &gt;&gt; a; if (a == 0) continue; //系数为0则不输出 if (k != n &amp;&amp; a &gt; 0) putchar('+'); //正数则输出正号（首项则不输出） else if (a &lt; 0) putchar('-'); //负数输出符号 if (k == 0) printf(&quot;%d&quot;, abs(a)); //常数项 else if (abs(a) == 1 &amp;&amp; k == 1) printf(&quot;x&quot;); //系数为1，指数为1 else if (abs(a) == 1 &amp;&amp; k &gt; 1) printf(&quot;x^%d&quot;, k); //系数为1，指数不为1 else if (abs(a) != 1 &amp;&amp; k == 1) printf(&quot;%dx&quot;, abs(a)); //系数不为1，指数为1 else if (abs(a) != 1 &amp;&amp; k &gt; 1) printf(&quot;%dx^%d&quot;, abs(a), k); //系数不为1，指数不为1 } return 0; } 另一种写法： for (int k = n; k &gt;= 0; k --) { int a; cin &gt;&gt; a; if (a == 0) continue; //系数为0则不输出 if (k != n &amp;&amp; a &gt; 0) putchar('+'); //正数则输出正号（首项则不输出） else if (a &lt; 0) putchar('-'); //负数输出符号 if (k == 0) cout &lt;&lt; abs(a); //常数项 else if (abs(a) != 1 &amp;&amp; k &gt; 0) cout &lt;&lt; abs(a); //系数为±1的非 常数项 省略系数 if (k == 1) printf(&quot;x&quot;); //省略指数1 else if (k &gt;= 2) printf(&quot;x^%d&quot;, k); } ","link":"https://shaoyihao.github.io/blog/输出多项式/"},{"title":"追赶奶牛","content":" 原题链接：追赶奶牛 题目大意：给定 10×1010\\times 1010×10 的网格图，农夫追赶奶牛，每遇到障碍边顺时针转向90°，初始时都向北（上），判断农夫需要多久才能追上奶牛。 思路：先定义4个方向： int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1}; 用变量 ddd 表示当前的方向，若需要顺时针转向，就：d = (d + 1) % 4 。 关键在于如何判断能否追上？ 若将每个时刻农夫和奶牛所处的位置和方向视为一种状态，则若某个状态第222次出现，就说明状态出现了循环，那么将永远也无法追上。 方法就是**将农夫和奶牛的位置、方向 共 666 个变量构成的元组 映射到一个唯一值，判断该哈希值是否出现过即可。**哈希方式可以使用进制转化的思想，因为这6个变量的范围均小于11，因此可以将这6个变量视为一个11进制数，转化为十进制就是相应的哈希值。 #include &lt;iostream&gt; using namespace std; int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1}; char g[12][12]; bool st[1000000]; int main() { int x, y, a, b; for (int i = 1; i &lt;= 10; i ++) for (int j = 1; j &lt;= 10; j ++) { cin &gt;&gt; g[i][j]; if (g[i][j] == 'F') x = i, y = j, g[i][j] = '.'; if (g[i][j] == 'C') a = i, b = j, g[i][j] = '.'; } bool flag = true; int cnt = 0, d1 = 0, d2 = 0; while (x != a || y != b) { int x2 = x + dx[d1], y2 = y + dy[d1]; if (1 &lt;= x2 &amp;&amp; x2 &lt;= 10 &amp;&amp; 1 &lt;= y2 &amp;&amp; y2 &lt;= 10 &amp;&amp; g[x2][y2] == '.') x = x2, y = y2; else d1 = (d1 + 1) % 4; int a2 = a + dx[d2], b2 = b + dy[d2]; if (1 &lt;= a2 &amp;&amp; a2 &lt;= 10 &amp;&amp; 1 &lt;= b2 &amp;&amp; b2 &lt;= 10 &amp;&amp; g[a2][b2] == '.') a = a2, b = b2; else d2 = (d2 + 1) % 4; int hash = x + y * 11 + a * 11 * 11 + b * 11 * 11 * 11 + d1 * 11 * 11 * 11 * 11 + d2 * 11 * 11 * 11 * 11 * 11; if (st[hash] == false) { st[hash] = true; cnt ++; } else { flag = false; break; } } if (flag == false) cout &lt;&lt; 0; else cout &lt;&lt; cnt; return 0; } 另一种方法 由于地图规模只有 10×1010\\times 1010×10，因此牛和农夫分别各有400400400种状态（100×4），整体上即400×400=160000400\\times400=160000400×400=160000种状态。农夫和牛的每一次移动都是一次状态的变化，若移动次数大于160000160000160000，则必然存在某状态的重复，也就意味着永远追不上。 #include &lt;iostream&gt; using namespace std; int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1}; char g[12][12]; void move(int&amp; x, int&amp; y, int&amp; d) { int a = x + dx[d], b = y + dy[d]; if (a &gt;= 0 &amp;&amp; a &lt; 10 &amp;&amp; b &gt;= 0 &amp;&amp; b &lt; 10 &amp;&amp; g[a][b] == '.') x = a, y = b; else d = (d + 1) % 4; } int main() { int x1, y1, x2, y2; for (int i = 0; i &lt; 10; i ++) for (int j = 0; j &lt; 10; j ++) { cin &gt;&gt; g[i][j]; if (g[i][j] == 'F') x1 = i, y1 = j, g[i][j] = '.'; else if (g[i][j] == 'C') x2 = i, y2 = j, g[i][j] = '.'; } int d1 = 0, d2 = 0, cnt = 0; while (cnt &lt;= 160000) { move(x1, y1, d1); move(x2, y2, d2); cnt ++; if (x1 == x2 &amp;&amp; y1 == y2) { cout &lt;&lt; cnt &lt;&lt; endl; return 0; } } cout &lt;&lt; 0 &lt;&lt; endl; return 0; } ","link":"https://shaoyihao.github.io/blog/追赶奶牛/"},{"title":"猜拳","content":" 原题链接：生活大爆炸版石头剪刀布 题目大意：一种含有555种招式（记作：0,1,2,3,40,1,2,3,40,1,2,3,4）的猜拳，胜负关系为： 已知甲，乙按一定周期出拳，求经过 nnn 轮后，二人的比分。 思路：本题重点就是如何存储胜负关系（上面的表格）？ 可以使用集合，集合s[i]中存储 招式iii所能击败的招式。 set&lt;int&gt; s[5] = {{2, 3}, {0, 3}, {1, 4}, {2, 4}, {0, 1}}; 对于招式jjj，若可以在s[i]中找到jjj，则说明iii可以击败jjj；反之，若可以在s[j]中找到iii，则说明jjj可以击败iii。 #include &lt;iostream&gt; #include &lt;set&gt; using namespace std; set&lt;int&gt; s[5] = {{2, 3}, {0, 3}, {1, 4}, {2, 4}, {0, 1}}; const int N = 210; int a[N], b[N]; int main() { int n, Ta, Tb; cin &gt;&gt; n &gt;&gt; Ta &gt;&gt; Tb; for (int i = 0; i &lt; Ta; i ++) cin &gt;&gt; a[i]; //读入甲的出拳方式周期 for (int i = 0; i &lt; Tb; i ++) cin &gt;&gt; b[i]; int cnta = 0, cntb = 0; for (int i = 0; i &lt; n; i ++) { if (s[a[i % Ta]].count(b[i % Tb])) cnta ++; //循环出拳 if (s[b[i % Tb]].count(a[i % Ta])) cntb ++; } cout &lt;&lt; cnta &lt;&lt; ' ' &lt;&lt; cntb; return 0; } 另一种思路 直接用二维数组存储得分，s[i][j]表示当甲出iii、乙出jjj时，甲所能得的分数。 int s[5][5] = {{0,0,1,1,0}, {1,0,0,1,0}, {0,1,0,0,1}, {0,0,1,0,1}, {1,1,0,0,0}}; int cnta = 0, cntb = 0; for (int i = 0; i &lt; n; i ++) { cnta += s[a[i % Ta]][b[i % Tb]]; cntb += s[b[i % Tb]][a[i % Ta]]; } // cout &lt;&lt; cnta &lt;&lt; ' ' &lt;&lt; cntb; ","link":"https://shaoyihao.github.io/blog/猜拳/"},{"title":"旋转矩阵","content":" 原题链接：旋转矩阵 题目大意：给定一个 n×nn\\times nn×n 的矩阵，对于 x,y,r,zx,y,r,zx,y,r,z，把以第 xxx 行第 yyy 列的元素为中心的 2r+12r+12r+1 阶矩阵按照某种时针方向旋转（z=0z=0z=0 表示顺时针，z=1z=1z=1 表示逆时针）。 思路： 在模拟时，如果是在原矩阵上直接进行覆盖，则一定要注意覆盖的顺序：因为2条邻边之间共享了一个元素（拐角元素）。 正确的覆盖顺序也是一种非常符合直觉的方式。（脑中动态模拟一下） 事实上只要前333边的覆盖满足上述顺序即可，最后一条边可以不必这样，因为最后一条边已经是所剩唯一还没被处理的边，覆盖它不会影响到其他边。 #include &lt;iostream&gt; using namespace std; const int N = 510; int g[N][N]; void f(int x, int y, int r, int z) { int tmp[2 * r + 1]; for (int i = 0; i &lt; 2 * r + 1; i ++) tmp[i] = g[x - r][y - r + i]; //暂存一条边，因为该边接下来会被覆盖 if (z == 1) //逆时针 { for (int i = 0; i &lt; 2 * r + 1; i ++) //上 g[x - r][y - r + i] = g[x - r + i][y + r]; for (int i = 0; i &lt; 2 * r + 1; i ++) //右 g[x - r + i][y + r] = g[x + r][y + r - i]; for (int i = 0; i &lt; 2 * r + 1; i ++) //下 g[x + r][y + r - i] = g[x + r - i][y - r]; for (int i = 0; i &lt; 2 * r + 1; i ++) //左 g[x + r - i][y - r] = tmp[i]; } else //顺时针 { for (int i = 0; i &lt; 2 * r + 1; i ++) //上 g[x - r][y + r - i] = g[x - r + i][y - r]; for (int i = 0; i &lt; 2 * r + 1; i ++) //左 g[x - r + i][y - r] = g[x + r][y - r + i]; for (int i = 0; i &lt; 2 * r + 1; i ++) //下 g[x + r][y - r + i] = g[x + r - i][y + r]; for (int i = 0; i &lt; 2 * r + 1; i ++) //右 g[x - r + i][y + r] = tmp[i]; //最后一条边随意些也无妨 } } int main() { int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1, idx = 1; i &lt;= n; i ++) for (int j = 1; j &lt;= n; j ++) g[i][j] = idx ++; while (m --) { int x, y, r, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; r &gt;&gt; z; while (r) //一个矩阵可以视作是多个“环” { f(x, y, r, z); r --; } } for (int i = 1; i &lt;= n; i ++) { for (int j = 1; j &lt;= n; j ++) cout &lt;&lt; g[i][j] &lt;&lt; ' '; puts(&quot;&quot;); } return 0; } 当然，如果每次都将矩阵拷贝一遍，再进行复制，那么就不必考虑可能覆盖的问题了。使用了额外空间，但是逻辑上更加清晰了。 #include &lt;iostream&gt; #include &lt;cstring&gt; using namespace std; const int N = 510; int g[N][N], g2[N][N]; void f(int x, int y, int r, int z) { if (z == 1) //逆时针 { for (int i = 0; i &lt; 2 * r + 1; i ++) //上 g[x - r][y - r + i] = g2[x - r + i][y + r]; for (int i = 0; i &lt; 2 * r + 1; i ++) //右 g[x - r + i][y + r] = g2[x + r][y + r - i]; for (int i = 0; i &lt; 2 * r + 1; i ++) //下 g[x + r][y - r + i] = g2[x - r + i][y - r]; for (int i = 0; i &lt; 2 * r + 1; i ++) //左 g[x - r + i][y - r] = g2[x - r][y + r - i]; } else //顺时针 { for (int i = 0; i &lt; 2 * r + 1; i ++) //上 g[x - r][y - r + i] = g2[x + r - i][y - r]; for (int i = 0; i &lt; 2 * r + 1; i ++) //左 g[x - r + i][y - r] = g2[x + r][y - r + i]; for (int i = 0; i &lt; 2 * r + 1; i ++) //下 g[x + r][y - r + i] = g2[x + r - i][y + r]; for (int i = 0; i &lt; 2 * r + 1; i ++) //右 g[x - r + i][y + r] = g2[x - r][y - r + i]; } } int main() { int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1, idx = 1; i &lt;= n; i ++) for (int j = 1; j &lt;= n; j ++) g[i][j] = idx ++; while (m --) { memcpy(g2, g, sizeof(g)); //拷贝当前矩阵的状态 int x, y, r, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; r &gt;&gt; z; while (r) //旋转该矩阵：一个矩阵可以视作是多个“环” { f(x, y, r, z); // 旋转一个环 r --; } } for (int i = 1; i &lt;= n; i ++) { for (int j = 1; j &lt;= n; j ++) cout &lt;&lt; g[i][j] &lt;&lt; ' '; puts(&quot;&quot;); } return 0; } ","link":"https://shaoyihao.github.io/blog/旋转矩阵/"},{"title":"扫雷","content":" 原题链接：扫雷 给出 nnn 行 mmm 列格子中的地雷分布，计算每个非地雷格中的数字。 #include &lt;iostream&gt; using namespace std; int dx[8] = {-1, -1, 0, 1, 1, 1, 0, -1}, dy[8] = {0, 1, 1, 1, 0, -1, -1, -1}; const int N = 210; char g[N][N]; int q[N][N]; int main() { int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i ++) for (int j = 1; j &lt;= m; j ++) cin &gt;&gt; g[i][j]; for (int i = 1; i &lt;= n; i ++) for (int j = 1; j &lt;= m; j ++) if (g[i][j] != '*') { int cnt = 0; for (int k = 0; k &lt; 8; k ++) if (g[i + dx[k]][j + dy[k]] == '*') cnt ++; q[i][j] = cnt; } for (int i = 1; i &lt;= n; i ++) { for (int j = 1; j &lt;= m; j ++) if (g[i][j] == '*') cout &lt;&lt; '*'; else cout &lt;&lt; q[i][j]; puts(&quot;&quot;); } return 0; } ","link":"https://shaoyihao.github.io/blog/扫雷/"},{"title":"11分制 or 21分制","content":" 原题链接：11分制or21分制 题目大意：输入一个表示胜负关系的字符串，其中W代表小w赢，L代表小l赢。分别输出在11分制下和21分制下的每局比分。 需要注意的是，在 uuu 分制下，当某一方的比方达到 uuu 后，还需要领先对方 222 分才能赢得比赛。 if ((w &gt;= u || l &gt;= u) &amp;&amp; abs(w - l) &gt;= 2) 完整代码： #include &lt;iostream&gt; using namespace std; const int N = 70000; char c[N]; int n; void show(int u) { int w = 0, l = 0; for (int i = 0; i &lt; n; i ++) { if (c[i] == 'W') w ++; else if (c[i] == 'L') l ++; if ((w &gt;= u || l &gt;= u) &amp;&amp; abs(w - l) &gt;= 2) { printf(&quot;%d:%d\\n&quot;, w, l); w = l = 0; } } printf(&quot;%d:%d\\n&quot;, w, l); //输出当前比分 } int main() { char ch; while (cin &gt;&gt; ch &amp;&amp; ch != 'E') c[n ++] = ch; show(11); puts(&quot;&quot;); show(21); return 0; } ","link":"https://shaoyihao.github.io/blog/11分制or21分制/"},{"title":"分巧克力","content":" 原题链接：分巧克力 题目大意：给定 nnn 块巧克力的尺寸 hi×wih_i\\times w_ihi​×wi​，从中切出 kkk 块一样的正方形，要求边长是整数且面积尽可能大。求最大的边长。 若指定的边长很大，则切出的巧克力数就会很少，就会不满足题意； 若指定的边长很小，则切出的巧克力数就会很多。 显然问题具有单调性，所求的结果就是左区间的右端点。二分的框架为： int l = 0, r = 1e5; while (l &lt; r) { int mid = (l + r + 1) / 2; if (check(mid)) l = mid; else r = mid - 1; } cout &lt;&lt; l; 若指定的边长是ccc，则w×hw\\times hw×h的巧克力可以切出的正方形有：⌊wc⌋×⌊hc⌋\\lfloor\\frac{w}{c}\\rfloor\\times\\lfloor\\frac{h}{c}\\rfloor⌊cw​⌋×⌊ch​⌋ 个。统计所有的巧克力可以切出的正方形总数cntcntcnt，将其与kkk进行比较。若cnt≥kcnt\\ge kcnt≥k，则指定的ccc满足条件；否则ccc不满足。 bool check(int x) { int cnt = 0; for (int i = 0; i &lt; n; i ++) { cnt += (h[i] / x) * (w[i] / x); if (cnt &gt;= k) return true; //提前退出（小优化） } return false; } ","link":"https://shaoyihao.github.io/blog/分巧克力/"},{"title":"四平方和","content":" 原题链接：四平方和 题目大意：四平方和定理（又称为拉格朗日定理）：每个正整数都可以表示为至多 4 个正整数的平方和。如果把0包括进去，那么就是每个正整数都可以表示为4个非负整数的平方和。 n=a2+b2+c2+d2n=a^2+b^2+c^2+d^2 n=a2+b2+c2+d2 暴力做法需要枚举a,b,ca,b,ca,b,c，三重循环，时间复杂度为O(N3)O(N^3)O(N3)，慢。 小技巧：判断一个数是否为平方数： int d = sqrt(x); //如果是小数，会被截成整数 if (d * d == x) puts(&quot;Yes&quot;); #include &lt;iostream&gt; #include &lt;cmath&gt; using namespace std; int main() { int n; cin &gt;&gt; n; for (int a = 0; a * a &lt;= n; a ++) for (int b = a; a * a + b * b &lt;= n; b ++) for (int c = b; a * a + b * b + c * c &lt;= n; c ++) { int t = n - a * a - b * b - c * c; int d = sqrt(t); if (d * d == t) //判断t是否为平方数 { printf(&quot;%d %d %d %d&quot;, a, b, c, d); return 0; } } } 如何进行优化呢？ 可以用空间换时间的思想，先预处理存储所有可能出现的c2+d2c^2+d^2c2+d2，然后只需枚举a,ba,ba,b即可。对于每组a,ba,ba,b，在已存储的二平方和数组中二分查找 n−a2−b2n-a^2-b^2n−a2−b2。时间复杂度为：O(N2lg⁡N)O(N^2\\lg N)O(N2lgN)。 用二分查找来判断某个数是否已经存储过。也可以用哈希表来判断。 二分 题目要求输出的是字典序最小的a,b,c,da,b,c,da,b,c,d，由于是先枚举的a,ba,ba,b，因此若能找到一组解，此时a,ba,ba,b一定是4个数中最小的，满足字典序最小。问题是如何保证找到的c2+d2c^2+d^2c2+d2中c,dc,dc,d也是字典序最小的呢？ 方法是将c2+d2,c,dc^2+d^2,c,dc2+d2,c,d作为一个结构体进行存储，之后排序时考虑字典序的问题。 struct Sum { int s, c, d; bool operator&lt; (const Sum &amp;t)const //重载运算符，规定排序的规则 { if (s != t.s) return s &lt; t.s; if (c != t.c) return c &lt; t.c; return d &lt; t.d; } }sum[N]; for (int c = 0; c * c &lt;= n; c ++) for (int d = c; c * c + d * d &lt;= n; d ++) sum[k ++] = {c*c+d*d, c, d}; //结构体的赋值 sort(sum, sum + k); 程序主要部分： for (int a = 0; a * a &lt;= n; a ++) for (int b = 0; a * a + b * b &lt;= n; b ++) { int t = n - a * a - b * b; int l = 0, r = k - 1; while (l &lt; r) { int mid = (l + r) / 2; if (sum[mid].s &gt;= t) r = mid; else l = mid + 1; } if (sum[l].s == t) { printf(&quot;%d %d %d %d&quot;, a, b, sum[l].c, sum[l].d); return 0; } } 哈希表 若采用哈希表来判断c2+d2c^2+d^2c2+d2是否存储过：O(N2)O(N^2)O(N2) #include &lt;iostream&gt; #include &lt;unordered_map&gt; using namespace std; typedef pair&lt;int, int&gt; PII; int main() { int n; cin &gt;&gt; n; unordered_map&lt;int, PII&gt; S; for (int c = 0; c * c &lt;= n; c ++) for (int d = c; c * c + d * d &lt;= n; d ++) { int t = c * c + d * d; if (S.count(t) == 0) S[t] = {c, d}; //首次存储的一定是字典序最小的c、d } for (int a = 0; a * a &lt;= n; a ++) for (int b = 0; a * a + b * b &lt;= n; b ++) { int t = n - a * a - b * b; if (S.count(t)) //是否存储过 { printf(&quot;%d %d %d %d&quot;, a, b, S[t].first, S[t].second); return 0; } } } ","link":"https://shaoyihao.github.io/blog/四平方和/"},{"title":"机器人跳跃","content":" 原题链接：机器人跳跃 题目大意：n+1n+1n+1座塔的高度存储于hhh数组，其中h[0]=0h[0]=0h[0]=0（起点）。 机器人起始时位于第000座塔，初始能量为E0E_0E0​，接下来会一座一座地在塔间跳跃。机器人在第iii座塔上时的能量为E[i]E[i]E[i]，满足： E[i+1]={E[i]+∣E[i]−h[i+1]∣,E[i]≥h[i+1]E[i]−∣E[i]−h[i+1]∣,E[i]&lt;h[i+1]=2E[i]−h[i+1]E[i+1]=\\left\\{\\begin{matrix} E[i]+|E[i]-h[i+1]|, &amp; E[i]\\ge h[i+1]\\\\ E[i]-|E[i]-h[i+1]|,&amp;E[i]&lt;h[i+1]\\end{matrix}\\right.=2E[i]-h[i+1] E[i+1]={E[i]+∣E[i]−h[i+1]∣,E[i]−∣E[i]−h[i+1]∣,​E[i]≥h[i+1]E[i]&lt;h[i+1]​=2E[i]−h[i+1] 若存在某座塔ttt（t≤nt\\le nt≤n），有：E[t−1]&lt;h[t]−E[t−1]E[t-1]&lt;h[t]-E[t-1]E[t−1]&lt;h[t]−E[t−1]，即：E[t]&lt;0E[t]&lt;0E[t]&lt;0，则机器人将无法到达终点（第nnn座塔）。 求要想使机器人能够到达终点，初始能量最少应为多少？ 思路：当E0E_0E0​很大时，显然可以到达终点；当E0E_0E0​较小时就会无法到达终点。容易看出其中的单调性，答案是右区间的左端点。 基本框架： int l = 0, r = 1e5; //答案的范围 while (l &lt; r) { int mid = (l + r) / 2; if (check(mid)) r = mid; else l = mid + 1; } printf(&quot;%d&quot;, r); 关键是check函数如何写？即如何判断给定的一个初始能量能否使机器人到达终点。 方法：利用给定的E0E_0E0​，根据题意，递推求出在各塔上时的能量E[i]E[i]E[i]，若存在E[i]&lt;0E[i]&lt;0E[i]&lt;0，则说明不能到达终点；否则说明可以。 注意到：当各塔之间高度相差不大时，近似有：E[i]=2E[i−1]E[i]=2E[i-1]E[i]=2E[i−1]，此时EEE值以指数递增，很容易爆整数类型。 事实上当存在某塔处 E[t]≥max⁡1≤i≤n{hi}E[t]\\ge\\max\\limits_{1\\le i\\le n}\\{h_i\\}E[t]≥1≤i≤nmax​{hi​}，之后E[t+1]=2E[t]−h[t+1]≥E[t]E[t+1]=2E[t]-h[t+1]\\ge E[t]E[t+1]=2E[t]−h[t+1]≥E[t]，即之后EEE值总是不减，始终大于0，即之后不可能存在E&lt;0E&lt;0E&lt;0的情况，一定可以到达终点。 bool check(int e) { for (int i = 1; i &lt;= n; i ++) //递推求E值 { e = e * 2 - h[i]; if (e &lt; 0) return false; if (e &gt;= 1e5) return true; //一定可以到达终点 } return true; } ","link":"https://shaoyihao.github.io/blog/机器人跳跃/"},{"title":"手机充电","content":" 原题链接：kotori的设备 题目大意：有nnn部手机，初始电量为bib_ibi​，耗电速率为ai/sa_i/sai​/s，只有一个充电器，充电速率为p/sp/sp/s，求这nnn部手机可以同时工作的最长时间。（即存在一部手机电量为0时即停止） 所有手机单位时间内总耗电为：a1+a2+...+ana_1+a_2+...+a_na1​+a2​+...+an​，单位时间充电为ppp。 若p≥a1+a2+...+anp\\ge a_1+a_2+...+a_np≥a1​+a2​+...+an​，则这nnn部手机可以无限久同时工作。 若p&lt;a1+a2+...+anp&lt; a_1+a_2+...+a_np&lt;a1​+a2​+...+an​，则不可能无限久同时工作下去，存在一个最大时间。 用二分查找该最长时间：指定一个时长ttt，若nnn部手机可以同时工作ttt时间，则时长ttt还可以设的更大；若不能同时工作ttt时间，则时长ttt应设小一点。 问题转化为：如何判断nnn部手机能否同时工作ttt时间？ 经过时间ttt时，若手机还有剩余电量，则这些手机不必充电，都可以工作ttt时间，因此这些手机不必考虑； 对于需要充电的手机，求出要想这些手机工作ttt时间总共至少需要充多少电（sumsumsum），将该值与ptptpt（充电器ttt时间内总共可以充的电量）进行比较： 若sum≤ptsum\\le ptsum≤pt，则充电器可以满足所需电量的需求，因此这些手机可以工作ttt时间 若sum&gt;ptsum&gt;ptsum&gt;pt，则充电器无法满足所需电量的需求，因此这些手机不能同时工作ttt时间 #include &lt;iostream&gt; using namespace std; const int N = 100010; double a[N], b[N], p; int n; bool check(double t) //判断n部设备能否同时工作时间t { double sum = 0; for (int i = 0; i &lt; n; i ++) if (a[i] * t &gt; b[i]) sum += a[i] * t - b[i]; //总共需要充的电 if (sum &gt; p * t) return false; //与实际可充电量pt进行比较 else return true; } int main() { cin &gt;&gt; n &gt;&gt; p; double sum = 0; for (int i = 0; i &lt; n; i ++) { cin &gt;&gt; a[i] &gt;&gt; b[i]; sum += a[i]; } double res; if (sum &lt;= p) res = -1; //无限久 else { double l = 0, r = 1e10; while (r - l &gt; 1e-6) //浮点数二分，求出最长时间 { double mid = (l + r) / 2; if (check(mid)) l = mid; else r = mid; } res = l; } cout &lt;&lt; res; return 0; } ","link":"https://shaoyihao.github.io/blog/手机充电/"},{"title":"数组分段","content":" 原题链接：数列分段 题目大意：将某段中的元素元素之和称为“段元素和”。将数组qqq分段后，可以得到一个最大的段元素和sis_isi​。求的就是在所分段数不超过mmm 的所有分段方式中最小的sss。 首先确定sss的范围：[qmax,∑i=1nqi][q_{max},\\sum\\limits_{i=1}^nq_i][qmax​,i=1∑n​qi​]，任意指定一个sss， 若存在一种分段方式使得最大的段元素和为sss，则说明sss可能还能更小 若不存在这样的分段方式能满足sss，则说明sss需要指定的大一点 根据这种思想就可以用二分找到最小的sss。 问题在于：如何判断所指定的sss是否可以满足，也就是check(mid)函数如何写？ 当指定一个sss时，从头到尾遍历数组，求出当最大的段元素和小于等于sss时最少需要分为多少段（ttt)。 若t&gt;mt&gt;mt&gt;m，则在最多只能分 mmm 段的情况下根本无法使最大的段元素和小于等于sss，因此无法满足；否则可以。 #include &lt;iostream&gt; using namespace std; const int N = 100010; int q[N], n, m, l, r; bool check(int x) //求出使段元素和≤x最少需要分的段数，再与m进行比较 { int cnt = 0; for (int i = 0; i &lt; n; i ++) { int sum = 0; while (i &lt; n &amp;&amp; sum &lt;= x) sum += q[i ++]; //跳出循环时有3种情况：当前段元素和&gt;x、到达了数组结尾、当前段元素和&gt;x且又到达了数组结尾 if (sum &gt; x &amp;&amp; i == n) //当前段元素和&gt;x且又到达了数组结尾 { cnt = cnt + 2; //最后一部分的前几个元素为1段，最后一个元素单独为1段。即产生2段。 break; } else if (i == n) //到达数组结尾 { cnt ++; //最后一部分为1段 break; } else //当前段元素和&gt;x 例如：a1+a2+a3&gt;x，则此时应a1,a2为一段，i当前所指元素为a4 { cnt ++; //产生了1个分段 i = i - 2; //i指回a2，接下来i++，使得i指向a3，即下一段的首元素 } } if (cnt &lt;= m) return true; return false; } int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i ++) { cin &gt;&gt; q[i]; l = max(l, q[i]); r += q[i]; } while (l &lt; r) //二分寻找答案 { int mid = (l + r) / 2; if (check(mid)) r = mid; else l = mid + 1; } cout &lt;&lt; r; return 0; } ","link":"https://shaoyihao.github.io/blog/数组分段/"},{"title":"路标设置","content":" 原题链接：路标设置 题目大意：在已知一些点的线段上，添加KKK个点，使相邻两点之间的距离整体上最小。 思路：本题与跳石头类型，都是在区间内直接二分出结果，难点在于check(mid)函数的判断。 查找对象：“空旷指数” 二分区间：[0,107][0,10^7][0,107] 若当前所设的“空旷指数”无法实现，则“空旷指数”应往更大的方向找；若当前所设的“空旷指数”可以实现，则为保证“空旷指数”最小，“空旷指数”应再往较小的方向找。 （“空旷指数”较大容易满足，较小则可能无法实现，因此要找的就是：右侧区间的左端点） 以上便是二分的过程。接下来要弄明白的就是如何判断是否可以实现？ 方法为：对于假设的“空旷指数”xxx，求出要想使“空旷指数”为xxx，需要添加多少个路标，将该结果cntcntcnt与KKK进行比较。 若 cnt≤Kcnt \\le Kcnt≤K，则可以实现 若 cnt&gt;Kcnt &gt; Kcnt&gt;K，则不能实现 最后一个问题就是：如何求出要想使“空旷指数”为xxx，需要添加路标数？ 对于相邻的两个路标i,i+1i,i+1i,i+1，之间的距离为ddd。若d&gt;xd&gt;xd&gt;x，则说明需要在二者之间添加路标： 若xxx不能整除ddd，则添加的路标数为：⌊dx⌋\\lfloor\\frac{d}{x}\\rfloor⌊xd​⌋ 若xxx可以整除ddd，则添加的路标数为：dx−1\\frac{d}{x}-1xd​−1 #include &lt;iostream&gt; using namespace std; const int M = 100010; int d[M]; int L, N, K; bool check(int x) //判断 通过添加不超过K个路标 能否使“空旷指数”为x { int last = 1, cnt = 0; for (int i = 2; i &lt;= N; i ++) //从第2个路标开始枚举，判断与前一个路标之间是否需要添加路标 { if (d[i] - d[last] &gt; x) //需要添加路标 { if ((d[i] - d[last]) % x == 0) cnt += (d[i] - d[last]) / x - 1; else cnt += (d[i] - d[last]) / x; } last = i; } if (cnt &lt;= K) return true; else return false; } int main() { cin &gt;&gt; L &gt;&gt; N &gt;&gt; K; for (int i = 1; i &lt;= N; i ++) cin &gt;&gt; d[i]; int l = 1, r = 1e7+10; while (l &lt; r) //二分 { int mid = (l + r) / 2; if (check(mid)) r = mid; else l = mid + 1; } cout &lt;&lt; l; return 0; } ","link":"https://shaoyihao.github.io/blog/路标设置/"},{"title":"跳石头","content":" 原题链接：跳石头 题目大意：在含有NNN个点（不包括端点）的线段上，删去MMM个点，使相邻两点之间的距离整体上最大。 思路： 明确查找对象：最短间隔的最大值lll 注意：“最短”指的是在当前状态下所有石头中的最小间隔ttt。每种状态都对应一个ttt，“最大”指的是在所有石头的摆放状态中，这些ttt中的最大值。 查找范围：[1,109][1,10^9][1,109] 逻辑关系：除去MMM块石头。 因此解题思路：二分查找 lll，判断这样的 lll 能否通过除去MMM块石头来实现。 若不能实现，就说明此时 lll 偏大了，需要移除更多的石头才行，无法实现 若能实现，说明这种最短间隔可以实现，但不一定是最大的最短间隔 lll较小时容易实现，lll较大时可能无法实现，最终答案就是这两种情况的临界值（左区间的右端点） 判断能否实现的方法是：**计算出至少需要移除多少块石头才能使最短距离为lll，将结果cntcntcnt（0≤cnt≤N0\\le cnt\\le N0≤cnt≤N）与题目给定的MMM进行比较。**具体步骤为：按顺序遍历每一块石头，判断是否需要移除。 int last = 0, cnt = 0; for (int i = 1; i &lt;= n; i ++) if (d[i] - last &lt; l) cnt ++; else last = d[i]; 若 cnt&gt;Mcnt &gt; Mcnt&gt;M，则移走MMM块石头无法实现最短距离为lll 若 cnt≤Mcnt \\le Mcnt≤M（M&lt;NM&lt; NM&lt;N时），则可以实现 注意：cnt=Ncnt=Ncnt=N时并不意味着去掉NNN个石头就能使最短距离为lll，还可能是NNN为边界的缘故。此时需要比较LLL与lll 若L&lt;lL&lt;lL&lt;l，则即使将NNN个石头都去掉，也仍无法实现 若L≥lL\\ge lL≥l，则可以实现 #include &lt;iostream&gt; using namespace std; const int N = 50010; int L, n, m; int d[N]; bool check(int x) //判断 通过至多移除m个石头使得最短距离为x 能否实现。方法：计算要想使最短距离为x需要移除多少石头，与m进行比较 { int last = 0, cnt = 0; for (int i = 1; i &lt;= n; i ++) if (d[i] - last &lt; x) cnt ++; //需要移除该石头，数目+1 else last = d[i]; if (cnt &gt; m || (cnt == n &amp;&amp; x &gt; L)) return false; else return true; } int main() { cin &gt;&gt; L &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i ++) cin &gt;&gt; d[i]; int l = 1, r = 1e9; while (l &lt; r) { int mid = (l + r + 1) / 2; if (check(mid)) l = mid; else r = mid - 1; } cout &lt;&lt; l; return 0; } ","link":"https://shaoyihao.github.io/blog/跳石头/"},{"title":"木材加工","content":" 原题链接：木材加工 题目大意：给定数组 q1,...,qnq_1,...,q_nq1​,...,qn​，求出最大的整数LLL，满足： ⌊q1L⌋+⌊q2L⌋+...+⌊qnL⌋=k\\lfloor\\frac{q_1}{L}\\rfloor+\\lfloor\\frac{q_2}{L}\\rfloor+...+\\lfloor\\frac{q_n}{L}\\rfloor=k ⌊Lq1​​⌋+⌊Lq2​​⌋+...+⌊Lqn​​⌋=k 思路：二分的范围为：[0,108][0,10^8][0,108]，分为2部分：≤L\\le L≤L 和 &gt;L&gt;L&gt;L。 当mid属于范围一时，表现为：sum ≥ k 当mid属于范围二时，表现为：sum &lt; k 二分查找左区间的右端点。 #include &lt;iostream&gt; using namespace std; const int N = 100010; int q[N]; int main() { int n, k; cin &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; n; i ++) cin &gt;&gt; q[i]; int l = 0, r = 1e8; //二分的范围 while (l &lt; r) { int mid = (l + r + 1) / 2, sum = 0; for (int i = 0; i &lt; n; i ++) sum += (q[i] / mid); if (sum &gt;= k) l = mid; else r = mid - 1; } cout &lt;&lt; l; return 0; } ","link":"https://shaoyihao.github.io/blog/木材加工/"},{"title":"最接近的数","content":" 原题链接：烦恼的高考志愿 题目大意：给定一个长度为 mmm 的数组，再给定 nnn 个数（询问），对于每一个数，在数组中找到与其最接近的数，求nnn个差值的和。 思路：先将数组排序，然后利用二分进行搜索。 二分查找数组中最后一个小于等于xxx的数q[l]q[l]q[l]（左区间的右端点），得到：q[l],x,q[l+1]q[l], x, q[l +1]q[l],x,q[l+1]，需要判断q[l]q[l]q[l]和q[l+1]q[l + 1]q[l+1]哪个更接近于xxx。 要注意边界问题： 当xxx小于该数组的最小值时，数组的最小值就是最接近xxx的数 当xxx大于该数组的最大值时，数组的最大值就是最接近xxx的数 注意，对于所用的二分模板，其查找的 命题的边界值，若原数组中本就不存在所要查找的满足命题PPP的元素，则二分找到的元素就是距离最近的的元素，虽然该元素满足QQQ。 例如，如果要查找的元素比数组中的最小值还要小，则该模板最终指向的就是数组的最小值；如果要查找的元素比数组中的最大值还要大，则该模板最终指向的就是数组的最大值。 const int N = 1000100; int q[N]; int main() { int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i ++) cin &gt;&gt; q[i]; sort(q, q + n); int x, t; cin &gt;&gt; x; int l = 0, r = n - 1; //在数组找到最后一个小于等于x的数 while (l &lt; r) { int mid = (l + r + 1) / 2; if (q[mid] &lt;= x) l = mid; else r = mid - 1; } if (x &lt;= q[0]) t = q[0]; else if (x &gt;= q[n - 1]) t = q[n - 1]; //也可以直接写为：if (x &lt;= q[0] || x &gt;= q[n - 1]) t = q[l]; //就是二分的结果 else t = (x - q[l] &lt; q[l + 1] - x) ? q[l] : q[l + 1]; cout &lt;&lt; t; return 0; } 本题AC代码 #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 1000100; int q[N]; int main() { int m, n; cin &gt;&gt; m &gt;&gt; n; for (int i = 0; i &lt; m; i ++) cin &gt;&gt; q[i]; sort(q, q + m); long long res = 0; while (n --) { int x; cin &gt;&gt; x; int l = 0, r = m - 1; while (l &lt; r) { int mid = (l + r + 1) / 2; if (q[mid] &lt;= x) l = mid; else r = mid - 1; } if (q[0] &gt;= x) res += (q[0] - x); else if (x &gt;= q[m - 1]) res += (x - q[m - 1]); // if (q[0] &gt;= x || x &gt;= q[m - 1]) res += (abs(q[l] - x)); else res += min(x - q[l], q[l + 1] - x); } cout &lt;&lt; res; return 0; } ","link":"https://shaoyihao.github.io/blog/最接近的数/"},{"title":"一元三次方程的根","content":" 原题链接：一元三次方程求解 题目大意：给定一元三次方程 ax3+bx2+cx+d=0a x^3 + b x^2 + c x + d = 0ax3+bx2+cx+d=0 的系数a,b,c,da,b,c,da,b,c,d ，并约定该方程存在三个不同实根（根的范围在 −100-100−100 至 100100100 之间），且根与根之差的绝对值 ≥1\\ge 1≥1。由小到大依次输出这三个实根。 思路：由于根的范围在 [−100∼100][-100\\sim 100][−100∼100] 之间，又两零点之间的距离≥1\\ge 1≥1，因此可以枚举每个长度为1的区间（注意点不能重复），在每个区间上用二分查找零点。 对于方程 f(x)=0f(x) = 0f(x)=0，若存在 222 个数 x1x_1x1​，x2x_2x2​（x1&lt;x2x_1 &lt; x_2x1​&lt;x2​），f(x1)×f(x2)≤0f(x_1) \\times f(x_2) \\le 0f(x1​)×f(x2​)≤0，则在 [x1,x2][x_1, x_2][x1​,x2​] 内一定存在根。 #include &lt;iostream&gt; using namespace std; double a, b, c, d; double f(double x) { return a * x * x * x + b * x * x + c * x + d; } int main() { cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; for (double i = -100; i &lt;= 99; i ++) { //处理区间 [i, i + 0.999]，避免端点被枚举2次。（利用了答案只需精确到小数点后2位） if (f(i) * f(i + 0.999) &gt; 1e-9) continue; else // [l, r]上有零点 { double l = i, r = i + 0.999; while (r - l &gt; 1e-3) { double mid = (l + r) / 2; if (f(mid) * f(l) &lt;= 1e-9) r = mid; // [l, mid]上有零点 else l = mid; // [mid, r]上有零点 } printf(&quot;%.2f &quot;, l); } } return 0; } 注意浮点数的比较方法！！！ ","link":"https://shaoyihao.github.io/blog/一元三次方程的根/"},{"title":"砍树","content":" 原题链接：砍树 题目大意： 思路：二分查找HHH的边界，使： max⁡{x1−H, 0}+max⁡{x2−H, 0}+...+max⁡{xn−H, 0}≥M\\max\\{x_1-H, \\ 0\\}+\\max\\{x_2-H, \\ 0\\}+...+\\max\\{x_n-H, \\ 0\\}\\ge M max{x1​−H, 0}+max{x2​−H, 0}+...+max{xn​−H, 0}≥M 当 HHH 过大时，总长度为小于 MMM，当 HHH 较小时，总长度又超出 MMM，因此要查找的就是左区间的右端点： #include &lt;iostream&gt; using namespace std; const int N = 1000010; int q[N], n, m; bool check(int x) //判断高度设置为x时能否得到总长度为m的木材 { long long res = 0; for (int i = 0; i &lt; n; i ++) res += max(q[i] - x, 0); if (res &gt;= m) return true; else return false; } int main() { cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i ++) cin &gt;&gt; q[i]; int l = 0, r = 1e9; while (l &lt; r) { int mid = (l + r + 1) / 2; if (check(mid)) l = mid; else r = mid - 1; } cout &lt;&lt; l; return 0; } ","link":"https://shaoyihao.github.io/blog/砍树/"},{"title":"A-B数对","content":" 原题链接：A-B数对 给出一串数以及一个数字 C，求数列中存在多少组A、B，使满足A - B = C。 思路： 与「寻找指定和的整数对」类似，思路转化为，对于数列中的每一个数 xxx，二分查找数列中是否存在 x+Cx+Cx+C。 与上题的区别在于： 上题中只需从较小的数开始处理，进行搜索另一个数，只要搜索到一个即可，问题即解决。 而此题要求的是总共满足该条件的A、B的组数，因此搜索到一组还不够，还要接着往后搜，统计次数。 对于xxx，数列中可能存在多个C−xC-xC−x，而在排过序的数组中，这些C−xC-xC−x都连在一起。因此我们只需找到C−xC-xC−x第一次出现的位置c1c_1c1​和最后一次出现的位置c2c_2c2​，则c2−c1+1c_2-c_1+1c2​−c1​+1即数组中C−xC-xC−x的个数（也就是对xxx而言，满足条件的组数）。 const int N = 200100; int q[N]; int main() { int n, m; cin &gt;&gt; n &gt;&gt; m; long long res = 0; for (int i = 0; i &lt; n; i ++) cin &gt;&gt; q[i]; sort(q, q + n); for (int i = 0; i &lt; n; i ++) { int x = q[i] + m, c1, c2; bool flag = 0; //记录是否找到x int l = i + 1, r = n - 1, mid; //对于第i个数查找的下标区间为 [i + 1, n - 1] while (l &lt; r) //二分找“右区间的左端点” { mid = (l + r) / 2; if (q[mid] &gt;= x) r = mid; else l = mid + 1; } if (q[l] == x) //第一次出现的位置 { c1 = l; flag = 1; } l = i + 1, r = n - 1; while (l &lt; r) //再次二分，找“左区间的右端点” { mid = (l + r + 1) / 2; if (q[mid] &lt;= x) l = mid; else r = mid - 1; } if (q[l] == x) c2 = l; //最后一次出现的位置 if (flag) res += c2 - c1 + 1; //加入到答案中 } cout &lt;&lt; res; return 0; } ","link":"https://shaoyihao.github.io/blog/A-B数对/"},{"title":"寻找指定和的整数对","content":" 原题链接 题目大意：给定长度为n的数组，判断其中是否有一对数的和等于给定的数targettargettarget。 思路： 判断数列中是否存在 x,yx,yx,y 满足 x+y==targetx + y == targetx+y==target，转化为：对于一个数 xxx，判断数组中是否存在 target−xtarget-xtarget−x，从而运用二分进行查找。 O(nlog⁡n)O(n\\log n)O(nlogn) #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 100010; int q[N]; int n, target; int main() { cin &gt;&gt; n; for (int i = 0; i &lt; n; i ++) cin &gt;&gt; q[i]; sort(q, q + n); //将数组进行排序 cin &gt;&gt; target; bool flag = 0; for (int i = 0; i &lt; n; i ++) { int x = target - q[i]; //查找的对象 int l = i + 1, r = n - 1, mid; //对于第i个数查找的下标区间为 [i + 1, n - 1] while (l &lt; r) //二分 { mid = (l + r) / 2; if (q[mid] &gt;= x) r = mid; else l = mid + 1; } if (q[l] == x) //判断是否找到 { flag = 1; cout &lt;&lt; q[i] &lt;&lt; ' ' &lt;&lt; x; break; } } if (!flag) cout &lt;&lt; &quot;No&quot;; return 0; } 本题还可以用双指针。 ","link":"https://shaoyihao.github.io/blog/寻找指定和的整数对/"},{"title":"二分查找","content":"二分本质上就是在一个区间中查找一个数，方式为：不断缩小查找的区间，缩小区间时根据的是：该数所满足的命题。 注意二分的区间只要包含正确答案即可，即所二分的区间不是唯一的（大一点较稳妥），根据题目而定。 例如求一个数x的平方根时，就要保证二分区间的右端点不小于x+1。因为当x = 0.01时，会出现开方后为0.1，此时就超出了区间[ 0, x ] 解题的关键思路在于弄明白： 要查找的对象是什么 查找范围是什么（估计答案的范围） 查找对象的所满足的关系式是什么，是否具有单调性，将其扩展为两个对立的命题，使查找对象处于命题的边界（该命题就是mid的check条件） 关键点往往在于：明确check(mid)函数什么时候为真，什么时候为假。 二分查找的 命题的边界值，若原数组中本就不存在所要查找的满足命题PPP的元素，则二分找到的元素就是距离最近的满足QQQ的元素。 有单调性的数列一定可以二分，没有单调性的数列也有可能可以二分。 1，整数二分 模板： int l, r, mid; while (l &lt; r) { mid = (l + r) / 2; if (check(mid)) r = mid; //r = mid与mid = (l + r) / 2 相对应 else l = mid + 1; //l比r大1 } int l, r, mid; while (l &lt; r) { mid = (l + r + 1) / 2; if (check(mid)) l = mid; //l = mid与mid = (l + r + 1) / 2 相对应 else r = mid - 1; //l比r大1 } 例题1 找出数组中某数第一次出现和最后一次出现的位置 原题链接：数的范围 #include &lt;iostream&gt; using namespace std; const int N = 100010; int q[N]; int n, m; int main() { scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot;, &amp;q[i]); while (m --) { int k; scanf(&quot;%d&quot;, &amp;k); int l = 0, r = n - 1, mid; //二分查找第一次出现的k while (l &lt; r) { mid = (l + r) / 2; if (q[mid] &gt;= k) r = mid; else l = mid + 1; } if (q[l] != k) { printf(&quot;-1 -1\\n&quot;); continue; } else printf(&quot;%d &quot;, l); l = 0, r = n - 1; //二分查找最后一次出现的k while (l &lt; r) { mid = (l + r + 1) / 2; if (q[mid] &lt;= k) l = mid; else r = mid - 1; } printf(&quot;%d\\n&quot;, l); } return 0; } 2，浮点数二分 浮点数二分就不存在边界的问题了，因此简单许多。 int l, r, mid; while (r - l &gt; 1e-8) //注意循环结束的条件，区间很小时，视作l==r //也可写为：for (int i = 0; i &lt; 100; i ++) 即不管三七二十一，直接循环100次，此时的区间长度已经非常非常小了 { mid = (l + r) / 2; if (check(mid)) l = mid; else r = mid; //直接将l换成r即可 } 例题1 求平方根 int main() { double x; scanf(&quot;%lf&quot;, &amp;x); double l = 0, r = x + 1; //确保r&gt;=1 !!!!!! while (r - l &gt; 1e-8) { double mid = (l + r) / 2; if (mid * mid &lt;= x) l = mid; else r = mid; } printf(&quot;%lf&quot;, l); return 0; } 例题2，求立方根 原题链接：数的3次方根 代码一： #include &lt;iostream&gt; using namespace std; int main() { double n; scanf(&quot;%lf&quot;, &amp;n); double l = -100, r = 100, mid; //根据数据范围估计立方根的范围，直接在该范围内搜索 for (int i = 0; i &lt; 100; i ++) //不管三七二十一，直接循环100次，此时误差也已经很小了 { mid = (l + r) / 2; if (mid * mid * mid &lt;= n) l = mid; else r = mid; } printf(&quot;%lf&quot;, l); return 0; } 代码二： int main() { double n; cin &gt;&gt; n; double l = -25, r = 25, mid; while (r - l &gt; 1e-8) { mid = (l + r) / 2; if (mid * mid * mid &lt; n) l = mid; else r = mid; } printf(&quot;%.6f&quot;, mid); return 0; } 3，lower_bound与upper_bound lower_bound 和 upper_bound 都是STL中的函数，在algorithm库中，这两个函数的原理均是二分查找。 lower_bound lower_bound 可以在区间 [l,r)[l, r)[l,r)（左闭右开）中二分查找，返回指向第一个 大于等于 x的元素位置的下标（或迭代器）。 用法： sort(q, q + n); //先排序 int pos1 = lower_bound(q, q + n, x) - q; //x为待查元素 int pos2 = lower_bound(q.begin(), q.end(), x) - q.begin(); upper_bound upper_bound 返回第一个大于x的元素的下标（或迭代器） sort(q, q + n); //先排序 int pos1 = upper_bound(q, q + n, x) - q; //x为待查元素 int pos2 = upper_bound(q.begin(), q.end(), x) - q.begin(); ","link":"https://shaoyihao.github.io/blog/二分查找/"},{"title":"拼数","content":" 原题链接：拼数 题目大意：给定 nnn 个整数，将它们联接成一排，求所能得到的最大整数。（例如13,312,34313,312,34313,312,343所能连成的最大整数就是：343312133433121334331213） 思路：本题本质上就是对这 nnn 个字符串按照某种方式进行排序，使得构成的排列所对应的整数最大。每个字符串都有其固有的“价值”：在最优的结果中，字符串越排在前面，就认为其“价值”越高。那么如何比较2个字符串的“价值”呢？ 对于数字字符串 aaa 和 bbb，定义运算符⪰\\succeq⪰：a⪰b ⟺ ab‾≥ba‾a\\succeq b\\ \\Longleftrightarrow\\ \\overline{ab}\\ge \\overline{ba}a⪰b ⟺ ab≥ba 。 可以发现：对于任意一种排列方式，只要存在相邻的两个字符串不满足 前面 ⪰\\succeq⪰ 后面，那么这种排列肯定不是最优的，因为将这2个字符串调换一下位置就会得到一个更大的整数。因此，最优的排列顺序一定满足：串1 ⪰\\succeq⪰ 串2 ⪰\\succeq⪰ ... ⪰\\succeq⪰ 串n 。 那么根据关系⪰\\succeq⪰，能否对字符串进行排序呢？这就需要证明⪰\\succeq⪰是一个全序关系。 上面这句话纯个人理解，还不敢确信。 令∣b∣|b|∣b∣为字符串bbb的长度，将字符串ab‾\\overline{ab}ab视作一个整数，则： ab‾≥ba‾⟺a×10∣b∣+b≥b×10∣a∣+a⟺ a10∣a∣−1≥b10∣b∣−1 ⟺ f(a)≥f(b) \\overline{ab}\\ge \\overline{ba}\\\\\\Longleftrightarrow a\\times 10^{|b|}+b\\ge b\\times 10^{|a|}+a\\\\\\Longleftrightarrow \\ \\ \\ \\ \\frac{a}{10^{|a|}-1}\\ge \\frac{b}{10^{|b|}-1}\\ \\ \\ \\ \\ \\\\\\Longleftrightarrow \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ f(a)\\ge f(b)\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ ab≥ba⟺a×10∣b∣+b≥b×10∣a∣+a⟺ 10∣a∣−1a​≥10∣b∣−1b​ ⟺ f(a)≥f(b) 可见，ab‾≥ba‾\\overline{ab}\\ge \\overline{ba}ab≥ba 确实反映出 aaa 的“价值”f(a)f(a)f(a)比bbb的价值要高。并且上述也可用于传递性的证明之中，若a⪰ba\\succeq ba⪰b，b⪰cb\\succeq cb⪰c，则：a⪰ca\\succeq ca⪰c 。 #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; string s[21]; bool cmp(const string &amp;a, const string &amp;b) { return (a + b &gt; b + a); } int main() { int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i ++) cin &gt;&gt; s[i]; sort(s, s + n, cmp); for (int i = 0; i &lt; n; i ++) cout &lt;&lt; s[i]; return 0; } ","link":"https://shaoyihao.github.io/blog/拼数/"},{"title":"分数线划定","content":" 原题链接：分数线划定 题目大意：从 nnn 人中选拔 mmm 人，给定 nnn 人的笔试成绩，面试分数线为第 m×150%m\\times 150\\%m×150% 名（下取整）的人的分数，输出所有进入面试的人的id和笔试成绩。 注意：由于可能出现多人分数相同的情况，因此进入面试的人数可能会大于 1.5m1.5m1.5m 。 #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; struct Score { int id; int score; }; const int N = 5010; Score q[N]; bool cmp(Score A, Score B) //分数相同时，id小的排在前面 { if (A.score != B.score) return A.score &lt; B.score; return !(A.id &lt; B.id); } int main() { int n, m; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i ++) cin &gt;&gt; q[i].id &gt;&gt; q[i].score; sort(q, q + n, cmp); int k = m * 1.5, i = 0; //q[n - k].score即面试分数线 while (q[i].score &lt; q[n - k].score) i ++; //找到起点 cout &lt;&lt; q[n - k].score &lt;&lt; ' ' &lt;&lt; n - i &lt;&lt; endl; //输出面试分数线和进入面试的人数 for (int j = n - 1; j &gt;= i; j --) //按排名输出进入面试的人的信息 cout &lt;&lt; q[j].id &lt;&lt; ' ' &lt;&lt; q[j].score &lt;&lt; endl; return 0; } ","link":"https://shaoyihao.github.io/blog/分数线划定/"},{"title":"高精度运算","content":"将大整数的每一位存入数组，数组的第0位存个位。因为如果发生进位的话，在数组的末尾添上一位较为容易。 此处A, B均为正数。 2个大整数之间的比较（字符串） bool cmp(string &amp;A, string &amp;B) // A &lt; B 时返回true （使用引用传递只是为了效率更高） { if (A.size() != B.size()) return A.size() &lt; B.size(); for (int i = 0; i &lt; (int)A.size() - 1; i ++) if (A[i] != B[i]) return A[i] &lt; B[i]; return false; } 或者直接使用字符串函数： bool cmp(char A[], char B[]) // A &lt; B 时返回true { if (strlen(A) != strlen(B)) return strlen(A) &lt; strlen(B); return strcmp(A, B) &lt; 0; } 高精度加法 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; vector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)//返回值为一个vector容器（即数组） { vector&lt;int&gt; res; int t = 0;//进位初始值为0 for (int i = 0; i &lt; A.size() || i &lt; B.size(); i ++)//但运算还未结束时，继续循环 { if (i &lt; A.size()) t += A[i]; if (i &lt; B.size()) t += B[i];//即：t = t+A[i]+B[i]，A[i]或B[i]可能不存在，因此使用if语句判断 res.push_back(t % 10);//取模后存入答案数组 t /= 10;//算出进位值：0或1 } if (t) res.push_back(1);//如果最后还进位了1，则数组需要添一位1 return res;//得到的是倒着存放着的答案（A和B本身也是倒着存着的，因此所得结果也是倒着存的） } int main() { string a, b; cin &gt;&gt; a &gt;&gt; b;//用字符串的形式读入两个高精度的数 vector&lt;int&gt; A, B;//再将高精度数存入数组 for (int i = a.size() - 1; i &gt;= 0; i --) A.push_back(a[i] - '0');//注意将字符串倒着存入数组，数组的第0位存个位，低位存低位 for (int i = b.size() - 1; i &gt;= 0; i --) B.push_back(b[i] - '0'); auto C = add(A, B);//将结果存入一个新的数组 for (int i = C.size() - 1; i &gt;= 0; i --) printf(&quot;%d&quot;, C[i]);//倒着将数组输出 return 0; } 高精度减法 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; //判断是否有： A &gt;= B bool cmp(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)//比较两个大数，（数组的比较） { if (A.size() != B.size()) return A.size() &gt; B.size(); //先通过位数判断，位数多的，该数就较大 for (int i = A.size() - 1; i &gt;= 0; i --)//从高位开始比，直到找到某一位不同为止 if (A[i] != B[i]) return A[i] &gt; B[i]; return true;//所有位均相同，即两个数组相同，大数相等 } vector&lt;int&gt; Sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B) { vector&lt;int&gt; res; int t = 0, c;//t表示借位（个位运算不会被借位，因此初始化为0） for (int i = 0; i &lt; A.size(); i ++)//A&gt;B，因此最后结果数组的位数就是A的位数 { if (i &lt; B.size()) c = A[i] - B[i] - t; else c = A[i] - t; res.push_back((c + 10) % 10); if (c &lt; 0) t = 1; else t = 0; } while (res.size() &gt; 1 &amp;&amp; res.back() == 0) res.pop_back();//去除前导0 return res; } int main() { string a, b; cin &gt;&gt; a &gt;&gt; b;//先用字符串读入大数 vector&lt;int&gt; A, B; for (int i = a.size() - 1; i &gt;= 0; i --) A.push_back(a[i] - '0');//再将大数倒着存入数组 for (int i = b.size() - 1; i &gt;= 0; i --) B.push_back(b[i] - '0'); if (cmp(A, B))//判断A是否大于B { auto C = Sub(A, B); for (int i = C.size() - 1; i &gt;= 0; i --) printf(&quot;%d&quot;, C[i]);//倒着输出 } else { auto C = Sub(B, A);//如果A&lt;B，则结果为：-（B-A) printf(&quot;-&quot;);//前面补一个负号 for (int i = C.size() - 1; i &gt;= 0; i --) printf(&quot;%d&quot;, C[i]); } return 0; } 另一种写法： vector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B) { vector&lt;int&gt; res; int t = 0; for (int i = 0; i &lt; A.size(); i ++) if (i &lt; B.size()) { res.push_back((A[i] - B[i] - t + 10) % 10); if (A[i] - B[i] - t &lt; 0) t = 1; else t = 0; } else { res.push_back((A[i] - t + 10) % 10); if (A[i] - t &lt; 0) t = 1; else t = 0; } while (res.size() &gt; 1 &amp;&amp; res.back() == 0) res.pop_back(); return res; } 高精度乘法 大数×一般数 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; vector&lt;int&gt; Mul(vector&lt;int&gt; &amp;A, int b) { vector&lt;int&gt; res; int t = 0;//进位 for (int i = 0; i &lt; A.size() || t; i ++)//在A各位还没乘完或者进位t还没有处理完时，循环继续 { if (i &lt; A.size()) t = A[i] * b + t; //在A各位还没乘完的情况 res.push_back(t % 10); t /= 10; } /*也可以这样写 for (int i = 0; i &lt; A.size(); i ++)//在A各位还没乘完的情况 { t = A[i] * b + t; res.push_back(t % 10); t /= 10; } while (t != 0) //进位t还没有处理完的情况 { res.push_back(t % 10); t /= 10; } */ while (res.size() &gt; 1 &amp;&amp; res.back() == 0) res.pop_back();//去除前导0。处理积为0的情况，若不进行处理，结果可能为0000000 return res; } int main() { string a; int b; cin &gt;&gt; a &gt;&gt; b; vector&lt;int&gt; A; for (int i = a.size() - 1; i &gt;= 0; i --) A.push_back(a[i] - '0'); auto C = Mul(A, b); for (int i = C.size() - 1; i &gt;= 0; i --) printf(&quot;%d&quot;, C[i]); return 0; } 应用：求阶乘 vector&lt;int&gt; f[N]; f[0] = vector&lt;int&gt;(1, 1); // 0! = 1 for (int i = 1; i &lt;= 1000; i ++) f[i] = mul(f[i - 1], i); 大数×大数 更一般的，整个乘法过程进行分析： 可见不考虑进位的情况下，乘数AAA的第 iii 位 与乘数BBB的第 jjj 位 的积 只对结果的第 i+j−1i+j-1i+j−1 位有贡献。若从下标0开始存储，则 A[i]×B[j]A[i]\\times B[j]A[i]×B[j] 将是 C[i+j]C[i+j]C[i+j] 的一部分，即： C[i+j]= ...+A[i]×B[j]+...C[i + j] =\\ ...+ A[i]\\times B[j]+... C[i+j]= ...+A[i]×B[j]+... (i,j)⟶C[i+j](i,j)\\longrightarrow C[i+j](i,j)⟶C[i+j]，这是一个单射关系。 for (int i = 0; i &lt; a.size(); i ++) for (int j = 0; j &lt; b.size(); j ++) C[i + j] += A[i] * B[j]; for (int i = 0; i &lt; a.size() + b.size() - 1; i ++) //从最低位开始 if (C[i] &gt; 9) { C[i + 1] += C[i] / 10; C[i] %= 10; } 由于相乘最后可能会有进位，因此 nnn 位数 和 mmm 位数相乘得到的结果可能是 n+mn+mn+m 位的。 去除前导零： int len = a.size() + b.size(); while (C[len - 1] == 0 &amp;&amp; len &gt; 1) len --; //去除前导零（最高位为0即去除） // for (int i = len - 1; i &gt;= 0; i --) cout &lt;&lt; C[i]; 倒着输出结果 完整代码： O(n2)O(n^2)O(n2) #include &lt;iostream&gt; using namespace std; const int N = 10010; int A[N], B[N], C[N]; int main() { string a, b; cin &gt;&gt; a &gt;&gt; b; for (int i = 0; i &lt; a.size(); i ++) A[i] = a[a.size() - 1 - i] - '0'; for (int i = 0; i &lt; b.size(); i ++) B[i] = b[b.size() - 1 - i] - '0'; for (int i = 0; i &lt; a.size(); i ++) for (int j = 0; j &lt; b.size(); j ++) C[i + j] += A[i] * B[j]; for (int i = 0; i &lt; a.size() + b.size() - 1; i ++) //从最低位开始 if (C[i] &gt; 9) { C[i + 1] += C[i] / 10; C[i] %= 10; } int len = a.size() + b.size(); while (C[len - 1] == 0 &amp;&amp; len &gt; 1) len --; //去除前导零（最高位为0即去除） for (int i = len - 1; i &gt;= 0; i --) cout &lt;&lt; C[i]; return 0; } 另一种写法： vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B) { vector&lt;int&gt; res = vector&lt;int&gt;(A.size() + B.size(), 0); for (int i = 0; i &lt; A.size(); i ++) for (int j = 0; j &lt; B.size(); j ++) res[i + j] += A[i] * B[j]; for (int i = 0; i &lt; A.size() + B.size() - 1; i ++) if (res[i] &gt; 9) { res[i + 1] += res[i] / 10; res[i] %= 10; } while (res.size() &gt; 1 &amp;&amp; res.back() == 0) res.pop_back(); return res; } 高精度除法 #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; vector&lt;int&gt; Div(vector&lt;int&gt; &amp;A, int b, int &amp;r)//以引用的形式传入余数，主函数中同时得到修改 { vector&lt;int&gt; res; r = 0;//余数 for (int i = A.size() - 1; i &gt;= 0; i --)//从被除数的最高位开始处理 { int c = r * 10 + A[i];//余数与子被除数的关系 res.push_back(c / b); r = c % b; } reverse(res.begin(), res.end());//由于主函数中会逆序输出，此处虽顺序是正确的，但也先配合主函数，逆序翻转一下 while (res.size() &gt; 1 &amp;&amp; res.back() == 0) res.pop_back();//去除前导0 return res; } int main() { string a; int b, r; cin &gt;&gt; a &gt;&gt; b; vector&lt;int&gt; A; for (int i = a.size() - 1; i &gt;= 0; i --) A.push_back(a[i] - '0'); auto C = Div(A, b, r); for (int i = C.size() - 1; i &gt;= 0; i --) printf(&quot;%d&quot;, C[i]); printf(&quot;\\n%d&quot;, r); return 0; } 如果不考虑与前面几种运算的配合，还可以写为： #include &lt;iostream&gt; #include &lt;deque&gt; using namespace std; deque&lt;int&gt; Div(deque&lt;int&gt; &amp;A, int b, int &amp;r) { deque&lt;int&gt; res; r = 0;//余数 for (int i = 0; i &lt; A.size(); i ++)//从被除数的最高位开始处理 { r = r * 10 + A[i];//余数与子被除数的关系 res.push_back(r / b); r %= b; } while (res.size() &gt; 1 &amp;&amp; res.front() == 0) res.pop_front(); return res; } int main() { string a; int b, r; cin &gt;&gt; a &gt;&gt; b; deque&lt;int&gt; A; for (int i = 0; i &lt; a.size(); i ++) A.push_back(a[i] - '0'); auto C = Div(A, b, r); for (int i = 0; i &lt; C.size(); i ++) printf(&quot;%d&quot;, C[i]); printf(&quot;\\n%d&quot;, r); return 0; } 压位？？？ ","link":"https://shaoyihao.github.io/blog/高精度运算/"},{"title":"结构体的排序规则","content":"在实际生活中进行排序时往往需要考虑多个关键字，体现在程序中就是2个结构体元素之间的比较规则。 当确定比较规则之后，可以直接调用sort函数对整个结构体数组进行排序。 举个例子：对于以下结构体，排序规则为： aaa越大的结构体元素越大 aaa相同时，bbb越大的结构体元素越大 a,ba,ba,b均相同时，ccc越小的结构体元素越大 struct SS { int a, b, c; }; SS s[N]; 实现方式有222种： 运算符重载 struct SS { int a, b, c; bool operator&lt;(const SS B) const //满足什么条件时 x &lt; B 为真 { if (a != B.a) return a &lt; B.a; if (b != B.b) return b &lt; B.b; return !(c &lt; B.c) } }; sort(s, s + n); cmp比较函数 bool cmp(SS A, SS B) //满足什么条件时 A &lt; B 为真，用于从小到大排序 { if (A.a != B.a) return A.a &lt; B.a; if (A.b != B.b) return A.b &lt; B.b; return !(A.c &lt; B.c); } sort(s, s + n, cmp); //从小到大排序 bool cmp(SS A, SS B) //满足什么条件时 A &gt; B 为真，用于从大到小排序 { } sort(s, s + n, cmp); //从大到小排序 需要注意的是：sort()是不稳定排序。如果要使相等的项的输出顺序与输入顺序相同，则使用sort可能会导致错误结果。解决方法有2种： 在结构体中添加一个属性id，记录输入时的顺序 使用stable_sort()，这是稳定的排序 例题1 AC代码： #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 310; struct Score { int id; int a, b, c; int sum; bool operator&lt;(const Score B) const { if (sum != B.sum) return sum &lt; B.sum; if (a != B.a) return a &lt; B.a; return !(a &lt; B.a); } }; Score s[N]; int main() { int n; cin &gt;&gt; n; for (int i = 1; i &lt;= n; i ++) { s[i].id = i; cin &gt;&gt; s[i].a &gt;&gt; s[i].b &gt;&gt; s[i].c; s[i].sum = s[i].a + s[i].b + s[i].c; } sort(s + 1, s + n + 1); //从小到大排序 for (int i = n, t = 0; t &lt; 5; t ++, i --) //输出分数最高的5名 cout &lt;&lt; s[i].id &lt;&lt; ' ' &lt;&lt; s[i].sum &lt;&lt; endl; return 0; } 例题2 #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int N = 110; struct Person { string name; int year, month, day, id; bool operator&lt;(const Person &amp;P) const { if (year != P.year) return !(year &lt; P.year); if (month != P.month) return !(month &lt; P.month); if (day != P.day) return !(day &lt; P.day); return id &lt; P.id; } }; Person q[N]; int main() { int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i ++) { cin &gt;&gt; q[i].name &gt;&gt; q[i].year &gt;&gt; q[i].month &gt;&gt; q[i].day; q[i].id = i; } sort(q, q + n); for (int i = n - 1; i &gt;= 0; i --) cout &lt;&lt; q[i].name &lt;&lt; endl; return 0; } ","link":"https://shaoyihao.github.io/blog/结构体的排序规则/"},{"title":"去重","content":"const int N = 110, M = 1001; //M为数组元素的范围 int q[N]; bool st[M]; //for (int i = 0; i &lt; n; i ++) cin &gt;&gt; q[i]; int idx = 0; for (int i = 0; i &lt; n; i ++) if (st[q[i]] == false) //之前没有出现过 { st[q[i]] = true; q[idx ++] = q[i]; } //此时idx为新数组中的元素个数（即所有不重复元素的个数），q[0, idx-1] 即所有不重复元素构成的数组。 这份代码的写法是由《算导》中快排的PartitionPartitionPartition函数的写法 启发而来。 优点在于：双指针写法，直接在原数组上进行覆盖存储，没有消耗额外空间。 STL写法 unique()是C++标准库函数里面的函数，其功能是去除相邻的重复元素（只保留一个），所以使用前需要对数组进行排序。该函数并没有将重复的元素删除，而是把重复的元素放到数组的最后。 for (int i = 0; i &lt; n; i ++) cin &gt;&gt; q[i]; sort(q, q + n); int k = unique(q, q + n) - q; //不重复部分的数组长度 for (int i = 0; i &lt; k; i ++) cout &lt;&lt; q[i] &lt;&lt; ' '; //只输出不重复部分 sort(q.begin(), q.end()); q.erase(unique(q.begin(), q.end()), q.end()); //删除重复部分 ","link":"https://shaoyihao.github.io/blog/去重/"},{"title":"计数排序","content":" 计数排序的基本思想是：对每个元素 xxx，确定数组中小于 xxx 的元素个数。利用这一信息，就可以直接把 xxx 放到它在输出数组中的位置上了。例如：如果有17个元素小于 xxx，则 xxx 就应该在第18个位置上。（当有几个元素相同时，这一方案要略做修改，因为不能把它们放在同一个输出位置上。） 具体步骤为： 统计每个元素在数组中的个数 for (int i = 0; i &lt; n; i ++) { cin &gt;&gt; q[i]; C[q[i]] ++; } 计算前缀和 for (int x = 1; x &lt;= W; x ++) C[x] += C[x - 1]; 此时 C[x]C[x]C[x] 即数组中 ≤x\\le x≤x 的元素的个数，C[x−1]C[x-1]C[x−1] 即数组中 &lt;x&lt;x&lt;x 的元素的个数。 得出排序结果 若排序后的结果数组从下标111开始存储，则对于元素 xxx ，下标区间C[x-1]+1 ~ C[x]存储的应都是xxx。也就是说，可以直接将 xxx 放到结果数组中的相应位置。 //倒序是为了保证排序的稳定性：原数组里面相同项相对位置不变，原来在后面的还在后面 for (int i = n - 1; i &gt;= 0; i ++) //倒序枚举每个元素 res[C[q[i]] --] = q[i]; //直接放入相应位置 for (int i = 1; i &lt;= n; i ++) cout &lt;&lt; res[i] &lt;&lt; ' '; //从下标1开始存储 如果所有 nnn 个元素都是互异的，那么对 x=q[i]x=q[i]x=q[i] 来说，C[x]C[x]C[x] 就是它在输出数组中的最终正确位置。然而因为数组中元素可能多次出现，所以每将一个值 x=q[i]x=q[i]x=q[i] 放入结果数组中后，都要将 C[x]C[x]C[x] 减 1。这样当遇到下一个xxx时，该元素可以直接被放到输出数组中xxx的前一个位置上。 若结果数组从下标0开始存储，则可以写为： for (int i = n - 1; i &gt;= 0; i --) res[-- C[q[i]]] = q[i]; for (int i = 0; i &lt; n; i ++) cout &lt;&lt; res[i] &lt;&lt; ' '; //从下标0开始存储 完整代码： for (int i = 0; i &lt; n; i ++) { cin &gt;&gt; q[i]; C[q[i]] ++; } for (int x = 1; x &lt;= W; x ++) C[x] += C[x - 1]; for (int i = n - 1; i &gt;= 0; i --) res[C[q[i]] --] = q[i]; for (int i = 1; i &lt;= n; i ++) cout &lt;&lt; res[i] &lt;&lt; ' '; 另一种写法 开辟一个新数组 C[k]，其中 C[x]C[x]C[x] 为 xxx 在 AAA 中出现的次数。 从小到大枚举0→w0\\rightarrow w0→w，输出 C[x]C[x]C[x] 次 xxx 。 for (int i = 0; i &lt; n; i ++) { cin &gt;&gt; q[i]; C[q[i]] ++; } int idx = 0; //结果数组从下标0开始存储 for (int x = 0; x &lt;= W; x ++) //遍历每个数 while (C[x] --) res [idx ++] = x; for (int i = 0; i &lt; n; i ++) cout &lt;&lt; res[i] &lt;&lt; ' '; 这种写法可能更容易理解，但不具有排序稳定性。 效率分析 影响排序效率的因素是：数组元素的范围www、数组元素的个数nnn。 时间复杂度为：Θ(w+n)\\Theta(w+n)Θ(w+n) ，特别的，当 w=O(n)w=O(n)w=O(n) 时，时间复杂度为：Θ(n)\\Theta(n)Θ(n) 。因此计数排序是一个线性时间排序算法。 计数排序不是比较排序，因此不被 Ω(nlog⁡n)\\Omega(n\\log n)Ω(nlogn) 的下界限制。 当 w=O(n)w=O(n)w=O(n) 时，应优先考虑该排序算法。 由于用来计数的数组 CCC 的长度取决于待排数组中数据的范围（Max−Min+1Max-Min+1Max−Min+1)，这使得计数排序对于数据范围很大的数组，需要大量内存。 空间复杂度为：Θ(w+n)\\Theta(w+n)Θ(w+n)。 ","link":"https://shaoyihao.github.io/blog/计数排序/"},{"title":"一些O(n²)的排序方式","content":"选择排序 void selection_sort(int q[], int n) { for (int i = 0; i &lt; n - 1 ; i ++) { int min = i; for (int j = i + 1; j &lt; n; j ++) if (q[j] &lt; q[min]) min = j;//找到最小元素的下标 swap(q[min], q[i]);//将最小元素与最前面的元素交换，没有引入额外空间 } } 插入排序 插入排序就是打扑克，需要将牌一张张抽出来，分别插入到前面已经排好序的牌中的适当位置，重复这一操作，直到插入最后一张牌。 void InsertSort(int num[], int n) //含n个元素的数组（从下标0开始存储），升序排序 { for (int i = 1; i &lt; n; i ++) //从第二个元素开始排序，因为一个元素默认有序 { int temp = num[i], j = i - 1;// j指向所处理的牌的前一张牌。 [0 ~ j]之间的元素已有序 while (j &gt;= 0 &amp;&amp; num[j] &gt; temp) //在[0 ~ j]中寻找适当位置以插入temp （第i个位置相当于为空，可供前面的牌后移时移入） { // 进行插入的两种条件：遇到了比x小的数、只能插在数组最前面 num[j + 1] = num[j]; //后移 j --; } num[j + 1] = temp; //找到适当位置后，将temp插入到该位置 } //每一次插入结束后，都保证了前面一部分的数是有序的 } 插入排序法是稳定的。 最坏的情况下，每个iii循环都需要执行iii次移动，总共需要：1+2+...+n−1=n(n−1)21+2+...+n-1 = \\frac{n(n-1)}{2}1+2+...+n−1=2n(n−1)​，因此时间复杂度为O(n2)O(n^2)O(n2). 插入排序法能快速处理相对有序的数据。最好情况下，时间复杂度为O(n)O(n)O(n). 虽然归并排序的时间复杂度为O(nlg⁡n)O(n\\lg n)O(nlgn), 而插入排序的时间复杂度为O(n2)O(n^2)O(n2)， 但是插人排序中的常量因子较小，因此在nnn较小时，实际运行得更快。 冒泡排序 含有nnn个元素的数组，进行冒泡排序共比较n−1n-1n−1趟。 每趟都从首元素开始比较，第111趟比较n−1n-1n−1次（操作nnn个元素），第iii趟比较n−in-in−i次（操作n−i+1n-i+1n−i+1个元素），第n−1n-1n−1趟比较111次（操作222个元素）。每趟比较得到的效果就是：将这（前）n−i+1n-i+1n−i+1个元素中的最值移到第n−i+1n-i+1n−i+1位（最后）。 发生交换的总次数等于该数组中的 逆序对的数目。 void BubbleSort(SeqList &amp;L) { for (int i = 1; i &lt;= L.length - 1; i ++)//总共比较n-1趟 for (int j = 1; j &lt;= L.length - i; j ++)//每趟都从首元素开始比较，第i趟比较n-i次 if (L.data[j].key &gt; L.data[j + 1].key) swap(L.data[j], L.data[j + 1]); } void bubbleSort() { for (int i = 0; i &lt; n - 1; i ++) for (int j = 0; j &lt; n - 1 - i; j ++) if (q[j] &gt; q[j + 1]) swap(q[j], q[j + 1]); } 设一个数组的逆序对数目为kkk。一个排好序的数组的逆序对数目为000。 若算法所能进行的操作只有：交换2个相邻元素，由于交换2个相邻元素最多使逆序对数目-1，则要想使数组排好序，需要进行的交换次数为 ≥k\\ge k≥k。 而冒泡排序每次交换都会使 逆序对的数目−1-1−1，因此冒泡排序中只需进行kkk次交换即可使数组有序。 可见，在操作为交换相邻2元素的排序算法中，冒泡排序是交换次数最少的算法。 数组的逆序数之和等于通过交换相邻两数把数列变为有序的最小步数。 因此冒泡排序的思路也为我们提供了一种求逆序数的方法： int cnt = 0; for (int i = 0; i &lt; n - 1; i ++) for (int j = 0; j &lt; n - 1 - i; j ++) if (q[j] &gt; q[j + 1]) cnt ++; 例题 不过这种方法的时间复杂度较高O(n2)O(n^2)O(n2)。 此处在对数组进行排序时一定要使用稳定的排序算法，否则不稳定的排序算法可能会改变相同元素的相对位置，导致计算逆序数的时候出现错误！ ","link":"https://shaoyihao.github.io/blog/一些O(n²)的排序方法/"},{"title":"逆序对的数目","content":"对分治思想的深入理解： 分治思想就是将问题拆分为若干个子问题，分开解决各个子问题，再将各子问题的结果进行合并，从而得到总问题的结果。在解决子问题的过程中，通常需要进行递归的处理。 而进行递归的关键是： 当子问题简化到最简情况时，结果应是已知的、显而易见的，如此将其作为递归的出口 总问题结果与子问题结果之间具有递推关系 譬如： 在归并排序中，当子列中只有一个元素时，已经有序，因此可将if (l == r) return;作为递归的出口。 而当两子列有序时，只需基于此，再进行两个有序子列的合并，即可使整个数列有序。因此该算法具有q = f(q1, q2)的递推关系。 求逆序数也是同理，当数列中只有一个元素时，逆序数就是0，因此可将if (l == r) return 0;作为出口。 将两子列的逆序数求出后，只需求出a在q1中，而b在q2中这种情况的逆序数cnt3，即可得到整个数列的逆序数：cnt = cnt1 + cnt2 + cnt3。 逆序对的定义：对于数列的第 i 个和第 j 个元素，如果满足 i&lt;ji&lt;ji&lt;j 且 a[i]&gt;a[j]a[i]&gt;a[j]a[i]&gt;a[j]，则其为一个逆序对；否则不是。（即：前面的数比后面的数大） 本题用到了将两个有序数组进行归并时的单调性，i,ji,ji,j所指的元素分别是对应子数组当前的最值。 子数组s1s_1s1​中大于jjj所指元素 的元素有：S[i∼mid]S[i\\sim mid]S[i∼mid]，个数为：mid−i+1mid - i + 1mid−i+1。 #include &lt;iostream&gt; using namespace std; typedef long long LL; const int N = 1e6 + 10; int q[N], tmp[N]; int n; LL merge(int l, int r) { if (l &gt;= r) return 0; int mid = (l + r) / 2; LL res = merge(l, mid) + merge(mid + 1, r);//第1类和第2类的逆序数 int i = l, j = mid + 1, k = 0; while (i &lt;= mid &amp;&amp; j &lt;= r) { if (q[i] &lt;= q[j]) tmp[k ++] = q[i ++]; else//此时为q[i]&gt;q[j]的情况，即存在第3类逆序数的情况 { tmp[k ++] = q[j ++]; res += mid - i + 1;//加上第3类情况的逆序数 } } while (i &lt;= mid) tmp[k ++] = q[i ++]; while (j &lt;= r) tmp[k ++] = q[j ++]; for (int i = l, k = 0; i &lt;= r; i ++, k ++) q[i] = tmp[k]; return res; } int main() { scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot;, &amp;q[i]); printf(&quot;%lld&quot;, merge(0, n - 1)); return 0; } 为什么while (i &lt;= mid &amp;&amp; j &lt;= r)循环结束之后就不再考虑逆序对的变化了呢？ 答：当该循环结束之后，也就是222堆牌中有一堆已经被合并完，不论是哪一堆剩下，此时对逆序对的数目都不再有影响。不妨记下标较小的那一堆为AAA，下标较大的那一堆为BBB。 如果是AAA有剩余，注意我们考虑的是对于BBB中的每个元素xxx，AAA中有多少个元素比它大。此时既然BBB中元素已全部处理完，那么最终答案也就得到了。AAA中所剩元素所产生的逆序数之前其实都已经被计入过。 如果是BBB有剩余，也就意味着这几个元素是最大的，AAA中不存在比这些更大的元素，因此不会产生逆序对。 ","link":"https://shaoyihao.github.io/blog/逆序对的数目/"},{"title":"归并排序的非递归实现","content":"已知一个含有nnn个元素的数组qqq。 基本思路： 首先取每个子列的长度为111，则qqq可以划分为nnn个子列。 由于每个子列的长度为1，因此每个子列都是有序的。 遍历数组，将子列①,②①,②①,②进行合并，将子列③,④③,④③,④进行合并...，合并后每个子列都是 长度≤2长度\\le2长度≤2 的有序数列。 合并：将两个有序数列合并为一个有序数列。 再取每个子列的长度为222，则qqq可以划分为⌈n2⌉\\lceil\\frac{n}{2}\\rceil⌈2n​⌉个有序子列。 遍历数组，将子列①′,②′①&#x27;,②&#x27;①′,②′进行合并，将子列③′,④′③&#x27;,④&#x27;③′,④′进行合并...，合并后每个子列都是 长度≤4长度\\le4长度≤4 的有序数列。 再取每个子列的长度为444... 以此类推下去。 void mergeSort(int q[], int n) //将含有n个元素的数组q进行归并排序 { for (int seglength = 1; seglength &lt;= n; seglength *= 2) //从小到大以2^i枚举 子列长度 for (int st = 0; st + seglength &lt; n; st += seglength * 2) //若存在连续的2个子列，就合并这两个子列。st是子列1的起始下标，st+seglength是子列2的起始下标，st+2*seglength是子列2的结束下标 merge(q, st, st + seglength - 1, min(st + 2 * seglength - 1, n - 1)); } void merge(int q[], int l, int mid, int r) //将数组q的两有序子列q[l, mid]和q[mid+1, r]进行合并 { int tmp[r - l + 1]; int i = l, j = mid + 1, k = 0; while (i &lt;= mid &amp;&amp; j &lt;= r) { if (q[i] &lt;= q[j]) tmp[k ++] = q[i ++]; else tmp[k ++] = q[j ++]; } while (i &lt;= mid) tmp[k ++] = q[i ++]; while (j &lt;= r) tmp[k ++] = q[j ++]; for (int i = l, k = 0; i &lt;= r; i ++, k ++) q[i] = tmp[k]; } ","link":"https://shaoyihao.github.io/blog/归并排序的非递归实现/"},{"title":"归并排序","content":"归并排序的主要思想也是分治，基本问题为：两个有序数组的合并。 主要步骤： 以数组中心（下标的中心）为分界点：mid=l+r2mid = \\frac {l+r} {2}mid=2l+r​ 递归排序左边与右边 归并，将两个有序的数组合并为一个有序的数组 #include &lt;iostream&gt; using namespace std; const int N = 1e6 +10; int n; int q[N], tmp[N];//需要另外开一个数组暂时存放正确顺序的数列 void merge_sort(int q[], int l, int r) { if (l &gt;= r) return;//递归的结束条件：子数组中只含一个元素或者不含元素时，递归到底了 int mid = (l + r) / 2;//取数组中点为界限，分为左右两段 merge_sort(q, l, mid), merge_sort(q, mid + 1, r);//对左右两段进行归并排序 （先递归） //此时q[l ~ mid]、q[mid+1 ~ r]均为有序数组 //将已经排好序的两段合在一起 int i = l, j = mid + 1, k = 0; //i、j分别指向两个子数列的首端（也是各自数列中的最小值） while (i &lt;= mid &amp;&amp; j &lt;= r) //两个指针都还没到各自的结尾时 { //两个指针所指的数，分别是各自子数组里的最小值，因此这两个数中的最小值即是剩下的数中的最小值 if (q[i] &lt;= q[j]) tmp[k ++] = q[i ++];//将这两个数中的较小值（即剩下的数中的最小值）存入tmp数组 else tmp[k ++] = q[j ++]; } //循环结束，说明至少有一个指针已经到了尽头，则另一个数组中剩下的数就是最大的几个数，直接将剩下的数按顺序接到tmp中即可 while (i &lt;= mid) tmp[k ++] = q[i ++]; while (j &lt;= r) tmp[k ++] = q[j ++]; //将tmp[0 ~ k]复制到q[l ~ r]，使q[l~r]有序 for (i = l, k = 0; i &lt;= r; i ++, k ++) q[i] = tmp[k]; } int main() { scanf(&quot;%d&quot;, &amp;n); int q[n]; for (int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot;, &amp;q[i]); merge_sort(q, 0, n - 1);//调用归并排序函数，传入的是数组的下标区间 [0, n-1] for (int i = 0; i &lt; n; i ++) printf(&quot;%d &quot;, q[i]); return 0; } 归并排序的非递归实现 ","link":"https://shaoyihao.github.io/blog/归并排序/"},{"title":"快速选择","content":"求第k小的数 最坏情形时间复杂度为：O(n2)O(n^2)O(n2)，绝大部分情况下是O(n)O(n)O(n)的。 #include &lt;iostream&gt; using namespace std; const int N = 100010; int q[N]; int quick_search(int l, int r, int k) { if (l == r) return q[l];//区间中只有一个元素，又所查找的数就在该区间内，因此所查找的数就是该数。 int x = q[l], i = l - 1, j = r + 1; while (i &lt; j) {//不用do-while的写法 while (q[++ i] &lt; x); while (q[-- j] &gt; x); if (i &lt; j) swap(q[i], q[j]); } int sl = j - l + 1; //左部分区间的数的个数 if (k &lt;= sl) return quick_search(l, j, k); //继续在左部分区间内找第k小的数 else return quick_search(j + 1, r, k - sl); //在右部分区间找，不过对于由部分区间而言，找的是第（k - sl）小的数 } int main() { int n, k; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for (int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot;, &amp;q[i]); cout &lt;&lt; quick_search(0, n - 1, k); return 0; } 另一种思路 令每个元素起始时（乱序）时的下标为aia_iai​，有序时的下标为AiA_iAi​，由于快排基本不需要用到辅助空间，整个排序过程基本可以视为一个数组在原地不断进行元素之间的交换，使得整体上每个元素越来越接近它最终的位置AiA_iAi​。 每一层递归实际上就是使得部分元素离最终位置更近一分，不妨称这个过程为“归位”。 因此，如果我们想要找到第kkk小的数，也就是：找到最终会落在下标k−1k-1k−1的那个元素，我们只需要每次只对包含下标k−1k-1k−1的区间进行“归位”，直到区间中只有一个元素：即最终会落在k−1k-1k−1的元素，即第kkk小的元素。 关键在于：不断地对区间进行选择。 int k; int f(int q[], int l, int r) //返回最终下标为k-1的数 { if (l == r) return q[l]; //此时必有一个元素已经落在了最终位置，又由于过程中一直在对区间进行选择，所以这个落在最终位置的元素就是我们要找的落在下标k-1的元素。 //等价于：if (l == k - 1 &amp;&amp; r == k - 1) return q[k - 1]; int i = l - 1, j = r + 1, x = q[l + r &gt;&gt; 1]; while (i &lt; j) { do i ++; while (q[i] &lt; x); do j --; while (q[j] &gt; x); if (i &lt; j) swap(q[i], q[j]); } //将区间分为左、右两部分[l, j]和[j+1, r] if (j &gt;= k - 1) return f(q, l, j); //下标k-1在左边区间 else return f(q, j + 1, r); //在右边区间 } int main() { int n; cin &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; n; i ++) cin &gt;&gt; q[i]; cout &lt;&lt; f(q, 0, n - 1); return 0; } nth_element函数 STL中有一个函数：nth_element，它的用法是： nth_element(q+x, q+x+k, q+x+len); 它会将数组q的子数组q[x ~ x+len-1]进行重排：下标[x ~ x+k-1]的元素都小于q[x+k]，下标[x+k+1 ~ x+len-1]的元素都大于q[x+k]，但不保证数组有序。 此时q[x+k]就是子数组q[x ~ x+len]中第kkk小的元素（最小为第000小）。 //本题中最小为第1小 for (int i = 0; i &lt; n; i ++) cin &gt;&gt; q[i]; nth_element(q, q + k - 1, q + n); cout &lt;&lt; q[k - 1]; ","link":"https://shaoyihao.github.io/blog/快速选择/"},{"title":"快速排序与归并排序","content":"快速排序 快速排序的平均时间复杂度为O(nlg⁡n)O(n\\lg n)O(nlgn)，且其中隐含的常数因子非常小；最坏条件下的时间复杂度为O(n2)O(n^2)O(n2)。 快速排序是基于 分治 的思想： 分解：数组A[l∼r]A[l\\sim r]A[l∼r]被划分为3部分：两个(可能为空)子数组A[l ∼ k−1]A[l\\ \\sim\\ k-1]A[l ∼ k−1]、A[k+1 ∼ r]A[k+1\\ \\sim\\ r]A[k+1 ∼ r]，和A[k]A[k]A[k]。 满足A[l ∼ k−1]A[l\\ \\sim\\ k-1]A[l ∼ k−1]中的每一个元素都小于等于A[k]A[k]A[k], 而A[k]A[k]A[k]也小于等于A[k+1 ∼ r]A[k+1\\ \\sim\\ r]A[k+1 ∼ r]中的每个元素。 max⁡{A[l ∼ k−1]}≤A[k]≤min⁡{A[k+1 ∼ r]}\\max\\{A[l\\ \\sim\\ k-1]\\}\\le A[k]\\le \\min\\{A[k+1\\ \\sim\\ r]\\} max{A[l ∼ k−1]}≤A[k]≤min{A[k+1 ∼ r]} 其中，计算下标kkk也是划分过程的一部分。 解决：通过递归调用快速排序，对子数组A[l ∼ k−1]A[l\\ \\sim\\ k-1]A[l ∼ k−1]和A[k+1 ∼ r]A[k+1\\ \\sim\\ r]A[k+1 ∼ r]进行排序。 合并：因为子数组都是原址排序的，所以不需要合并操作：数组A[l∼r]A[l\\sim r]A[l∼r]已经有序。 def Quicksort(q, l, r): if l &lt; r: k = Partition(q, l, r) //计算k的位置 Quicksort(q, l, k - 1) Quicksort(q, k + 1, r) 其中的关键过程是PartitionPartitionPartition，它实现了对数组的原址重排，时间复杂度为：Θ(n)\\Theta(n)Θ(n)。 def Partition(q, l, r): x = q[r] i = l - 1 for j = l to r - 1: if q[j] &lt;= x: swap(q[++ i], q[j]) swap(q[i + 1], q[r]) //将主元置于2段中间（将主元与最左的大于x的元素进行交换） return i + 1 在Partition的运行过程中，始终满足的性质有： 下标区间[l,i][l, i][l,i]上的元素均 ≤x\\le x≤x 下标区间[i+1,j−1][i +1,j-1][i+1,j−1]上的元素均 &gt;x&gt; x&gt;x 算法正确性的证明： 初始步：在循环的第一轮迭代开始之前， i=l−1i=l-1i=l−1和j=lj=lj=l。因为此时在lll和iii之间、 i+1i+1i+1和j−1j-1j−1之间都不存在值，所以循环不变量显然都满足。 归纳步： q[j]&gt;xq[j]&gt;xq[j]&gt;x时，循环体的唯一操作是：将jjj的值加111。在jjj值增加后，有q[j−1]&gt;xq[j-1]&gt;xq[j−1]&gt;x，且所有其他项都保持不变。 q[j]≤xq[j]\\le xq[j]≤x时，循环体进行的操作是：将iii的值加111，交换q[i],q[j]q[i],q[j]q[i],q[j]，再将jjj的值加111。因为进行了交换，此时有q[i]≤xq[i]\\le xq[i]≤x。而原本q[i]q[i]q[i]的值是大于xxx的，交换到q[j−1]q[j-1]q[j−1]中后，有q[j−1]&gt;xq[j-1]&gt;xq[j−1]&gt;x。 因此循环不变量仍成立。 终止步：当终止时，j=rj=rj=r，此时q[l∼r−1]q[l\\sim r-1]q[l∼r−1]中每个元素都必然属于循环不变量所描述的2个集合中的一个。 即：算法已经将数组中的所有元素划分成了三个集合：包含了所有小于等于xxx的元素的集合、包含了所有大于xxx的元素的集合和只有一个元素xxx的集合。 性能分析 最坏情况即：划分产生的2个子问题分别包含n−1n-1n−1个元素和000个元素。若每次划分都是这样的最坏情况（即数组已基本有序），有： T(n)=T(n−1)+Θ(n)T(n)=T(n-1)+\\Theta(n) T(n)=T(n−1)+Θ(n) 此时快速排序的时间复杂度为：Θ(n2)\\Theta(n^2)Θ(n2)。而此时若采用插入排序的时间复杂度为：O(n)O(n)O(n)。 最好情况下，每次划分出的2个子问题的规模基本相同（⌊n2⌋\\lfloor\\frac{n}{2}\\rfloor⌊2n​⌋和⌈n2⌉−1\\lceil\\frac{n}{2}\\rceil-1⌈2n​⌉−1），有： T(n)=2T(n2)+Θ(n)T(n)=2T(\\frac{n}{2})+\\Theta(n) T(n)=2T(2n​)+Θ(n) 此时快速排序的时间复杂度为：Θ(nlog⁡n)\\Theta(n\\log n)Θ(nlogn)。 一般情形下，快速排序的运行时间都接近于最好情况，而非最坏情况。 例如：假设划分算法总是产生 9 : 1 的划分，乍一看，这种划分是很不平衡的。此时有： T(n)=T(910n)+T(110n)+Θ(n)T(n)=T(\\frac{9}{10}n)+T(\\frac{1}{10}n)+\\Theta(n) T(n)=T(109​n)+T(101​n)+Θ(n) 递归树的高度最高为： (910)hn=1 ⟹ h=log⁡9101n=log⁡109n=Θ(log⁡n)(\\frac{9}{10})^hn=1\\ \\Longrightarrow\\ h=\\log_{\\frac{9}{10}}\\frac{1}{n}=\\log_{\\frac{10}{9}}n=\\Theta(\\log n) (109​)hn=1 ⟹ h=log109​​n1​=log910​​n=Θ(logn) 每层的代价为O(n)O(n)O(n)，因此整个递归树的代价为：O(nlog⁡n)O(n\\log n)O(nlogn)。 即使是99:1这种看似很不均衡的划分方式，时间复杂度仍是O(nlog⁡n)O(n\\log n)O(nlogn)。 只要划分是常数比例，产生的递归树的高度都是Θ(log⁡n)\\Theta(\\log n)Θ(logn)，其中每一层的时间代价都是O(n)O(n)O(n)，因此算法的运行时间都是O(nlog⁡n)O(n\\log n)O(nlogn)。 随机化 有时我们可以通过在算法中引入随机性，从而使得算法对于所有的输入都能获得较好的期望性能。常用的的方法是随机抽样（random sampling）。 与始终采用q[r]q[r]q[r]作为主元的方法不同，随机抽样是从数组q[l∼r]q[l\\sim r]q[l∼r]中随机选择一个元素作为主元。 因为主元元素是随机选取的，我们期望在平均情况下，对输入数组的划分是比较均衡的。 def Randomized_Partition(q, l, r): i = random(l, r) swap(q[i], q[r]) return Partition(q, l, r) 归并排序 归井排序算法完全遵循分治模式。直观上其操作如下： 分解：将待排序的nnn个元素的序列分解成各具n2\\frac{n}{2}2n​个元素的两个子序列。 解决：使用归并排序递归地排序两个子序列。 合井：合并两个已排序的子序列。 以玩扑克牌为例，假设桌上有两堆牌面朝上的牌，每堆都已排序，最小的牌在顶上。我们希望把这两堆牌有序合并成一堆。 我们的基本步骤是：从两堆牌的顶上两张牌中选取较小的一张，将该牌从其堆中移走（该堆的顶上将显露一张新牌），放置到输出堆。重复这个步骤，直到一个输入堆为空，这时，我们只需要将剩余堆中的牌都放置到输出堆即可。 因为我们只是比较顶上的两张牌，所以计算上每个基本步骤都只需要常量时间。因为我们最多执行nnn个基本步骤，所以合并需要Θ(n)\\Theta(n)Θ(n)的时间。 归并操作的具体实现： 由子数组q[l∼r]q[l\\sim r]q[l∼r]生成两个数组 L=q[l∼t], R=q[t+1,r]L=q[l\\sim t],\\ \\ R=q[t+1,r]L=q[l∼t], R=q[t+1,r] 在L,RL,RL,R的末尾均添加元素∞\\infin∞（作为哨兵） 对L,RL,RL,R进行归并，再覆盖存入q[l∼r]q[l\\sim r]q[l∼r]中 def Merge(q, l, t, r): L = q[l : t] R = q[t + 1 : r] L.append(INF) R.append(INF) i = 0, j = 0 for (int k = l; k &lt;= r; k ++) if (L[i] &lt;= R[j]) q[k] = L[i ++] else q[k] = R[j ++] 循环不变量为：在for循环的每次迭代前，子数组q[l∼k−1]q[l\\sim k-1]q[l∼k−1]按从小到大顺序包含L,RL,RL,R中最小的k−lk-lk−l个数。L[i]L[i]L[i]和R[j]R[j]R[j]是各自数组中未被复制回qqq中的最小元素。 算法正确性的证明： 初始步：循环的第一次迭代之前，有k=lk=lk=l，子数组q[l∼k−1]q[l\\sim k-1]q[l∼k−1]为空。显然这个空的子数组包含LLL和RRR的k−l=0k-l=0k−l=0个最小元素。又因为i=j=li=j=li=j=l，所以L[i]L[i]L[i]和R[j]R[j]R[j]都是各自所在数组中未被复制回数组 A 的最小元素。 归纳步：若L[i]≤R[j]L[i]\\le R[j]L[i]≤R[j]，则L[i]L[i]L[i]是当前未被复制回qqq的最小元素。因为q[l∼k−1]q[l\\sim k-1]q[l∼k−1]包含k−lk-lk−l个最小元素，所以将L[i]L[i]L[i]存入q[k]q[k]q[k]后，q[l∼k]q[l\\sim k]q[l∼k]将包含k−l+1k-l+1k−l+1个最小元素。之后再增加k,ik,ik,i的值，为下次迭代维护了该循环不变量。 若L[i]&gt;R[j]L[i]&gt;R[j]L[i]&gt;R[j]，同理循环不变量也可得到维护。 终止步：终止时k=r+1k=r+1k=r+1，根据循环不变量，此时q[l,k−1]q[l,k-1]q[l,k−1]中按从小到大的顺序包含LLL和RRR中的k−l=r−l+1k-l=r-l+1k−l=r−l+1个最小元素。又L,RL,RL,R总共有r−l+3r-l+3r−l+3个元素，其中最大的两个元素为∞\\infin∞。因此除两个最大的元素∞\\infin∞外，其他所有元素都已被复制回数组qqq。 归并排序的整个过程为： def MergeSort(q, l, r) { if (l &lt; r): t = (l + r) / 2 MergeSort(q, l, t) MergeSort(q, t + 1, r) Merge(q, l, t, r) } T(n)=2T(n2)+Θ(n)T(n)=2T(\\frac{n}{2})+\\Theta(n) T(n)=2T(2n​)+Θ(n) 因此时间复杂度为：Θ(nlog⁡n)\\Theta(n\\log n)Θ(nlogn)。 ","link":"https://shaoyihao.github.io/blog/快排and归并/"},{"title":"分形图","content":" 原题链接：南蛮图腾 题目大意：已知 n=1n=1n=1时： /\\ /__\\ n=2n=2n=2时： /\\ /__\\ /\\ /\\ /__\\/__\\ n=3n=3n=3时： /\\ /__\\ /\\ /\\ /__\\/__\\ /\\ /\\ /__\\ /__\\ /\\ /\\ /\\ /\\ /__\\/__\\/__\\/__\\ 以此类推，输出规模为 nnn 的图形。 思路：已知初始时 n=1n=1n=1 的图形： a[1][2] = a[2][1] = '/'; a[1][3] = a[2][4] = '\\\\'; //转义 a[2][2] = a[2][3] = '_'; 容易发现，规模为 n+1n+1n+1 的图形可以由规模为 nnn 的图形得到： 经过这一番扩展后，图形的宽、高均扩大为原来的 222 倍。 for (int i = 1; i &lt;= h; i ++) for (int j = 1; j &lt;= w; j ++) a[i + h][j] = a[i + h][j + w] = a[i][j]; //向下重复2次 for (int i = 1; i &lt;= h; i ++) for (int j = w; j &gt;= 1; j --) { a[i][j + w / 2] = a[i][j]; //向右平移半宽 a[i][j] = ' '; //平移后，原位置就置空 } w *= 2, h *= 2; //更新宽、高 由规模为 111 的图形，只需重复以上操作 kkk 次，就能得到规模为 1+k1+k1+k 的分形图。 #include &lt;iostream&gt; #include &lt;cstring&gt; using namespace std; char a[3000][3000]; int main() { int n; cin &gt;&gt; n; memset(a, ' ', sizeof(a)); //初始时全部置为空格 a[1][2] = a[2][1] = '/'; a[1][3] = a[2][4] = '\\\\'; //转义 a[2][2] = a[2][3] = '_'; int h = 2, w = 4; //初始时的高、宽 for (int t = 1; t &lt; n; t ++) //重复进行n-1次该操作 { for (int i = 1; i &lt;= h; i ++) for (int j = 1; j &lt;= w; j ++) a[i + h][j] = a[i + h][j + w] = a[i][j]; for (int i = 1; i &lt;= h; i ++) for (int j = w; j &gt;= 1; j --) { a[i][j + w / 2] = a[i][j]; a[i][j] = ' '; } w *= 2, h *= 2; } for (int i = 1; i &lt;= h; i ++) { for (int j = 1; j &lt;= w; j ++) cout &lt;&lt; a[i][j]; puts(&quot;&quot;); } return 0; } ","link":"https://shaoyihao.github.io/blog/分形图/"},{"title":"快速排序","content":"快排的主要思想——分治 主要步骤： 确定分界点x：q[lll]、q[rrr]、q[l+r2\\frac {l+r} {2}2l+r​]、或随机一点 将数组分为两段，使小于等于xxx的项在左侧，大于等于xxx的项在右侧 递归处理左右两段 由于是先移动后判断，因此iii指针停止移动就说明：iii当前情况下所指向的数≥x≥x≥x；jjj指针停止移动就说明：jjj当前情况下所指的数≤x≤x≤x 。 第一轮迭代时，iii左侧的元素都小于xxx，jjj右侧的元素都大于xxx，然后进行第一次交换。 由于可能此时q[i]=q[j]=xq[i]=q[j]=xq[i]=q[j]=x，因此交换之后，iii左侧的元素全部≤x≤x≤x，jjj右侧的元素全部≥x≥x≥x，此后也将一直保持着这种性质。 迭代到最后的情形是j=ij=ij=i或j=i−1j=i-1j=i−1。此时数列[l,j][l, j][l,j]中所有元素都≤x\\le x≤x，[j+1,r][j+1, r][j+1,r]中所有元素都≥x\\ge x≥x，即max⁡{q1}≤min⁡{q2}\\max\\{q1\\} ≤\\min\\{q2\\}max{q1}≤min{q2}，整个数列分为了较小和较大的两块。 注意：xxx不一定处于两段相接的那个点。 再分别处理下标区间为[l,j][l, j][l,j]和[j+1,r][j+1, r][j+1,r]的子数列即可（也可以是[l,i−1][l, i-1][l,i−1]和[i,r][i, r][i,r]）。递归到最后的子数列就是一个数或者没有数，此时就递归到了底，结束。 最坏情形的时间复杂度为：O(n2)O(n^2)O(n2)，绝大部分情况下都是 O(nlog⁡n)O(n\\log n)O(nlogn)的。 #include &lt;iostream&gt; using namespace std; const int N = 1e6 +10; int n; int q[N]; void quick_sort(int q[], int l, int r) { if (l &gt;= r) return; int x = q[l + r &gt;&gt; 2];//基准值 int i = l - 1, j = r + 1;//先往中间移动再进行判断，所以先将两个指针指向数组两侧的边上，移动之后便指向了数组的首尾元素 while (i &lt; j) { do i ++; while (q[i] &lt; x); //while (q[++ i] &lt; x); do j --; while (q[j] &gt; x); //while (q[-- j] &gt; x); 这是不用do-while的写法 if (i &lt; j) swap(q[i], q[j]); } quick_sort(q, l, j); quick_sort(q, j + 1, r); } int main() { scanf(&quot;%d&quot;, &amp;n); int q[n]; for (int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot;, &amp;q[i]); quick_sort(q, 0, n - 1);//传入的是数组的下标区间 [0, n-1] for (int i = 0; i &lt; n; i ++) printf(&quot;%d &quot;, q[i]); return 0; } 分治的思想表现在：先将整个数组分为较大和较小两部分，这是一种宏观上的有序。再分别处理每个小部分，将其分为较大和较小两部分... 考虑最终的情况：处理到一个含2个元素的区间，将其分为两部分（实则就是对其进行了排序）；处理到1个含一个元素的区间，已经有序。 注意：在这种代码写法中，递归的基准值xxx不能任选。 在以[l,j][l, j][l,j]和[j+1,r][j+1, r][j+1,r]作为递归区间时，xxx的取值不可以为q[r]q[r]q[r]、q[l+r+12]q[\\frac{l+r+1}{2}]q[2l+r+1​] 在以[l,i−1][l, i-1][l,i−1]和[i,r][i, r][i,r]作为递归区间时，xxx的取值不可以为q[l]q[l]q[l]、q[l+r2]q[\\frac{l+r}{2}]q[2l+r​] 否则可能会出现同一个区间被一直递归下去成为死循环（边界问题）。 以数列 1 2 为例（下标为0,1），执行quickSort(0, 1)来对该数组进行排序，若取基准值x=q[r]=2x=q[r]=2x=q[r]=2，则在迭代中iii指针指向222后停止，jjj指针也指向222，迭代结束，此时2个子问题分别为f(l,j)=f(0,1)，f(j+1,r)=f(2,1)。可见子问题仍有f(0,1)，也就进入了无限递归了（MLE）。 推荐做法是：背一个正确的模版....... ","link":"https://shaoyihao.github.io/blog/快速排序/"},{"title":"地毯填补","content":" 原题链接：地毯填补 题目大意：给定一个 2k×2k2^k\\times 2^k2k×2k 的正方形网格，其中一个格子不能被填充（“黑格”）。给定 444 种地毯： 如何将整个正方形网格填满？ 思路：首先从简单的情形开始考虑，对于 2×22\\times 22×2 的网格：显然无论哪个格子不能被填充，我们都可以用一块毯子填满： 最简单的情形可以解决后，对于一般的情形，可以采用以下方法： 通过上面的方法，2k×2k2^k\\times 2^k2k×2k 网格中有一个“黑格”，可以将其转化为 444 个 2k−1×2k−12^{k-1}\\times 2^{k-1}2k−1×2k−1 的网格中各有一个“黑格”。即将原问题转化为 444 个同类型的子问题，体现了 分治 的思想。不断解决每个子问题，当所有子问题都解决完后，整个网格也就铺满了。 具体思路为：首先将网格分为 444 部分，判断“黑格”位于哪一部分，在其余3部分的交汇处放置一个L型地毯。 此时问题被划分为 444 个子问题，只需分别递归求解即可。 需要注意的是整个函数的功能为：处理一个2k×2k2^k\\times 2^k2k×2k网格，“黑格”位于其中(x,y)(x,y)(x,y)处。即坐标(x,y)(x,y)(x,y)是相对于当前规模的网格图而言的，因此在递归时由于处理的子问题网格图发生了变化，相应的，(x,y)(x,y)(x,y)也要随之改变。 例如，若原本“黑格”位于(2k−1+1, 2k−1+1)(2^{k-1}+1, \\ 2^{k-1}+1)(2k−1+1, 2k−1+1)，在划分之后，子问题④中，“黑格”的坐标为(1,1)(1,1)(1,1) 。 而本题要求在输出时，坐标是基于整个网格图而言，因此如何在子问题中也能得出相对于整体的坐标呢？ 此处采用的方法是：记录子问题相对于原问题的坐标偏移量。 接着上面的例子，子问题④中的坐标 (x,y)(x,y)(x,y)整体上看其实是(x+2k−1,y+2k−1)(x+2^{k-1},y+2^{k-1})(x+2k−1,y+2k−1)，此处坐标的偏移量就是：dx=2k−1,dy=2k−1dx=2^{k-1},dy=2^{k-1}dx=2k−1,dy=2k−1 。 坐标偏移量之间还具有传递性。例如若R2\\R_2R2​中的坐标(x,y)(x,y)(x,y)在R1\\R_1R1​中其实是(x+dx1,y+dy1)(x+dx_1,y+dy_1)(x+dx1​,y+dy1​)，R3\\R_3R3​中的坐标(x,y)(x,y)(x,y)在R2\\R_2R2​中其实是(x+dx2,y+dy2)(x+dx_2,y+dy_2)(x+dx2​,y+dy2​)，则其在R1\\R_1R1​中的坐标为：(x+dx1+dx2, y+dy1+dy2)(x+dx_1+dx_2,\\ y+dy_1+dy_2)(x+dx1​+dx2​, y+dy1​+dy2​) 。 综上，在递归处理子问题时，要注意修改①**“黑格”的相对坐标**、②子问题中所有坐标相对于初始坐标的偏移量。 #include &lt;iostream&gt; using namespace std; void dfs(int k, int x, int y, int dx, int dy) { if (k == 0) return; //递归出口 int t = 1 &lt;&lt; (k - 1); //这个值下面经常要用，因此单独提出来 if (x &lt;= t &amp;&amp; y &lt;= t) //“黑格”位于左上 { cout &lt;&lt; t + 1 + dx &lt;&lt; ' ' &lt;&lt; t + 1 + dy &lt;&lt; ' ' &lt;&lt; 1 &lt;&lt; endl; //相对于整体的坐标 dfs(k - 1, x, y, dx, dy); //左上子问题 dfs(k - 1, t, 1, dx, dy + t); //右上子问题 dfs(k - 1, 1, t, dx + t, dy); //左下子问题 dfs(k - 1, 1, 1, dx + t, dy + t); //右下子问题 } else if (x &lt;= t &amp;&amp; y &gt;= t + 1) //“黑格”位于右上 { cout &lt;&lt; t + 1 + dx &lt;&lt; ' ' &lt;&lt; t + dy &lt;&lt; ' ' &lt;&lt; 2 &lt;&lt; endl; dfs(k - 1, t, t, dx, dy); dfs(k - 1, x, y - t, dx, dy + t); dfs(k - 1, 1, t, dx + t, dy); dfs(k - 1, 1, 1, dx + t, dy + t); } else if (x &gt;= t + 1 &amp;&amp; y &lt;= t) //“黑格”位于左下 { cout &lt;&lt; t + dx &lt;&lt; ' ' &lt;&lt; t + 1 + dy &lt;&lt; ' ' &lt;&lt; 3 &lt;&lt; endl; dfs(k - 1, t, t, dx, dy); dfs(k - 1, t, 1, dx, dy + t); dfs(k - 1, x - t, y, dx + t, dy); dfs(k - 1, 1, 1, dx + t, dy + t); } else //“黑格”位于右下 { cout &lt;&lt; t + dx &lt;&lt; ' ' &lt;&lt; t + dy &lt;&lt; ' ' &lt;&lt; 4 &lt;&lt; endl; dfs(k - 1, t, t, dx, dy); dfs(k - 1, t, 1, dx, dy + t); dfs(k - 1, 1, t, dx + t, dy); dfs(k - 1, x - t, y - t, dx + t, dy + t); } } int main() { int k, x, y; cin &gt;&gt; k &gt;&gt; x &gt;&gt; y; dfs(k, x, y, 0, 0); //初始时无偏移 return 0; } ","link":"https://shaoyihao.github.io/blog/地毯填补/"},{"title":"棋子移动","content":" 原题链接：棋子移动 在处理长度为 nnn 的串时，其中包含了对 长度为 n−1n-1n−1 的串的处理，从而可以递归求解。 n=4n=4n=4 时直接打表即可。 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int n; void print(string str, int t) { cout &lt;&lt; str &lt;&lt; endl; if (t == 4) { string s; for (int i = 0; i &lt; n - 4; i ++) s += &quot;o*&quot;; cout &lt;&lt; &quot;ooo--***o*&quot; + s &lt;&lt; endl; cout &lt;&lt; &quot;ooo*o**--*&quot; + s &lt;&lt; endl; cout &lt;&lt; &quot;o--*o**oo*&quot; + s &lt;&lt; endl; cout &lt;&lt; &quot;o*o*o*--o*&quot; + s &lt;&lt; endl; cout &lt;&lt; &quot;--o*o*o*o*&quot; + s &lt;&lt; endl; return; } swap(str[t - 1], str[2 * t]); swap(str[t], str[2 * t + 1]); cout &lt;&lt; str &lt;&lt; endl; swap(str[t - 1], str[2 * (t - 1)]); swap(str[t], str[2 * (t - 1) + 1]); print(str, t - 1); } int main() { cin &gt;&gt; n; string str; for (int i = 1; i &lt;= n; i ++) str += &quot;o&quot;; for (int i = 1; i &lt;= n; i ++) str += &quot;*&quot;; str += &quot;--&quot;; print(str, n); return 0; } ","link":"https://shaoyihao.github.io/blog/棋子移动/"},{"title":"无限字符串","content":" 原题链接：无限字符串 题目大意：给定一个字符串strstrstr，定义一种操作为：将strstrstr的最后一个字符移到字符串的首位置，将这个新得到的字符串接到strstrstr的后面，则每次执行完该操作都会使字符串的长度扩大 111 倍，反复执行该操作，所得字符串的长度就将是无限长。例如：COW→COW WCO→COWWCO OCOWWC→⋯COW\\rightarrow COW\\ WCO\\rightarrow COWWCO\\ OCOWWC\\rightarrow\\cdotsCOW→COW WCO→COWWCO OCOWWC→⋯ 给定初始字符串，求所得无限字符串中第 NNN 个字符是什么？（N≤1018N \\leq 10^{18}N≤1018） 思路：设初始字符串的长度为lenlenlen，每次操作都使得字符串长度增加 111 倍。因为要研究的只是无限字符串中第 NNN 个字符，因此不用考虑“无限”，从长度为 ttt 的字符串开始分析即可，ttt 满足：t2≤N&lt;t\\frac{t}{2}\\le N&lt; t2t​≤N&lt;t 。 long long t = len; while (t &lt;= N) t *= 2; 对于长度为 ttt 的字符串sss，由于它是由长度为 t2\\frac{t}{2}2t​ 的字符串s12s_{\\frac{1}{2}}s21​​操作而来，因此它的形式满足： 可见，要想在长度为 ttt 的字符串sss中找到 第 kkk（k≤tk\\le tk≤t）个字符，可以运用分治的思想： 若 t=lent=lent=len，即 s=strs=strs=str，也就是在原始字符串中找第 kkk 个字符，直接返回即可 str[k]str[k]str[k] 若 k≤t2k\\le\\frac{t}{2}k≤2t​，则 s[k]=s12[k]s[k]=s_{\\frac{1}{2}}[k]s[k]=s21​​[k]，直接在左半段寻找即可：到 s12s_{\\frac{1}{2}}s21​​ 中寻找第 kkk 个字符 若 k=t2+1k = \\frac{t}{2}+1k=2t​+1，则 s[t2+1]=s12[t2]s[\\frac{t}{2}+1]=s_{\\frac{1}{2}}[\\frac{t}{2}]s[2t​+1]=s21​​[2t​]，因此就需要到 s12s_{\\frac{1}{2}}s21​​ 中寻找第 t2\\frac{t}{2}2t​ 个字符 若 k&gt;t2+1k&gt;\\frac{t}{2}+1k&gt;2t​+1，则 s[k]=s12[k−t2−1]s[k]=s_{\\frac{1}{2}}[k-\\frac{t}{2}-1]s[k]=s21​​[k−2t​−1]，即：需要到 s12s_{\\frac{1}{2}}s21​​ 中寻找第 k−t2−1k-\\frac{t}{2}-1k−2t​−1 个字符 char dfs(long long t, long long u) //返回长度为t的字符串中第u个字符 { if (t == len) return str[u]; else if (u == t / 2 + 1) return dfs(t / 2, t / 2); else if (u &gt; t / 2 + 1) return dfs(t / 2, u - t / 2 - 1); else return dfs(t / 2, u); } 保证分类没有遗漏。 #include &lt;iostream&gt; #include &lt;cstring&gt; using namespace std; char str[31]; int len; char dfs(long long t, long long u) //返回长度为t的字符串中第u个字符 { if (t == len) return str[u]; else if (u == t / 2 + 1) return dfs(t / 2, t / 2); else if (u &gt; t / 2 + 1) return dfs(t / 2, u - t / 2 - 1); else return dfs(t / 2, u); } int main() { scanf(&quot;%s&quot;, str + 1); len = strlen(str + 1); long long N, t = len; cin &gt;&gt; N; while (t &lt;= N) t *= 2; cout &lt;&lt; dfs(t, N); return 0; } N&gt;len⇒N≥2lenN&gt;len\\Rightarrow N\\ge 2lenN&gt;len⇒N≥2len，t2≤N&lt;t\\frac{t}{2}\\le N&lt;t2t​≤N&lt;t，t≥4lent\\ge 4lent≥4len 非递归写法： #include &lt;iostream&gt; #include &lt;cstring&gt; using namespace std; char s[31]; long long N; int main() { scanf(&quot;%s&quot;, s + 1); cin &gt;&gt; N; int len = strlen(s + 1); while (N &gt; len) { long long t = len; while (t &lt;= N) t *= 2; if (N == t / 2 || N == t / 2 + 1) N = t / 4 - 1; else N = N - t / 2 - 1; } cout &lt;&lt; s[N]; return 0; } ","link":"https://shaoyihao.github.io/blog/无限字符串/"},{"title":"组合搜索","content":" 原题链接：选数 题目大意：从 nnn 个数中任选 kkk 个相加，求所得的和中有多少个质数。 思路：本题就是在考察如何在 nnn 个数中枚举 kkk 元组，显然方案数有：CnkC_n^kCnk​ 种。 搜索时关键是要做到不重不漏。关键就是要做到“不减遍历”，即本次搜索到的 kkk 个下标一定比 上次搜索到的 kkk 个下标要大。直观上看就是 kkk 个指针都在逐渐右移。 参考：用递归进行枚举 #include &lt;iostream&gt; using namespace std; const int N = 22; int a[N], n, k, res; bool st[N]; bool isPrime(int x) { if (x &lt; 2) return false; for (int i = 2; i &lt;= x / i; i ++) if (x % i == 0) return false; return true; } // u记录当前已经枚举的元素个数，sum为当前的元素和，begin记录枚举的起始下标 void dfs(int u, int sum, int begin) { if (u == k) { if (isPrime(sum)) res ++; return; } for (int i = begin; i &lt; n; i ++) if (st[i] == false) { st[i] = true; dfs(u + 1, sum + a[i], i + 1); st[i] = false; } } int main() { cin &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; n; i ++) cin &gt;&gt; a[i]; dfs(0, 0, 0); cout &lt;&lt; res; return 0; } ","link":"https://shaoyihao.github.io/blog/组合搜索/"},{"title":"用递归进行枚举","content":" 递归枚举的关键是顺序。 考虑如何将枚举的顺序转化为一个树的遍历。 考虑代码中递归函数需要有哪些参数。 组合型枚举 枚举所有子集 输出{1,2,...,n}\\{1, 2, ..., n\\}{1,2,...,n}的所有子集。 按1∼n1\\sim n1∼n的顺序，依次考虑每个数选或不选。总数为：2n2^n2n。 每个数都有3种状态：选、不选、未考虑。用一个数组来存储。 #include &lt;iostream&gt; using namespace std; const int N = 16; int st[N]; //3种状态：0表示未考虑、1表示选、2表示不选 int n; void dfs(int u) { if (u &gt; n) //搜索结束 { for (int i = 1; i &lt;= n; i ++) if (st[i] == 1) cout &lt;&lt; i &lt;&lt; ' '; puts(&quot;&quot;); return; } st[u] = 2; //分支1：不选 dfs(u + 1); st[u] = 0; //恢复现场，由于接下来紧接着就赋st[u]=1，因此此处该步可以省略 st[u] = 1; //分支2：选 dfs(u + 1); st[u] = 0; } int main() { cin &gt;&gt; n; dfs(1); //从第1个数开始 return 0; } 如果要将所有的子集进行存储，由于各子集中的元素个数不同，因此应采用变长数组vector来存储较方便。 #include &lt;iostream&gt; #include &lt;vector&gt; using namespace std; const int N = 16; int st[N]; int n; vector&lt; vector&lt;int&gt; &gt; p; void dfs(int u) { if (u &gt; n) { vector&lt;int&gt; s; for (int i = 1; i &lt;= n; i ++) if (st[i] == 1) s.push_back(i); p.push_back(s); return; } st[u] = 2; dfs(u + 1); st[u] = 0; //分支1：不选 st[u] = 1; dfs(u + 1); st[u] = 0; //分支2：选 } int main() { cin &gt;&gt; n; dfs(1); for (int i = 0; i &lt; p.size(); i ++) { for (int j = 0; j &lt; p[i].size(); j ++) cout &lt;&lt; p[i][j] &lt;&lt; ' '; puts(&quot;&quot;); } return 0; } 位运算优化 一个含有nnn个元素的集合，有2n2^n2n个子集，可以用一个nnn位二进制串来表示一个子集。二进制串中的一位代表集合中的一个元素，若该位为1，表示该子集中有该元素；若该位为0，表示该子集中没选该元素。 将该二进制串转化为十进制数，从而就可以用一个十进制来代表一个子集。十进制数的范围为：0∼2n−10\\sim 2^n-10∼2n−1。 int tot = 1 &lt;&lt; n; // 子集数目 for (int t = 0; t &lt; tot; t ++) // 枚举每个子集 { for (int i = 0; i &lt; n; i ++) //枚举该十进制数的二进制形式中的每一位 if (t &gt;&gt; i &amp; 1) cout &lt;&lt; i + 1 &lt;&lt; ' '; //该位是1，表示该子集中存在该元素。 puts(&quot;&quot;); } 枚举元素数目固定的子集 nnn个元素枚举所有kkk元子集，总数为：CnkC_n^kCnk​ 。 一个含 kkk 个元素的序列有 k!k!k! 种全排列，为保证只输出其中的一种，在枚举时，这 k!k!k! 个序列中只取升序的那一个。 因此递归搜索函数中需要再加入一个参数，存储最小可以从哪个数开始枚举。 #include &lt;iostream&gt; using namespace std; const int N = 30; int n, m; int p[N]; void dfs(int u, int start) //对第u个位置上应存储的数进行搜索，从start开始（从小到大）。 { if (u &gt; m) //位置放满了 { for (int i = 1; i &lt;= m; i ++) cout &lt;&lt; p[i] &lt;&lt; ' '; puts(&quot;&quot;); return; } for (int i = start; i &lt;= n; i ++) //枚举第u位上可以放的数 { p[u] = i; dfs(u + 1, i + 1); //第u+1位存储的数要比第u位存储的数大 p[u] = 0; //恢复现场（此处该句也可省略） } } int main() { cin &gt;&gt; n &gt;&gt; m; dfs(1, 1); return 0; } 注意到：当枚举第uuu位上放哪个数时，此时已经确定了u−1u-1u−1位，还有n−start+1n-start+1n−start+1个数可供选择，若u-1 + n-start+1 &lt; m，则即使将后面所有可选的数都选上也无法存满mmm个数，即一定无解，可提前退出，这就是“剪枝”。 void dfs(int u, int start) { if (u - 1 + n - start + 1 &lt; m) return; //剪枝 if (u &gt; m) { for (int i = 1; i &lt;= m; i ++) cout &lt;&lt; p[i] &lt;&lt; ' '; puts(&quot;&quot;); return; } for (int i = start; i &lt;= n; i ++) { p[u] = i; dfs(u + 1, i + 1); p[u] = 0; //恢复现场（此处该句也可省略） } } 排列型枚举 枚举全排列 总数为：n!n!n! 。 依次枚举每个位置放哪个数。 也可依次枚举每个数放哪个位置，但这样输出时并不是字典序。 #include &lt;iostream&gt; using namespace std; const int N = 10; int path[N]; bool st[N]; int n; void dfs(int u) { if (u &gt; n) { for (int i = 1; i &lt;= n; i ++) cout &lt;&lt; path[i] &lt;&lt; ' '; puts(&quot;&quot;); return; } for (int i = 1; i &lt;= n; i ++) if (st[i] == false) { path[u] = i; st[i] = true; dfs(u + 1); path[u] = 0; st[i] = false; } } int main() { cin &gt;&gt; n; dfs(1); return 0; } 枚举所有排列 nnn个数可以产生的排列有：∑i=1nAni\\sum\\limits_{i=1}^nA_n^ii=1∑n​Ani​种。 #include &lt;iostream&gt; using namespace std; const int N = 10; bool st[N]; int n; void dfs(int u, int a) // 第1个参数表示当前搜索的位，第2个参数表示当前结合产生的数的大小 { if (u == n) return; //n位都已经枚举结束，本层递归结束 for (int i = 1; i &lt;= n; i ++) if (st[i] == false) { st[i] = true; cout &lt;&lt; a * 10 + i &lt;&lt; endl; dfs(u + 1, a * 10 + i); //搜索下一位，此时生成的数变为a*10+i st[i] = false; } } int main() { cin &gt;&gt; n; dfs(0, 0); //从第0位开始搜索，a的初始值为0 return 0; } ","link":"https://shaoyihao.github.io/blog/用递归进行枚举/"},{"title":"解压字符串","content":" 原题链接：外星密码 题目大意：对于连续的若干个相同的子串 SSS 会压缩为 nSnSnS 的形式（nnn 是一个整数且 1≤n≤991\\leq n\\leq991≤n≤99），例如：字符串 CBCBCBCB 就压缩为 [4CB] 或者 [2[2CB]]，后面这种压缩之后再压缩的称为二重压缩（给定的数据最多只有十重压缩）。给定一个被压缩后的字符串，输出原本完整的字符串。 思路：这种具有递归形式的题目显然应递归求解。 题目所给定的字符串StrStrStr宏观上可以视作：cc[S]cc[S]cc，宏观上该字符串的解压过程就是：cc+S的解压字符串+cc+S的解压字符串+cc。因此只需编写一个用于解压 SSS 的函数即可。 在此之前我们需要先将 SSS 从整个字符串中取出。由于 SSS 是由[]包围着的且 SSS 中可能也含有嵌套的 []，因此取出 SSS 的关键就是如何找到最外层的 [] 。此处采用了栈，用的是“括号匹配”的思想。 string substr(string str, int t) // str下标t处为'['，返回后面紧跟的S { string sub; stack&lt;char&gt; op; op.push(str[t]); //将 S 前面的 '[' 入栈 for (int i = t + 1; i &lt; str.size(); i ++) //遍历后面的字符，直到遇到上面'['所匹配的']' { if (str[i] == '[') op.push(str[i]); else if (str[i] == ']' &amp;&amp; op.size() &gt; 1) op.pop(); //嵌套 else if (str[i] == ']' &amp;&amp; op.size() == 1) break; //遇到了 sub += str[i]; //将'['和']'之间的所有字符都存储下来 } return sub; } 取出 SSS，接下来就要考虑如何对其进行解压。注意到 SSS 的形式大概是 Ncc[S']cc[S']cc，即一个数字NNN后面再跟着一个字符串，而这个字符串中可能也包含需要解压的部分，而解压它与解压 SSS 是完全相同的过程，可见这是一个递归解压的过程。不过不必想的太过复杂，我们只需做好当下即可。 首先将 SSS 中的数字 NNN 取出： int t = 0, N = 0; while (isdigit(str[t])) { N = N * 10 + str[t] - '0'; t ++; } // 取出数字N，且此时t指向首个非数字字符 字符串中的数字要特别关注，因为一个数字可能有好几位，多个字符。 遍历后面的字符，若遇到普通字母，则直接加入结果，若遇到[，则再取出后面的子串进行解压，将解压结果加入结果。 for (int i = t; i &lt; str.size(); i ++) if (isalpha(str[i])) tmp += str[i]; else if (str[i] == '[') //包含需要解压的子串 { string sub = substr(str, i); //取出后面的整个子串 tmp += f(sub); //将解压结果加入 i = i + sub.size() + 1; //i跳到'['所对应的右中括号处 } 最后将所得字符串重复 NNN 次即得 SSS 的解压结果。完整过程为： string f(string str) //解压字符串str { int t = 0, N = 0; while (isdigit(str[t])) { N = N * 10 + str[t] - '0'; t ++; } //取出数字num string res, tmp; for (int i = t; i &lt; str.size(); i ++) //从数字后的第一个字符开始遍历 if (isalpha(str[i])) tmp += str[i]; else if (str[i] == '[') { string sub = substr(str, i); //取出需要解压的完整子串 tmp += f(sub); i = i + sub.size() + 1; //i跳至该子串的末尾 } while (N --) res += tmp; //重复N遍 return res; } 注意：处理所给数据StrStrStr 与 解压StrStrStr中的SSS 是有略微区别的，因为题目所给的字符串前面并没有数字，而SSS总会以数字开头。因此主程序中对StrStrStr的处理不能直接使用所编写的解压函数。 完整代码： #include &lt;iostream&gt; #include &lt;stack&gt; using namespace std; string substr(string str, int t) { string substring; stack&lt;char&gt; op; op.push(str[t]); for (int i = t + 1; i &lt; str.size(); i ++) { if (str[i] == '[') op.push(str[i]); else if (str[i] == ']' &amp;&amp; op.size() &gt; 1) op.pop(); else if (str[i] == ']' &amp;&amp; op.size() == 1) break; substring += str[i]; } return substring; } string f(string str) { int t = 0, N = 0; while (isdigit(str[t])) { N = N * 10 + str[t] - '0'; t ++; } string res, tmp; for (int i = t; i &lt; str.size(); i ++) if (isalpha(str[i])) tmp += str[i]; else if (str[i] == '[') { string sub = substr(str, i); tmp += f(sub); i = i + sub.size() + 1; } while (N --) res += tmp; return res; } int main() { string str, res; cin &gt;&gt; str; for (int i = 0; i &lt; str.size(); i ++) if (isalpha(str[i])) res += str[i]; else if (str[i] == '[') { string sub = substr(str, i); res += f(sub); i = i + sub.size() + 1; } cout &lt;&lt; res; return 0; } 更加巧妙的代码： #include &lt;iostream&gt; using namespace std; string read() //返回所读字符串的解压结果 { string res; char c; while (cin &gt;&gt; c) //每次读入一个字符 if (isalpha(c)) res += c; else if (c == '[') { int n; cin &gt;&gt; n; //读入数字 string sub = read(); //解压后面的字符串并加入结果 while (n --) res += sub; } else if (c == ']') return res; //本层递归结束，回到上一层 } int main() { cout &lt;&lt; read(); return 0; } 模拟一下AC[3FUN] ⟶\\longrightarrow⟶ ACFUNFUNFUN，好好体会上面的代码。 ","link":"https://shaoyihao.github.io/blog/解压字符串/"},{"title":"基于递推的递归","content":"递归的基本思想是某个函数直接或者间接地调用自身，这样原问题的求解就转换为了许多类型相同但是规模更小的子问题。求解时只需要关注如何把原问题划分成符合条件的子问题，而不需要过分关注这个子问题是如何被解决的。最终base case定义了最简子问题的答案。 写递归的要点：明白一个函数的作用并相信它能完成这个任务，千万不要跳进这个函数里面企图探究更多细节， 否则就会陷入无穷的细节无法自拔。 在处理递归时，要思考： 所设计的函数的功能是什么？ 递归的结束条件（出口）是什么？ 如何将较复杂的问题转化为若干个简单的同类型问题？递归调用函数时，函数的参数发生了什么变化？ 基于递推关系的递归 若一个问题可以归结为一个递推式，则可以用递归来处理。递推的初始值就是递归的base case。 容易发现，递归也常用于解决动态规划问题。 def f(参数列表): if (base case) return 最小子问题解 else 递推关系 斐波那契数列 {f(0)=0 f(1)=1 f(n)=f(n−1)+f(n−2), n≥2\\left\\{\\begin{matrix} f(0)=0 \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\\\ f(1)=1\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\\\f(n)=f(n-1)+f(n-2),\\ \\ \\ n\\ge 2 \\end{matrix}\\right. ⎩⎨⎧​f(0)=0 f(1)=1 f(n)=f(n−1)+f(n−2), n≥2​ O(2n)O(2^n)O(2n) int f(int n) { if (n == 0) return 0; else if (n == 1) return 1; else return f(n - 1) + f(n - 2); } 求n!n!n! {0!=1 n!=n×(n−1)!\\left\\{\\begin{matrix}0!=1\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\\\n!=n\\times(n-1)!\\end{matrix}\\right. {0!=1 n!=n×(n−1)!​ int factorial(int n) { if (n == 0) return 1; else return factorial(n - 1) * n; } 最大公因数 {gcd(a, 0)=a gcd(a, b)=gcd(b, a%b)\\left\\{\\begin{matrix}gcd(a,\\ 0)=a\\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\ \\\\gcd(a,\\ b)=gcd(b,\\ a\\%b)\\end{matrix}\\right. {gcd(a, 0)=a gcd(a, b)=gcd(b, a%b)​ int gcd(int a, int b) { if (b == 0) return a; else return gcd(b, a % b); //简写为：return b ? gcd(b, a % b) : a; } 记忆化搜索 记忆化搜索是一种通过记录已经遍历过的状态的信息，从而避免对同一状态重复遍历的搜索实现方式，确保了每个状态只访问一次。 以计算斐波那契数列为例： memset(a, -1, sizeof(a)); int f(int n) { if (a[n] != -1) return a[n]; //之前已经计算过，直接返回 if (n == 0) a[n] = 0; else if (n == 1) a[n] = 1; else a[n] = f(n - 1) + f(n - 2); return a[n]; } ","link":"https://shaoyihao.github.io/blog/基于递推的递归/"},{"title":"2的幂次方表示","content":" 原题链接：2的幂次方表示 题目大意：给定一个正整数，输出该数的2的幂次方表示。例如： 137=27+23+20=2(7)+2(3)+2(0)=2(22+2+20)+2(2+20)+2(0)=2(2(2)+2+2(0))+2(2+2(0))+2(0)137=2^7+2^3+2^0\\\\=2(7)+2(3)+2(0)\\\\=2(2^2+2+2^0)+2(2+2^0)+2(0)\\\\=2(2(2)+2+2(0))+2(2+2(0))+2(0) 137=27+23+20=2(7)+2(3)+2(0)=2(22+2+20)+2(2+20)+2(0)=2(2(2)+2+2(0))+2(2+2(0))+2(0) 思路：对于一个数 XXX，如何快速地将其转化为 2a+2b+2c+...2^a+2^b+2^c+...2a+2b+2c+... 的形式？我们很自然地就会想到二进制，例如13=1101(2)13=1101_{(2)}13=1101(2)​在第0,2,30,2,30,2,3位上是1，因此 13=23+22+2013=2^3+2^2+2^013=23+22+20 。 可以借助STL中的 bitset 来实现判断 XXX 的二进制形式中某一位是否为 111 ： bitset&lt;16&gt; a(X); for (int i = 15; i &gt;= 0; i --) if (a.test(i)) // 判断第i位是否为1 { ... } 此处函数dfs(u)的功能就是求出参数uuu的 2的幂次方表示。首先将 uuu 转化为 2a+2b+2c+...2^a+2^b+2^c+...2a+2b+2c+... 的形式，再判断是否需要对a,b,c,...a,b,c,...a,b,c,...继续分解：注意到最终的2的幂次方表示中，单位项只有：2,2(0)2,2(0)2,2(0) 这2种，因此 iii 只要大于111，那它就需要再细分。【只有满足一定情况，才进行递归处理】 由于一个正整数最终一定会拆分至 2、12、12、1，因此最终递归一定会结束。 #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;bitset&gt; using namespace std; string res; void dfs(int u) { bitset&lt;16&gt; a(u); //将u转换为bitset处理 bool isFirstOne = true; for (int i = 15; i &gt;= 0; i --) //从高位到低位 if (a.test(i)) { if (isFirstOne == false) res += &quot;+&quot;; //若不是首项，则前面要添一个'+' else isFirstOne = false; if (i == 0) res += &quot;2(0)&quot;; else if (i == 1) res += &quot;2&quot;; else // i &gt; 1，可以继续分解，递归下去 { res += &quot;2(&quot;; dfs(i); res += &quot;)&quot;; } } } int main() { int x; cin &gt;&gt; x; dfs(x); cout &lt;&lt; res; return 0; } ","link":"https://shaoyihao.github.io/blog/2的幂次方表示/"},{"title":"Hanoi塔","content":"把一个问题划分为一个或多个规模更小的子问题，然后用相同的方法求解这些规模更小的子问题。值得注意的是，这些规模更小的子问题应与原问题保持同一类型。 def Hanoi(n, A, B, C): # 将A柱上的前n个碟子借助B移到C上 if (n == 1): move(1, A, C) # 将A柱上的前1个碟子直接移到C else: Hanoi(n - 1, A, C, B) # 先将前n-1个碟子移到B move(n, A, C) # 将第n个碟子移到C Hanoi(n - 1, B, A, C) # 将B上的n-1个碟子移到C #include &lt;stdio.h&gt; void move(char start, char target)//定义一个函数来描述单次移动动作 { printf(&quot;%c-&gt;%c\\n&quot;, start, target); } //将n个盘子从start上，借助other柱，移动到target上 void Hanoi(int n, char start, char other, char target) { if (n == 1) { move(start, target); return;//递归终止 } Hanoi(n - 1, start, target, other); //先将n-1个盘从start移到other（借助target柱） move(start, target); //把第n个盘子移动到target Hanoi(n - 1, other, start, target); //最后将n-1个盘子从orther移回target（借助start柱） } int main() { int n; scanf(&quot;%d&quot;, &amp;n); Hanoi(n, 'A', 'B', 'C'); return 0; } ","link":"https://shaoyihao.github.io/blog/汉诺塔/"},{"title":"波兰表达式（中序）","content":" 原题链接：波兰表达式 题目大意：求一个波兰表达式的结果。 背景知识 波兰表达式(Polish notation)、**逆波兰表达式(Reverse Polish notation，RPN)**是波兰数学家Jan Łukasiewicz的发明。 平时我们习惯将表达式写成 (1+2)×(3+4)(1 + 2) \\times (3 + 4)(1+2)×(3+4)，加减乘除等运算符写在中间，因此称呼为中缀表达式。 波兰表达式的写法为 × + 1 2 + 3 4\\times\\ +\\ 1\\ 2\\ +\\ 3\\ 4× + 1 2 + 3 4，将运算符写在前面，因而也称为前缀表达式。 逆波兰表达式的写法为 1 2 + 3 4 + ×1\\ 2\\ +\\ 3\\ 4\\ +\\ \\times1 2 + 3 4 + ×，将运算符写在后面，因而也称为后缀表达式。 波兰表达式和逆波兰表达式有个优点，就是不需要借助()来明确运算顺序，没有括号也不会有歧义。而中缀表达式假如去掉括号，意思往往会改变。 思路 波兰表达式PPP具有一种递归定义： 一个运算数是一个PPP，值就是该数本身 一个表达式 运算符 P P 是一个PPP，值就是表达式内两个PPP的值相运算的结果 根据表达式的首元是运算数还是运算符，就能知道该表达式的宏观组成，从而也就知道如何计算该表达式了。 本质上是二叉树的先序遍历。 double P() //返回该波兰表达式的值 { if (首元素是数字x) return x; else //首元素是运算符op { return P() op P(); } } #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; double p()//函数返回一个浮点数 { string str; cin &gt;&gt; str; //每调用一次函数就读取一个字符串（单个运算符或运算数） switch(str[0]) //判断读取的是运算符还是运算数 { case '+': return p() + p(); //返回接下来的两个波兰表达式的和 case '-': return p() - p(); case '*': return p() * p(); case '/': return p() / p(); default: return stof(str); //将字符串转化为浮点数 } } int main() { printf(&quot;%lf&quot;, p()); return 0; } ","link":"https://shaoyihao.github.io/blog/波兰表达式/"},{"title":"递归与调用栈","content":"调用栈 调用栈（Call Stack）描述的是函数之间的调用关系，它由多个栈帧（Stack Frame）组成。每个栈帧对应着一个未运行完的函数，栈帧中保存了该函数的返回地址和局部变量，因而不仅能在函数执行完毕后找到正确的返回地址，还很自然地保证了不同函数间的局部变量互不相干（因为不同函数对应着不同的栈帧）。 在gdb可以用 backtrace(简称bt)命令打印所有栈帧信息。若要用p命令打印一个非当前栈帧的局部变量，可以用frame命令选择另一个栈帧。 以一个简单的函数为例： def greet(name): greet2(name) bye() def greet2(name): print &quot;how are you, &quot; + name + &quot;?&quot; def bye(): print &quot;ok bye!&quot; 接下来再调用greet2(&quot;maggie&quot;)，同样，计算机也为这个函数调用分配一块内存（新建了一个栈帧），并且跳转到了函数开头处执行。 计算机使用一个栈来表示这些内存块，其中第二个内存块位于第一个内存块上面。 greet2(&quot;maggie&quot;)调用完后，栈顶的内存块被弹出。 此时栈顶的内存块是函数greet的，这意味着现在返回到了函数greet。当调用函数greet2时，函数greet只执行了一部分。调用下层函数时，当前函数暂停并处于未完成状态，该函数的所有变量的值都还在内存中。执行完函数greet2后，回到函数greet，此时会从离开的地方接着往下执行：调用函数bye。 在栈顶添加函数bye的内存块： 执行完bye后，又回到greet函数。此时由于没有别的事情要做，函数greet执行结束，退出。 递归与递归调用栈 递归函数就是不断调用自身，因此也运用到了调用栈。在C语言的函数中，调用自己和调用其他函数并没有任何本质区别，都是建立新栈帧，传递参数并修改当前代码行。在函数体执行完毕后删除栈帧，处理返回值并修改当前代码行。 以求阶乘的函数fact(3)为例： def fact(x): if (x == 1) return 1 return x * fact(x - 1) 执行过程： 每个fact调用都有自己的xxx变量，在一个函数调用中不能访问另一个的xxx变量。 使用栈虽然很方便，但是也要付出代价：存储详尽的信息可能占用大量的内存。因为每个函数调用都要占用一定的内存，如果递归层数很多，则栈很高，计算机就需要存储大量函数调用的信息。 ","link":"https://shaoyihao.github.io/blog/递归与调用栈/"},{"title":"NP完全理论","content":"判定问题与最优化问题 若一个问题的答案只有是或否两种，则称该问题为判定问题（decision problem）。 问题的输入其实就是一种问题的具体实例。 把判定问题抽象为一个从实例集映射到{0,1}\\{0, 1\\}{0,1}上的布尔函数，可以得到该函数的成真输入构成的集合： Lf={x ∣ f(x)=1}L_f=\\{x\\ |\\ f(x)=1\\} Lf​={x ∣ f(x)=1} 若一个问题有很多组解，其中每一个可行的解都有一个关联的值，我们希望找出一个具有最佳值的可行解，这种问题就称为最优化问题（optimization problem）。 通常，最优化问题都可以转化为一个判定问题（借助一个值kkk）。 一般认为，判定问题要“更容易一些”（或至少“不会更难”）。如果某个最优化问题很容易，那么其相关的判定问题也会很容易。 因为若可以容易的解决出最优化问题，那么就可以将求出的最优值与所要验证的值进行比较，从而得到判定问题的答案，因此此时解决判定问题也是容易的。 如果我们能够说明某个判定问题是个困难问题，那么也就说明了其相关的最优化问题也是困难的。 问题的归约 对于2个判定问题A,BA,BA,B，假设有一个过程，它可以将AAA的任意输入aaa转化成BBB的某种输入bbb，并且满足： 转换操作需要多项式时间。 两个输入得到的结果是相同的：AAA输入aaa时得到的结果是true，当且仅当BBB输入bbb时得到的结果是true。 这称为将问题AAA多项式时间归约到问题BBB，记为：A≤pBA\\le_pBA≤p​B，表示的含义是：AAA大于BBB的难度不会超过一个多项式时间因子。 归约（reduction）提供了一种在多项式时间内解决问题AAA的方法： 对于问题AAA的某种输入aaa，先以多项式时间将aaa转化为问题BBB的某种输入bbb 再求问题BBB在bbb下的结果 将该结果作为问题AAA在aaa下的结果 注意：BBB问题通常是要比AAA更加核心本质的。 定理：若A≤pBA\\le_p BA≤p​B，则 BBB是PPP类问题⇒\\Rightarrow⇒AAA是PPP类问题。 编码与形式语言体系 给定一种抽象判定问题Q：I→{0,1}Q：I\\rightarrow\\{0,1\\}Q：I→{0,1}，若将实例集III中的每种输入 编码为 01序列，得到{0,1}I→{0,1}\\{0,1\\}_I\\rightarrow \\{0,1\\}{0,1}I​→{0,1}，称此时的问题为具体问题(concrete problem)，记为e(Q)e(Q)e(Q)。 若具体问题输入的是一个长度为nnn的01序列，存在一个算法可以在O(nk)O(n^k)O(nk)时间内求解该问题，则称该具体问题是多项式时间可解的(polynomial-time solvable)。 求解问题的效率与实例的编码方式有关，如果不先指定编码，就不可能真正谈及对一个抽象问题的求解。 对于几种多项式相关的编码方式，问题本身是否多项式时间可解与选用这其中哪一种编码无关。 对一个抽象问题的实例，采用二进制或三进制来进行编码，对其“复杂性”都没有影响。但是如果对实例进行一元编码，则其复杂性可能会变化。 为了能够用一种与编码无关的方式进行描述，一般都假定用合理的、简洁的方式对问题实例进行编码。 通常默认的编码方式满足：一个整数的编码与其二进制表示是多项式相关的，并且一个有限集合的编码 与 相应的元素间用逗号隔开的列表的编码是多项式相关的 (ASCII 码就是这样的一种编码方案)。 字母表∑\\sum∑是符号的有限集合，∑∗\\sum^*∑∗是由表中符号组成的所有串构成的全集，∑∗\\sum^*∑∗的任一子集都是一种∑\\sum∑上的语言LLL。 因为每一个判定问题都是对应一个映射，完全可以用成真输入构成的集合来描述，因此每个判定问题都是一个∑={0,1}\\sum=\\{0,1\\}∑={0,1}上的语言LLL： L={x ∣ f(x)=1}L=\\{x\\ |\\ f(x)=1\\} L={x ∣ f(x)=1} 对于某判定问题的一种算法AAA，若输入串xxx，算法输出为true，则称该算法接受(accepts) xxx；若输出为false，则称该算法拒绝(rejects) xxx。 定义被算法接受的语言L1L_1L1​：对于语言中的所有输入，算法的输出都是true。 那是不是说若输入x≠L1x\\ne L_1x​=L1​，算法就会输出false呢？答案是否定的。 对于一种输入xxx，算法执行的结果并非只有true和false两种，还有可能是：算法不终止。 定义被算法判定的语言L2L_2L2​：对于语言中的所有输入，算法的输出要么是true，要么是false。 若对于任意x∈L1x\\in \\textcolor{#FF0000}{L_1}x∈L1​，算法可以在O(nk)O(n^k)O(nk)内接受xxx，则称：L1L_1L1​在多项式时间内被该算法接受（正确答案可以被快速验证）。 若对于任意输入（即x∈{0,1}∗x\\in\\textcolor{#FF0000}{\\{0, 1\\}^*}x∈{0,1}∗），算法可以在O(nk)O(n^k)O(nk)内判定 xxx是否属于L2L_2L2​（即算法能否在多项式时间内终止），则称L2L_2L2​在多项式时间内被该算法判定（正确答案、错误答案都能被快速验证）。 因此，要接受一个语言，算法只需可以根据L1L_1L1​中的串给出答案即可，但是要判定某一语言，算法需要可以对{0,1}∗\\{0,1\\}^*{0,1}∗中的所有串进行判定。 停机问题存在接受算法，但不存在判定算法。 可以由多项式时间算法判定的语言构成的集合 是 可以由多项式时间算法接受的语言构成的集合 的一个子集。 L2⊆L1L_2\\subseteq L_1 L2​⊆L1​ P、NP P类问题就是在多项式时间内可以解决的判定问题构成的集合。即：这些问题可以在时间O(nk)O(n^k)O(nk)内解决，其中kkk为某一常量，nnn是此问题输入的规模。 P={L:L可以在多项式时间内被判定}P=\\{L:L可以在多项式时间内被判定\\} P={L:L可以在多项式时间内被判定} 一般认为，在多项式时间（polynomial-time）内可解的问题是易处理的问题，在超多项式时间内解决的问题是不易处理的问题。 NP类问题是可以在多项式时间内验证给定的解是否成立的判定问题。 若给定一个PPP问题的解，要验证该解是否正确，可以重新计算一遍该问题，所用时间多项式时间，因此显然有： P⊆NPP\\subseteq NP P⊆NP 但NP⊆PNP\\subseteq PNP⊆P是否成立还尚未被证明，因此 P=?NPP\\stackrel{?}{=}NPP=?NP 仍是未解之谜。 大多数学者猜测P≠NPP\\ne NPP​=NP，理由是 经过多年尝试至今仍未找到任何一个NP-complete问题的有效算法，如果所有NP完全问题实际上都能在多项式时间内解决，那将是令人震惊的。 NP代表nondeterministic polynomial time，非确定多项式时间。即NP问题的另一种定义为：可以用非确定性多项式时间算法求解的判定问题构成的集合。 因此要想求出NP问题的一个解，可以采用非确定性算法，包括2个步骤： 随机猜测一个解 确定性验证该解是否为问题的解 （若本步所需时间为多项式时间，则称该算法为非确定性多项式时间算法。） 非确定性算法总会在某次执行中猜中一个解。 NP-hard与NP-complete 若所有NP问题都可以归约到判定问题BBB，则称问题BBB是NP-hard问题。 若判定问题BBB是NP问题，且 BBB也是NP-hard问题，则称该问题是NP-complete问题。 可以理解为，NP-complete问题是NP问题中“最难最核心”的。 停机问题不是NP-complete问题，是NP-hard问题。 定理：如果存在某个NP-complete问题可以在多项式时间内解决，则所有NP问题都有多项式时间的算法，P=NP。 目前，若明确了一个问题是NP-complete问题，那么就可以认为该问题特别难以处理，此时选用一种近似算法比较实际。 在证明某个问题是NP-complete问题时，我们是在陈述它是一个多么困难的问题。我们并不是要证明存在某个有效的算法，而是要证明不太可能存在有效的算法。 假设已经知道判定问题AAA不可能存在多项式时间算法，且存在一个多项式时间的归约算法可以将AAA的一种输入转化为判定问题BBB的一种输入。那么就可以用反证法来证明BBB不可能存在多项式时间算法。 NP-complete问题的证明 Cook-Levin定理：若一个NP-complete问题可以归约到判定问题LLL，则LLL是一个NP-hard问题。 可见我们需要先找到一个NP-complete问题，这样才能去证明别的问题也是NP-complete问题。 电路可满足问题（CircuitSAT） 已知一个由与、或、非门所组成的组合电路，判断该电路是否存在一组输入，能够使它的输出为1。 给定一个组合电路，通过检查输入的所有可能赋值来确定它是否是可满足性电路。如果有nnn个输入，就会有2n2^n2n种可能的赋值，总时间为Ω(2n)\\Omega(2^n)Ω(2n)，这与电路的规模呈超多项式关系。 可以证明电路可满足问题是NP-complete问题。 历史上第一个被证明的NP-complete问题其实是SAT问题。 证明判定问题LLL为NP-complete问题的一般方法为： 证明LLL为NP问题 证明LLL为NP-hard问题 选取一个已知的NP-complete问题AAA 构造一种函数fff，该函数可以将AAA的任意输入映射为LLL的某种输入 证明任意 x∈A⟺f(x)∈Lx\\in A\\Longleftrightarrow f(x)\\in Lx∈A⟺f(x)∈L 证明fff具有多项式运行时间 随着已知的NP-complete问题构成的集合越来越大，证明时可选择的就越多。 公式可满足性问题（SAT） 确定一个布尔公式是否是可满足的。 L={&lt;ϕ&gt;：ϕ是一个可满足的布尔公式}L=\\{&lt;\\phi&gt;：\\phi是一个可满足的布尔公式\\} L={&lt;ϕ&gt;：ϕ是一个可满足的布尔公式} 证明： 对于输入公式ϕ\\phiϕ，验证它的一个可满足性赋值所组成的证书时，将公式中的每个变量替换为其对应的值，再对公式进行求解，得到公式的最终结果，这很容易在多项式时间内完成。 因此SATSATSAT属于NP。 对于一个布尔组合电路CCC，将电路的每根线都对应一个变量，将逻辑门操作表示为相关线路变量的等价式（子句）。利用归纳法，最终可以在多项式时间内产生一个表示整个电路的布尔公式ϕ\\phiϕ，它是电路输出变量与描述每个门操作的子句的“与”。 若CCC具有一个可满足性赋值，则用线路中的值对ϕ\\phiϕ中每个变量赋值后，最后ϕ\\phiϕ的值为1；反之，如果存在ϕ\\phiϕ值为1, 则类似可证电路CCC是可满足的。 因此，CircuitSAT≤pSATCircuitSAT\\le_p SATCircuitSAT≤p​SAT，则SATSATSAT属于NP-hard。 3-CNF可满足性问题（3-CNF-SAT） 若合取范式中每个简单析取式都含有3个不同文字，则称该公式为3-CNF（conjunctive normal form）。 例如(x1∨¬x1∨¬x2)∧(x3∨x2∨x4)∧(¬x1∨¬x3∨¬x4)(x_1\\vee\\neg x_1\\vee\\neg x_2)\\land(x_3\\vee x_2\\vee x_4)\\land(\\neg x_1\\vee\\neg x_3\\vee\\neg x_4)(x1​∨¬x1​∨¬x2​)∧(x3​∨x2​∨x4​)∧(¬x1​∨¬x3​∨¬x4​)就是一个3-CNF。 给定一个3-CNF，判断它是否是可满足的。 证明： 对于输入公式ϕ\\phiϕ，验证它的一个可满足性赋值所组成的证书时，将公式中的每个变量替换为其对应的值，再对公式进行求解，得到公式的最终结果，这很容易在多项式时间内完成。 因此3−CNF−SAT3-CNF-SAT3−CNF−SAT属于NP。 对于任意一个布尔公式ϕ\\phiϕ，构造一棵二叉“语法分析树”，将文字作为叶子结点，逻辑联结词作为内部结点，使得树中的每一个内部结点上均有一个或者两个孩子。（如果公式中存在多个文字“连或”，可以利用结合律在表达式中加括号。） 如此就可以把该二叉语法分析树转化为一个布尔逻辑公式ϕ′\\phi&#x27;ϕ′：为每个内部顶点的输出设置一个变量yiy_iyi​，每个内部结点都可以用一个等价式（子句）来描述，最终得到一个描述整棵树的逻辑公式，它是根变量与所有顶点的子句的合取的“与”。 如此便把原始公式ϕ\\phiϕ转化成了一个合取式ϕ′\\phi&#x27;ϕ′，其中每个子句中至多只有3个文字。要想将ϕ′\\phi&#x27;ϕ′转化为3-CNF形式，可以将每个子句都转化为3-CNF（多个3-CNF的合取式仍是3-CNF）。 列出每个子句的真值表，选取成假赋值，写出ϕi′‾\\overline{\\phi_i&#x27;}ϕi′​​的析取范式（disjunctive normal form, DNF），再根据反演规则，得到ϕi′\\phi_i&#x27;ϕi′​的合取范式，且其中每个子句都至多含3个文字。 要想将ϕi′\\phi_i&#x27;ϕi′​转化为3-CNF，需要将其中不足3个文字的子句转化为恰好有3个不同文字。 如此便实现了 将ϕi′\\phi_i&#x27;ϕi′​等价转化为3-CNF形式，从而也就实现了将原始公式ϕ\\phiϕ等价转化为3-CNF形式。 容易证明，最终产生的3-CNF公式的长度是关于原始公式长度的多项式，因此可以在多项式时间内完成整个转化过程。 因此 SAT≤p3−CNF−SATSAT\\le_p 3-CNF-SATSAT≤p​3−CNF−SAT，则3−CNF−SAT3-CNF-SAT3−CNF−SAT属于NP-hard。 其它NP-complete问题 到目前为止，已经找到了大约4000个NP-complete问题。 01背包问题 已知一个物品集合sss和集合中每件物品的价值和重量，给定一个背包的最大承重为WWW，求出一个在不超过背包承重的前提下总价值最大的物品子集。 对应的判定问题为：给定一个整数kkk，判断能否求出一个物品子集，满足总质量不超过WWW且总价值 ≥k≥k≥k。 团问题 若无向图GGG的某个子图中任意2点均有边相连，则称该子图为完全子图，也称为团。将该完全子图中的结点数称为团的规模。 判定形式描述的团问题即：图GGG中是否存在一个规模为kkk的团？ Clique={&lt;G,k&gt;：G中含有规模为k的团}Clique=\\{&lt;G,k&gt;：G中含有规模为k的团\\} Clique={&lt;G,k&gt;：G中含有规模为k的团} 该判定问题生成的最优化问题即：最大团问题（MCP）：在一个无向图中找出一个规模最大的团。 顶点覆盖问题 若点集V′V&#x27;V′是无向图GGG的一个结点子集，且对于图中任意一条边，都存在该边的某个端点属于V′V&#x27;V′，则称V′V&#x27;V′为GGG的一个顶点覆盖（vertex cover）。V′V&#x27;V′的结点数称为该顶点覆盖的规模。 判定形式描述的顶点覆盖问题即：判断一个图中是否含有规模为kkk的顶点覆盖。 Vertex−Cover={&lt;G,k&gt;：G有一个规模为k的顶点覆盖}Vertex-Cover=\\{&lt;G,k&gt;：G有一个规模为k的顶点覆盖\\} Vertex−Cover={&lt;G,k&gt;：G有一个规模为k的顶点覆盖} 对应的最优化问题即：在一个给定的图中，找出规模最小的的顶点覆盖。 哈密顿回路问题 判断图GGG中是否存在经过每个结点一次且仅一次的回路。 旅行商问题（TSP） 已知一个含有nnn个结点的无向完全图GGG，起点固定，求总距离最小的哈密顿回路。解空间的大小为(n−1)!(n-1)!(n−1)!。 TSP={&lt;G,c,k&gt;:完全图G中包含一个最大总代价为k的哈密顿回路}TSP=\\{&lt;G,c,k&gt;:完全图G中包含一个最大总代价为k的哈密顿回路\\} TSP={&lt;G,c,k&gt;:完全图G中包含一个最大总代价为k的哈密顿回路} （ccc是V×V→ZV\\times V\\rightarrow\\mathbf{Z}V×V→Z上的一个函数，表示各边的权值。） 子集和问题 给定一个有限集合S⊆Z+S\\subseteq \\mathbf{Z^+}S⊆Z+，判断SSS是否存在一个子集，满足该子集的元素和为ttt。 SubsetSum={&lt;S,t&gt;:存在一个子集S′⊆S，使得∑i∈S′i=t}SubsetSum=\\{&lt;S,t&gt;:存在一个子集S&#x27;\\subseteq S，使得\\sum_{i\\in S&#x27;}i=t\\} SubsetSum={&lt;S,t&gt;:存在一个子集S′⊆S，使得i∈S′∑​i=t} 子图同构问题 给定两个无向图G1,G2G_1,G_2G1​,G2​，判断G1G_1G1​是否存在某个子图与G2G_2G2​同构。 集合划分问题 判断集合SSS能否被划分成两个集合，满足这两个集合的元素和相等。 最长简单回路问题 在图中找出一个具有最大长度的简单回路。 图着色问题 判断一个无向图能否kkk-染色。 最优化形式为：至少需要多少种颜色才能使图的相邻结点颜色不同。 集合覆盖问题（SCP） 已知全集UUU， 集合FFF是由UUU的某些子集构成的集合（即FFF中的元素是集合），且满足⋃s∈Fs=U\\bigcup\\limits_{s\\in F}s=Us∈F⋃​s=U。集合覆盖问题就是：在FFF中找出一个 元素最少的、满足并集为UUU的 子集。 （说白了就是在众多尺寸不一的地砖中选最少的砖来铺满房间。） 对应的判定问题：已知全集UUU，FFF是由UUU的某些子集构成的集合，给定一个正整数kkk，判断能否找到一个元素数为kkk的集合C⊆FC\\subseteq FC⊆F，满足CCC覆盖了UUU中所有元素。 装箱问题（Bin Packing） 已知nnn个质量不同的物品构成的集合，求最少需要用多少个载重量为WWW的箱子才能将这些物品装完。 对应的判定问题：给定kkk个相同的箱子，判断能否将这nnn个物品装入这kkk个箱子中。 ","link":"https://shaoyihao.github.io/blog/P与NP/"},{"title":"算法的基础理论","content":"基本概念 一般可以将问题形式化描述为： f(x) , x∈Sf(x)\\ ,\\ \\ \\ \\ \\ \\ x\\in S f(x) , x∈S 其中f(x)f(x)f(x)是一个目标函数，它表示解决问题的目的。如果目标是使问题达到某种最优，则称为最优化问题。 SSS称为解空间（或搜索空间），x∈Sx\\in Sx∈S称为约束条件，满足约束条件的xxx称为可行解。使目标函数取得最优值的可行解称为最优解。 有些问题需要找出最优解，而有些问题只需要找到一个可行解即可。 一种问题给定不同的条件，可以得到多个不同的具体问题，每个具体问题又称为问题实例（instance）。 （确定性）算法是解决问题的一种方法或一个过程，是一个由若干运算或指令组成的有穷序列。 算法的特点：有穷性、可行性、确定性、输入、输出。 确定性算法：对同一种输入，不管算法运行多少次，得到的输出都是一样的。 若输出可能不一样，则称为非确定性算法（或随机算法）。 若对于某种问题的所有实例，算法都能得到正确的输出，则称该算法是正确的。 利用循环不变量来证明算法的正确性 循环不变量(Loop Invariants) 是与迭代次数有关的一个语句。它在循环开始前，以及在每次迭代后都为真。 要证明算法的正确性，可以借助循环不变量： 首先证明循环不变量：对于循环的每次迭代jjj，循环不变量LjL_jLj​都为真。 再研究在循环终止时发生了什么，此时的循环不变量提供了怎样的信息。 基本步骤为： 初始步（Initialization）：在循环的第一次迭代之前，循环不变量为真。 归纳步（Maintenance）：若循环的第jjj次迭代前Lj−1L_{j-1}Lj−1​为真，则在循环的第jjj次迭代后，LjL_jLj​为真。 终止步（Termination）：当循环终止时，循环不变量为我们提供提供了一个有用的性质，该性质有助于证明算法是正确的。 以插入排序为例（从下标1开始存储）。 void InsertSort() { for (int i = 2; i &lt;= n; i ++) { int t = q[i], j = i - 1; while (j &gt;= 1 &amp;&amp; q[j] &gt; t) { q[j + 1] = q[j]; j --; } q[j + 1] = t; } } 循环不变量为：for循环的每次迭代开始时，子数组q[1∼i−1]q[1\\sim i-1]q[1∼i−1]由原来在q[1∼i−1]q[1\\sim i-1]q[1∼i−1]中的元素组成，但已按序排列。 初始步：第一次迭代之前，i=2i=2i=2，此时子数组q[1∼i−1]q[1\\sim i-1]q[1∼i−1]中仅含q[1]q[1]q[1]，就是原本就含的q[1]q[1]q[1]，且显然有序，因此第一次迭代之前循环不变式成立。 归纳步：非形式化地，循环体中的操作是将q[i−1],q[i−2],...q[i-1],q[i-2],...q[i−1],q[i−2],...等向右移动一个位置，直到找到q[i]q[i]q[i]的适当位置，再将q[i]q[i]q[i]的值插入到该位置。这时子数组q[1∼i]q[1\\sim i]q[1∼i]由原来在A[1∼i]A[1\\sim i]A[1∼i]中的元素组成，但已按序排列。因此for循环的下一次迭代之前，循环不变式仍成立。 终止步：循环终止时 j=n+1j=n+1j=n+1，由循环不变量可得：子数组q[1∼n]q[1\\sim n]q[1∼n]由原来在q[1∼n]q[1\\sim n]q[1∼n]中的元素组成，但已按序排列。即原数组已排序。 算法的效率评价 计算模型是一种实现算法的设备，例如图灵机、RAM等。不同计算模型的计算速度不同，但在抽象的计算能力上是等价的。即如果一个问题在某计算模型上可解，那么在其它计算模型上也是可解的。 算法的效率取决于算法本身，与计算模型无关。但由于不同计算模型的计算速度不同，因此分析不同的算法必须在同样的计算模型下才有意义。 算法关于给定实例的运行时间：该算法执行的基本运算的数目。 表示形式 定义 内涵 O(f(N))O(f(N))O(f(N)) 存在c、n0n_0n0​，使 N≥n0n_0n0​ 时，T(N) ≤ cf(N) 最终T(N)最多增长得和f(N)一样快（上界） Ω(f(N))\\Omega(f(N))Ω(f(N)) 存在c、n0n_0n0​，使 N≥n0n_0n0​ 时，T(N) ≥ cf(N) 最终T(N)至少增长得和f(N)一样快（下界） Θ(f(N))\\Theta(f(N))Θ(f(N)) 存在c1c_1c1​、c2c_2c2​、n0n_0n0​，使 N≥ n0n_0n0​ 时，c2c_2c2​f(N) ≥ T(N) ≥ c1c_1c1​f(N) 最终T(N)与f(N)以相同的阶数增长 注意：此处的O、Ω、ΘO、\\Omega、\\ThetaO、Ω、Θ都是一种表示集合的符号。例如：O(f(n))O(f(n))O(f(n))表示的是所有以cf(n)cf(n)cf(n)为上界的函数集合。 要证明f(n)=Θ(g(n))f(n)=\\Theta(g(n))f(n)=Θ(g(n))，除了用定义之外，还可以使用数学中的极限概念： 若lim⁡n→∞f(n)g(n)=c（常数），则f(n)=Θ(g(n))若\\lim_{n\\rightarrow \\infin}\\frac{f(n)}{g(n)}=c（常数），则f(n)=\\Theta(g(n)) 若n→∞lim​g(n)f(n)​=c（常数），则f(n)=Θ(g(n)) 同理： 若lim⁡n→∞f(n)g(n)≠∞，则f(n)=O(g(n))若lim⁡n→∞f(n)g(n)≠0，则f(n)=Ω(g(n))若\\lim_{n\\rightarrow \\infin}\\frac{f(n)}{g(n)}\\ne\\infin，则f(n)=O(g(n))\\\\若\\lim_{n\\rightarrow \\infin}\\frac{f(n)}{g(n)}\\ne 0，则f(n)=\\Omega(g(n)) 若n→∞lim​g(n)f(n)​​=∞，则f(n)=O(g(n))若n→∞lim​g(n)f(n)​​=0，则f(n)=Ω(g(n)) 一些性质： f(n)=Θ(g(n))⟺f(n)=O(g(n))且f(n)=Ω(g(n))f(n)=\\Theta(g(n))\\Longleftrightarrow f(n)=O(g(n))且f(n)=\\Omega(g(n)) f(n)=Θ(g(n))⟺f(n)=O(g(n))且f(n)=Ω(g(n)) f1(n)=O(g1(n)),f2(n)=O(g2(n))⟹f1(n)+f2(n)=O(max⁡{g1(n),g2(n)})f_1(n)=O(g_1(n)),f_2(n)=O(g_2(n))\\Longrightarrow f_1(n)+f_2(n)=O(\\max \\{g_1(n),g_2(n)\\}) f1​(n)=O(g1​(n)),f2​(n)=O(g2​(n))⟹f1​(n)+f2​(n)=O(max{g1​(n),g2​(n)}) 实际生活中，人们往往只关心最坏情况的运行时间，原因是： 一个算法的最坏情况运行时间给出了任何输入的运行时间的一个上界。知道了这个界，就能确保该算法绝不需要更长的时间。 对某些算法，最坏情况经常出现。 平均情况往往与最坏情况大致一样差。 O(log⁡N)&lt;O(N)&lt;O(N)&lt;O(NlogN)&lt;O(N2)&lt;O(2n)&lt;O(N!)&lt;O(NN)O(\\log N) &lt; O(\\sqrt{N}) &lt; O(N) &lt; O(NlogN) &lt; O(N^2) &lt; O(2^n) &lt; O(N!) &lt; O(N^N) O(logN)&lt;O(N​)&lt;O(N)&lt;O(NlogN)&lt;O(N2)&lt;O(2n)&lt;O(N!)&lt;O(NN) 问题的下界 问题的下界即解决该问题所必需的最小运行时间。通过对问题下界的研究可以帮助人们判断一个算法是否有改进的潜力。 问题 下界 n个元素找最大值 cncncn 矩阵相乘 cn2cn^2cn2 基于比较的排序 nlog⁡nn\\log nnlogn ","link":"https://shaoyihao.github.io/blog/算法理论/"}]}